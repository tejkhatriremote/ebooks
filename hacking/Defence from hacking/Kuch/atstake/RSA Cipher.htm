<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0048)http://www.muppetlabs.com/~breadbox/txt/rsa.html --><HTML><HEAD><TITLE>Prime Number Hide-and-Seek: How the RSA Cipher Works</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff>
<P align=center>
<CENTER>
<H1>Prime Number Hide-and-Seek: How the RSA Cipher Works </H1></CENTER>
<P>
<UL>Table of Contents 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#0">Preface: What 
  is This?</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#1">Introduction: 
  The Idea of a Trapdoor Function</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#2">Background, 
  Part I: How to Calculate with Exponents</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#3">Background, 
  Part II: Modulus Arithmetic</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#4">Background, 
  Part III: The Fundamental Theorem of Algebra</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#5">Background, 
  Part IV: Relatively Prime Numbers</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#6">Euler's 
  Totient Function</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#7">Euler's 
  Totient Theorem</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#8">Variations on 
  a Theme</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#9">The Plot 
  Thickens</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#10">Does This 
  Really Work?</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#11">Making a 
  Pair of Keys</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#12">An 
  Example</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#13">How to Crack 
  RSA</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#14">How to Make 
  RSA Uncrackable</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#15">Huge 
  Exponents in Modulus Arithmetic</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#16">Huge Factors 
  in Modulus Arithmetic</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#17">Safety in 
  Numbers</A> 
  <LI><A href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#18">Summing 
  Up</A> 
  <LI><A 
  href="http://www.muppetlabs.com/~breadbox/txt/rsa.html#19">References</A> 
</LI></UL>
<P><A name=0></A>
<H2>Preface: What is This? </H2>
<P>The RSA cipher is a fascinating example of how some of the most abstract 
mathematical subjects find applications in the real world. Few are the 
mathematicians who study creatures like the prime numbers with the hope or even 
desire for their discoveries to be useful outside of their own domain. But every 
now and then that is exactly what happens. 
<P>This text explains the mathematics behind RSA -- how and why it works. The 
intended audience is just about anyone who is interested in the topic and who 
can remember a few basic facts from algebra: what a variable is, the difference 
between a prime number and a composite number, and the like. 
<P>The most important mathematical facts necessary for understanding RSA's 
foundations are reviewed near the beginning. Even if you are familiar with 
everything covered in these sections, I would recommend that you at least skim 
through them. 
<P>In one or two places, I have specifically targeted an explanation to what I 
consider to be the average computer programmer, leveraging analogous concepts in 
programming and general mathematics. 
<P>Before getting started, I should make some observations on the mathematical 
notation used here. 
<P>For the most part, where notations for the same idea differ between standard 
mathematics and the common practices among computer programmers, I have stuck 
with the mathematicians. This is, after all, a mathematical subject. However, I 
have deviated in a few places where there was too much opportunity for 
confusion. I have used * to denote multiplication, and have completely avoided 
"implied" multiplication (i.e., using PQ as shorthand for P&nbsp;*&nbsp;Q). 
Since not all web browsers can display superscripts, I have used ^ to denote 
exponentiation. (This necessitates more parenthesizing than would normally be 
used.) The mathematician's three-bar congruency symbol is not available, so I 
have made do with = instead. Variables are always named with a single capital 
letter. 
<P>Finally, please note that throughout the text I use the word 
<DEF>number</DEF> to refer specifically to a positive integer -- what are 
sometimes referred to as the <DEF>natural</DEF> numbers, or <DEF>counting</DEF> 
numbers. 
<P>
<HR>

<P><A name=1></A>
<H2>Introduction: The Idea of a Trapdoor Function </H2>
<P>What a mathematician refers to as a <DEF>function</DEF> is very similar to a 
function in computer programming. It is, in essence, an abbreviation. For 
example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>F(X) = 7 * X + 43.</TD></TR></TBODY></TABLE>
<P>If X happens to be 3, then F(X) will be 64. So, "F(3)" is shorthand for 
"7&nbsp;*&nbsp;3&nbsp;+&nbsp;43". 
<P>The same function in a C program might look like: 
<P><PRE>        int F(int x)
        {
            return 7 * x + 43;
        }
</PRE>
<P>Of course, in a computer program, functions are used to encapsulate all kinds 
of algorithms, and frequently make use of external variables and the like. In 
mathematics, however, a function is used solely for the number it returns. And, 
given a certain number as input, they will always return the same output. (Thus, 
rand() would not qualify as a mathematical function, unless it were written so 
that the seed value was passed in as an input parameter.) 
<P>Mathematicians often consider how to construct a function's 
<DEF>inverse</DEF> -- taking a function and making a new one that "goes in the 
other direction", so to speak: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>G(X) = (X - 43) / 7.</TD></TR></TBODY></TABLE>
<P>G(64) is equal to 3, and in general, G(F(X)) is equal to X. Therefore, G is 
F's inverse. Not all functions are invertible, of course. Clearly, the function: 

<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>F(X) = X * 0</TD></TR></TBODY></TABLE>
<P>cannot be inverted. (Because how could G(F(X)) return X when F(X) is always 
zero?) 
<P>Usually, when you have a mathematical function for which an inverse does 
exist, constructing it is not too difficult. In fact, it is often transparent. 
Typically, you can just run through the steps backwards, subtracting where the 
original function adds, and so on. But can it be done for <EM>every</EM> 
invertible function? 
<P>To put the question in terms of programming, imagine that there are two 
functions: 
<P><PRE>        int foo(int x);
        int bar(int x);
</PRE>
<P>foo() and bar() work like mathematical functions -- they do nothing but 
compute a return value, and given the same number for input, they will always 
produce the same output. (And pretend for the moment that this is on a machine 
where integers can be arbitrarily large.) Suppose you are told that bar() is the 
inverse of foo(). The statement: 
<P><PRE>        x == bar(foo(x))
</PRE>
<P>is always true, as long as x meets foo()'s requirements for a valid argument. 

<P>Now, imagine that you have the source code for foo(), but not for bar(). Can 
you write your own replacement for bar(), just by examining foo()? 
<P>It seems that you ought to be able to. There are no secrets as to what foo() 
does, after all. You can run foo() with different inputs as many times as you 
like. You already know that bar() exists, somewhere, so you know that it is 
<EM>possible</EM> to write. Is it guaranteed that you can reconstruct it? 
<P>Theoretically speaking, the answer is yes. Given such an function, it is 
always possible to construct its inverse. However, if we also throw in the tiny 
constraint that you have to finish before the heat-death of the universe, the 
answer subtly changes. 
<P>There are some special functions that, though what they do is simple enough, 
and how they do what they do is utterly transparent, figuring out how to 
<EM>undo</EM> what they do is a diabolical task. Such a creature is a 
<DEF>trapdoor function</DEF>. Anyone can fall through a trapdoor, but only those 
who know where the hidden lever is can climb back out again. 
<P>In 1975, Whitfield Diffie, Martin E. Hellman, and Ralph Merkle realized that 
a trapdoor function could be the basis for an entirely new kind of cipher -- one 
in which the decoding method could remain secret even when the encoding method 
was public knowledge. Diffie and Hellman published a paper in 1976 that 
described this idea, and offered some examples of weak trapdoor functions. And 
in 1977, Ronald L. Rivest, Adi Shamir, and Leonard Adleman outlined, in an MIT 
technical memo, an excellent candidate that became the basis for the RSA cipher. 

<P>What follows is a description of that function. 
<P>
<HR>

<P><A name=2></A>
<H2>Background, Part I: How to Calculate with Exponents </H2>
<P>Here's a quick refresher on how to combine exponents. Recall that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>N^2</TD>
    <TD align=left>= N * N,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>N^3</TD>
    <TD align=left>= N * N * N,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>N^4</TD>
    <TD align=left>= N * N * N * N,</TD></TR></TBODY></TABLE>
<P>
<P>and so on. For example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>2^7 = 2 * 2 * 2 * 2 * 2 * 2 * 2 = 128.</TD></TR></TBODY></TABLE>
<P>If we fiddle with exponents for a bit, we will quickly realize that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>N^E * N = N^(E + 1).</TD></TR></TBODY></TABLE>
<P>So, for example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>2^7 * 2 = 128 * 2 = 256 = 2^8.</TD></TR></TBODY></TABLE>
<P>Building upon this, we can also see that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>N^E * N * N = N^(E + 2).</TD></TR></TBODY></TABLE>
<P>But N&nbsp;*&nbsp;N can also be written as N^2: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>N^E * N^2 = N^(E + 2).</TD></TR></TBODY></TABLE>
<P>We can extrapolate from this, and derive a more general rule -- namely: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>N^A * N^B = N^(A + B).</TD></TR></TBODY></TABLE>
<P>And, if we repeated this process on the next level up, we would find that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>(N^A)^B = N^(A * B).</TD></TR></TBODY></TABLE>
<P>These two simple facts are very useful when handling exponent-laden formulas. 

<P><A name=3></A>
<H2>Background, Part II: Modulus Arithmetic </H2>
<P>Most computer programmers are familiar with modulus as a "remainder" 
operator, usually denoted by "%", which gives the remainder of an integer 
division instead of the quotient. For example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>27 % 12 = 3.</TD></TR></TBODY></TABLE>
<P>Though the idea is the same, the mechanics here are slightly different from 
what mathematicians refer to as <DEF>modulus arithmetic</DEF>. In essence, 
modulus arithmetic consists of taking the infinitely long number-line and 
coiling it around a finite circle. All the numbers that land on the same point 
along the circle's edge are considered interchangeable, or <DEF>congruent</DEF>. 
Thus, the analogue to the above example in modulus arithmetic would be expressed 
as: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>27 = 3 (mod 12),</TD></TR></TBODY></TABLE>
<P>or, in words: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>27 is congruent to 3, modulo 12.</TD></TR></TBODY></TABLE>
<P>(Though note that mathematicians actually use a three-barred version of the 
equal sign to indicate congruency.) In this case, 12 is the <DEF>modulus</DEF> 
that we are working under, and the equation simply tells us that, under a 
modulus of 12, 27 and 3 are considered to be the same number. Likewise: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>11 + 16 = 3 (mod 12)</TD></TR></TBODY></TABLE>
<P>reads as: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>11 plus 16 is congruent to 3, modulo 
12.</TD></TR></TBODY></TABLE>
<P>Modulus arithmetic is sometimes called <DEF>clockface arithmetic</DEF> -- if 
it's currently 11 o'clock, then 16 hours later it will be 3 o'clock. (Of course, 
the analogy is less perfect when the modulus is something other than 12.) 
<P>An important feature of modulus arithmetic is that you can replace the terms 
of an addition operation with congruent values, and still get the right answer: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>16 = 4 (mod 12), therefore</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>11 + 16 = 11 + 4 = 3 (mod 12).</TD></TR></TBODY></TABLE>
<P>Another example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>9835 = 7 (mod 12), and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>1176 = 0 (mod 12), therefore</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>9835 + 1176 = 7 + 0 = 7 (mod 12).</TD></TR></TBODY></TABLE>
<P>Even better, this trick also works with multiplication: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>9835 * 1176 = 7 * 0 = 0 (mod 12)</TD></TR></TBODY></TABLE>
<P>(and, if we check, we will see that, yes, 9835&nbsp;*&nbsp;1176 is 11565960, 
and 11565960&nbsp;=&nbsp;0&nbsp;(mod&nbsp;12)). 
<P>If our modulus was 10, then modulus arithmetic would be equivalent to 
ignoring all but the last digit in our numbers: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>37 = 7 (mod 10),</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>287 + 482 = 9 (mod 10), and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>895 * 9836 = 0 (mod 10).</TD></TR></TBODY></TABLE>
<P>And, in a sense, a C program does all of its calculations in modulus 
arithmetic. Since integer calculations in C are permitted to overflow, the high 
bits silently falling off into the bit bucket, a C program using 32-bit integers 
is really doing all of its arithmetic modulo 2^32. 
<P>As you might imagine, some calculations that are time-consuming and produce 
huge numbers become trivial in modulus arithmetic. The ability to reduce values 
to their remainders before doing the actual calculation keeps the calculations 
from getting out of hand. 
<P><A name=4></A>
<H2>Background, Part III: The Fundamental Theorem of Algebra </H2>
<P>The <DEF>Fundamental Theorem of Algebra</DEF> states that for every number, 
there is exactly one way to factor that number into primes -- and vice versa: 
every selection of primes multiplies into a different number. For example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>1176 = 2 * 2 * 2 * 3 * 7 * 7, or</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>1176 = 2^3 * 3^1 * 7^2.</TD></TR></TBODY></TABLE>
<P>It is guaranteed that there is no other way to break 1176 into prime factors. 
And, certainly, any time you take three 2s, two 7s, and a three, you're always 
going to get 1176 when you multiply them together. The Fundamental Theorem of 
Algebra assures us that both these things are true for <EM>every</EM> number. 
<P>(By the way, this is one of the reasons that 1 is not considered to be a 
prime number: if it were, then each number would have an infinite number of 
prime factorizations, all differing by how many 1s were included. Instead, 1 is 
considered to have no prime factors at all, and we say that a number is prime if 
it has exactly one prime factor -- namely itself.) 
<P>Put another way, the Fundamental Theorem of Algebra states that the set of 
all numbers and the set of all selections of prime numbers are "isomorphic" -- 
there is a perfect one-to-one mapping between the two. A number is therefore 
<EM>defined</EM> by its prime factorization. 
<P><A name=5></A>
<H2>Background, Part IV: Relatively Prime Numbers </H2>
<P>The <DEF>greatest common divisor</DEF> (abbreviated GCD) of two numbers is 
the largest number that evenly divides into both of them. For example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD(15, 10) = 5,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD(18, 10) = 2,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD(21, 10) = 1, and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD(170, 102) = 34.</TD></TR></TBODY></TABLE>
<P>Or, another way to look at it is to say that the GCD is the intersection of 
the two numbers' set of prime factors: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD((2^3 * 3^1 * 7^2), (2^2 * 5^1 * 7^3)) = 2^2 * 7^2, 
  so</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>GCD(1176, 6860) = 196.</TD></TR></TBODY></TABLE>
<P>When two numbers have no common factors, their GCD will be 1, and the two 
numbers are said to be <DEF>relatively prime</DEF> (or <DEF>coprime</DEF>). For 
example, we can see in our list up above that 21 and 10 are relatively prime. 
<P>Since a prime number has no factors besides itself, clearly a prime number is 
relatively prime to every other number (except for multiples of itself). And the 
same can be said of the number 1. 
<P>Okay. Enough background material. Let's get to the good stuff. 
<P>
<HR>

<P><A name=6></A>
<H2>Euler's Totient Function </H2>
<P><DEF>Euler's Totient Function</DEF> is denoted by the Greek letter phi, and 
is defined as follows: 
<P>
<BLOCKQUOTE>phi(N) = how many numbers between 1 and N&nbsp;-&nbsp;1 which are 
  relatively prime to N. </BLOCKQUOTE>
<P>Thus: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(4)</TD>
    <TD align=left>= 2</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1 and 3 are relatively prime to 
4),</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(5)</TD>
    <TD align=left>= 4</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1, 2, 3, and 4 are relatively prime to 
      5),</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(6)</TD>
    <TD align=left>= 2</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1 and 5 are relatively prime to 
6),</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(7)</TD>
    <TD align=left>= 6</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1, 2, 3, 4, 5, and 6 are relatively 
      prime to 7),</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(8)</TD>
    <TD align=left>= 4</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1, 3, 5, and 7 are relatively prime to 
      8), and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>phi(9)</TD>
    <TD align=left>= 6</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1, 2, 4, 5, 7, and 8 are relatively 
      prime to 9).</TD></TR></TBODY></TABLE>
<P>
<P>Here is the same definition expressed as C code: 
<P><PRE>        phi = 1;
        for (i = 2 ; i &lt; N ; ++i)
            if (gcd(i, N) == 1)
                ++phi;
</PRE>
<P>(By the way, notice that phi(1) is specially defined to be 1.) 
<P>It should be easy to see that phi(N) will be N&nbsp;-&nbsp;1 whenever N is 
prime. Somewhat less obvious is the useful fact that phi(N) is also easy to 
calculate when N has exactly two different prime factors: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(P * Q) = (P - 1) * (Q - 1), if P and Q are 
  prime.</TD></TR></TBODY></TABLE>
<P>(The proof of this fact is left as an exercise for the reader. It's actually 
not too hard.) Thus, for example: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(15) = 2 * 4 = 8</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;(1, 2, 4, 7, 8, 11, 13, and 
  14).</TD></TR></TBODY></TABLE>
<P>
<P>The two prime factors cannot be the same number for this to work, and in fact 
you can see above that phi(9) does not equal 4. 
<P><A name=7></A>
<H2>Euler's Totient Theorem </H2>
<P>This theorem is one of the important keys to the RSA algorithm: 
<P>
<BLOCKQUOTE>If GCD(T,&nbsp;R)&nbsp;=&nbsp;1 and T&nbsp;&lt;&nbsp;R, then 
  T^(phi(R))&nbsp;=&nbsp;1&nbsp;(mod&nbsp;R). </BLOCKQUOTE>
<P>Or, in words: 
<P>
<BLOCKQUOTE>If T and R are relatively prime, with T being the smaller number, 
  then when we multiply T with itself phi(R) times and divide the result by R, 
  the remainder will always be 1. </BLOCKQUOTE>
<P>We can test this theorem on some smaller numbers for which we have already 
calculated the totient. Using 5 for T and 6 for R, we get: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(6) = (2 - 1) * (3 - 1) = 1 * 2 = 2, so</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>5^(phi(6)) = 5^2 = 25, and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>25 = 24 + 1 = 6 * 4 + 1, therefore</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>25 = 1 (mod 6).</TD></TR></TBODY></TABLE>
<P>Using 2 for T and 15 for R, we have: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(15) = (3 - 1) * (5 - 1) = 2 * 4 = 8, so</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>2^(phi(15)) = 2^8 = 256, and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>256 = 255 + 1 = 17 * 15 + 1, therefore</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>256 = 1 (mod 15).</TD></TR></TBODY></TABLE>
<P>
<P><A name=8></A>
<H2>Variations on a Theme </H2>
<P>Here again is the equation of Euler's Totient Theorem: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(phi(R)) = 1 (mod R)</TD></TR></TBODY></TABLE>
<P>(remembering that T&nbsp;&lt;&nbsp;R, and T and R are relatively prime). 
Thanks to the way that modulus arithmetic works on multiplication, we can easily 
see that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(phi(R)) * T^(phi(R)) = 1 * 1 (mod 
R),</TD></TR></TBODY></TABLE>
<P>which can be rewritten, using the laws of exponents, as: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(phi(R) + phi(R)) = 1 * 1 (mod R),</TD></TR></TBODY></TABLE>
<P>or: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(2 * phi(R)) = 1 (mod R).</TD></TR></TBODY></TABLE>
<P>If we ran through this sequence again, we would get: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(3 * phi(R)) = 1 (mod R).</TD></TR></TBODY></TABLE>
<P>Clearly, we could keep doing this as many times as we like. So, we can expand 
on Euler's Totient Theorem, and state a more general corollary: 
<P>
<BLOCKQUOTE>If GCD(T,&nbsp;R)&nbsp;=&nbsp;1 and T&nbsp;&lt;&nbsp;R, then 
  T^(K&nbsp;*&nbsp;phi(R))&nbsp;=&nbsp;1&nbsp;(mod&nbsp;R), where K can be any 
  number. </BLOCKQUOTE>
<P>However, we can state this corrollary another way. Notice that if K can be 
any number, then K&nbsp;*&nbsp;phi(R) is just the set of numbers that are evenly 
divisible by phi(R). Or, in other words, the numbers that are congruent to zero, 
modulo phi(R). So: 
<P>
<BLOCKQUOTE>If GCD(T,&nbsp;R)&nbsp;=&nbsp;1 and T&nbsp;&lt;&nbsp;R, then 
  T^S&nbsp;=&nbsp;1&nbsp;(mod&nbsp;R) whenever 
  S&nbsp;=&nbsp;0&nbsp;(mod&nbsp;phi(R)). </BLOCKQUOTE>
<P>Now, let's tweak our equation further by multiplying both sides by T: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^S * T = 1 * T (mod R).</TD></TR></TBODY></TABLE>
<P>Simplifying leaves us with: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(S + 1) = T (mod R).</TD></TR></TBODY></TABLE>
<P>If we repeat this, we will get: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(S + 1) * T = T * T (mod R),</TD></TR></TBODY></TABLE>
<P>or: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(S + 2) = T^2 (mod R).</TD></TR></TBODY></TABLE>
<P>Doing this yet again will give us: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(S + 3) = T^3 (mod R),</TD></TR></TBODY></TABLE>
<P>and so on. This pattern looks familiar, doesn't it? 
<P>What makes it interesting this time is that S is <EM>not</EM> a multiple of 
R, but of phi(R). In other words, we have the rather surprising rule: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^E = T^F (mod R) whenever E = F (mod 
phi(R)).</TD></TR></TBODY></TABLE>
<P>(once again, only as long as T&nbsp;&lt;&nbsp;R, and T and R are relatively 
prime). 
<P><A name=9></A>
<H2>The Plot Thickens </H2>
<P>We are on the edge of something very important. Let's back up a bit and look 
at this equation more closely: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(S + 1) = T (mod R).</TD></TR></TBODY></TABLE>
<P>Notice what we have here. We take a number, T, and raise it to a power, and 
when we do the calculation in modulus arithmetic, we wind up with T again. In 
short, we have a recipe for a function that returns its own input (presuming 
that R has been chosen ahead of time, and that T is verified to be relatively 
prime to R). 
<P>If you're thinking to yourself, "What's so interesting about that?", then 
consider what we would have if we broke this function up into two separate 
steps. Specifically, let's imagine that we can find two new numbers P and Q such 
that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = S + 1, for one of the possible values of 
  S.</TD></TR></TBODY></TABLE>
<P>Or, more to the point: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod phi(R))</TD></TR></TBODY></TABLE>
<P>Then we could write: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^(P * Q) = T (mod R),</TD></TR></TBODY></TABLE>
<P>which is equivalent to: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>(T^P)^Q = T (mod R),</TD></TR></TBODY></TABLE>
<P>and <EM>this</EM> is something that can be broken up into two steps: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^P = X (mod R), and then</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>X^Q = T (mod R).</TD></TR></TBODY></TABLE>
<P>Now, if you don't see the value in doing this, imagine now that the two steps 
are performed on separate computers. And that X is sent from the first computer 
to the second over an insecure phone line.... 
<P><A name=10></A>
<H2>Does This Really Work? </H2>
<P>T stands for the plaintext, the message that is to be sent. P, Q, and R 
together form the cipher's keys -- P and R make up the public key, and Q and R 
make up the private key. And X becomes the encrypted message. 
<P>Here, again, is the central equation that makes it work: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod phi(R))</TD></TR></TBODY></TABLE>
<P>Note here that P and Q will both automatically be relatively prime to phi(R). 
(Why? Because if either P or Q had a factor in common with phi(R), then 
P&nbsp;*&nbsp;Q would also have that as a factor. But we know that 
P&nbsp;*&nbsp;Q divided by phi(R) leaves a remainder of one.) This is important. 

<P>Imagine a clockface, with just an hour hand, and imagine yourself placing the 
hour hand on midnight and then moving it forward by jumps, over and over, each 
jump covering N hours. If you pick a value for N that is divisible by 2 or 3 
(the prime factors of 12), then you will find that you will only hit certain 
numbers before you return to midnight, and the sequence will then repeat. If N 
is 2, then the hour hand will visit 12, 2, 4, 6, 8, 10, 12, 2, 4, 6, 8, 10, 
12&nbsp;... 
<P>If, however, your N is relatively prime with 12, then you will wind up 
hitting every number exactly once before finally returning to midnight 12 jumps 
later. For example, using 7 for your N, the itinerary would be: 12, 7, 2, 9, 4, 
11, 6, 1, 8, 3, 10, 5, 12,&nbsp;... In addition, the <EM>order</EM> in which you 
visit the numbers is entirely dependent on what value you pick for N. 
<P>In a similar vein, it is important that both P and Q be relatively prime to 
phi(R). Because of this, we know that every possible value for T, when raised to 
the power P modulo R, will land on a different number. (Remember that when doing 
exponents in modulus arithmetic, it is actually phi(R), and not R itself, that 
determines the length of the cycles.) If this weren't true -- if P, for example, 
shared a factor in common with phi(R) -- then some values for T could get mapped 
to the same value for X, and it would clearly be impossible to tell which was 
originally which. There could not be one value for Q that would correctly map X 
back to T every time. 
<P>The question of which T-values will wind up going to which X-values depends 
entirely on the value used for P -- and here's the rub for the would-be 
codebreaker: Just about every possible mapping of T-values to X-values does in 
fact exist. Somewhere out there is a P that will make that mapping. 
<P>If this: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^P = X</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>X^Q = T</TD></TR></TBODY></TABLE>
<P>was the cipher's scheme, there'd be no cipher. With P already being public 
knowledge, it would be trivial to take an X and compute backwards to T. But, 
instead, we have this: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T^P = X (mod R)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>X^Q = T (mod R)</TD></TR></TBODY></TABLE>
<P>as the cipher's scheme, and that changes everything. The modulus arithmetic 
erases too much information. There's no way to deduce how many times the hour 
hand needs to spin around the clockface when Q turns X back into T. Without 
knowing what Q is, a given X could wind up going to <EM>any</EM> of the possible 
values for T. 
<P>But what is really maddening to our would-be codebreaker is that even when T 
and P and X are all known, Q still can't be deduced! (Of course, it actually can 
-- but not necessarily within anyone's lifetime. But we're getting ahead of 
ourselves.) 
<P>So, let's see how to make this recipe work. 
<P>
<HR>

<P><A name=11></A>
<H2>Making a Pair of Keys </H2>
<P>To construct our own personal cipher keys, we need an appropriate value for 
R. So, we start by randomly picking two prime numbers, U and V, and multiplying 
them together: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>R = U * V.</TD></TR></TBODY></TABLE>
<P>There are two good reasons for selecting a value for R that has exactly two 
prime factors. First of all, we have an easy formula for calculating phi(R): 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(R) = (U - 1) * (V - 1).</TD></TR></TBODY></TABLE>
<P>Secondly, we want R to be hard to factor. The fewer factors a number has, the 
longer it takes to find them. 
<P>We then need to find values for P and Q such that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod phi(R)).</TD></TR></TBODY></TABLE>
<P>When the numbers have been chosen, P and R together become the public key, 
and Q and R make up the private key. U and V are no longer needed, and can be 
forgotten. 
<P><A name=12></A>
<H2>An Example </H2>
<P>In order to see all this in action, we want to stick with numbers that we can 
actually work with. So, for our example, we will select the primes 5 and 11 to 
be our U and V. This gives R a value of 55, and: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>phi(55) = (5 - 1) * (11 - 1) = 4 * 10 = 
40.</TD></TR></TBODY></TABLE>
<P>Now, we need to find numbers to fit the equation: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod 40).</TD></TR></TBODY></TABLE>
<P>There are, of course, an infinite number of pairs that will fit this 
equation. So, let's find one of them. 
<P>Our only initial constraint is that P and Q are both relatively prime to 40. 
So, we can't use numbers that are multiples of 2 and/or 5. We also don't want P 
and Q to be congruent mod 40, since that would turn our trapdoor cipher into a 
garden-variety symmetric cipher. Ideally, in fact, we'd prefer that P and Q be 
relatively prime to each other. Let's start with 7, which we'll assign to P: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>7 * Q = 1 (mod 40).</TD></TR></TBODY></TABLE>
<P>What would that make Q? If we rewrite this equation to get rid of the 
unfamiliar modulus arithmetic, we have: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>7 * Q = K * 40 + 1, where K can be any 
number.</TD></TR></TBODY></TABLE>
<P>The first value for Q that works is 23: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>7 * 23 = 161 = 4 * 40 + 1.</TD></TR></TBODY></TABLE>
<P>So we have 7 for P, our public key, and 23 for Q, our private key. 
<P>To make our cipher work, you may recall that the values we use for T must be 
less than R, and also relatively prime to R. We also don't want to use 1 for T, 
because 1 raised to any power whatsoever is going to remain 1. Finally, the same 
holds true for R - 1, because R - 1 is congruent to -1, modulo R. 
<P>So, we'll take what's left and create the following character set: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;2</TD>
    <TD align=right>&nbsp;3</TD>
    <TD align=right>&nbsp;4</TD>
    <TD align=right>&nbsp;6</TD>
    <TD align=right>&nbsp;7</TD>
    <TD align=right>&nbsp;8</TD>
    <TD align=right>&nbsp;9</TD>
    <TD align=right>12</TD>
    <TD align=right>13</TD>
    <TD align=right>14</TD>
    <TD align=right>16</TD>
    <TD align=right>17</TD>
    <TD align=right>18</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;A</TD>
    <TD align=right>&nbsp;B</TD>
    <TD align=right>&nbsp;C</TD>
    <TD align=right>&nbsp;D</TD>
    <TD align=right>&nbsp;E</TD>
    <TD align=right>&nbsp;F</TD>
    <TD align=right>&nbsp;G</TD>
    <TD align=right>&nbsp;H</TD>
    <TD align=right>&nbsp;I</TD>
    <TD align=right>&nbsp;J</TD>
    <TD align=right>&nbsp;K</TD>
    <TD align=right>&nbsp;L</TD>
    <TD align=right>&nbsp;M</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>19</TD>
    <TD align=right>21</TD>
    <TD align=right>23</TD>
    <TD align=right>24</TD>
    <TD align=right>26</TD>
    <TD align=right>27</TD>
    <TD align=right>28</TD>
    <TD align=right>29</TD>
    <TD align=right>31</TD>
    <TD align=right>32</TD>
    <TD align=right>34</TD>
    <TD align=right>36</TD>
    <TD align=right>37</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;N</TD>
    <TD align=right>&nbsp;O</TD>
    <TD align=right>&nbsp;P</TD>
    <TD align=right>&nbsp;Q</TD>
    <TD align=right>&nbsp;R</TD>
    <TD align=right>&nbsp;S</TD>
    <TD align=right>&nbsp;T</TD>
    <TD align=right>&nbsp;U</TD>
    <TD align=right>&nbsp;V</TD>
    <TD align=right>&nbsp;W</TD>
    <TD align=right>&nbsp;X</TD>
    <TD align=right>&nbsp;Y</TD>
    <TD align=right>&nbsp;Z</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>38</TD>
    <TD align=right>39</TD>
    <TD align=right>41</TD>
    <TD align=right>42</TD>
    <TD align=right>43</TD>
    <TD align=right>46</TD>
    <TD align=right>47</TD>
    <TD align=right>48</TD>
    <TD align=right>49</TD>
    <TD align=right>51</TD>
    <TD align=right>52</TD>
    <TD align=right>53</TD>
    <TD align=right>&nbsp;</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>sp</TD>
    <TD align=right>&nbsp;0</TD>
    <TD align=right>&nbsp;1</TD>
    <TD align=right>&nbsp;2</TD>
    <TD align=right>&nbsp;3</TD>
    <TD align=right>&nbsp;4</TD>
    <TD align=right>&nbsp;5</TD>
    <TD align=right>&nbsp;6</TD>
    <TD align=right>&nbsp;7</TD>
    <TD align=right>&nbsp;8</TD>
    <TD align=right>&nbsp;9</TD>
    <TD align=right>&nbsp;*</TD>
    <TD align=right>&nbsp;</TD></TR></TBODY></TABLE>
<P>
<P>The message we will encrypt is "VENIO" (Latin for "I come"): 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;V</TD>
    <TD align=right>&nbsp;E</TD>
    <TD align=right>&nbsp;N</TD>
    <TD align=right>&nbsp;I</TD>
    <TD align=right>&nbsp;O</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>31</TD>
    <TD align=right>&nbsp;7</TD>
    <TD align=right>19</TD>
    <TD align=right>13</TD>
    <TD align=right>21</TD></TR></TBODY></TABLE>
<P>
<P>To encode it, we simply need to raise each number to the power of P modulo R. 

<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>V:</TD>
    <TD align=right>31^7 (mod 55) =</TD>
    <TD align=right>27512614111 (mod 55) =</TD>
    <TD align=right>26</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>E:</TD>
    <TD align=right>&nbsp;7^7 (mod 55) =</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;823543 (mod 55) =</TD>
    <TD align=right>28</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>N:</TD>
    <TD align=right>19^7 (mod 55) =</TD>
    <TD align=right>&nbsp;&nbsp;893871739 (mod 55) =</TD>
    <TD align=right>24</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>I:</TD>
    <TD align=right>13^7 (mod 55) =</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;62748517 (mod 55) =</TD>
    <TD align=right>&nbsp;7</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>O:</TD>
    <TD align=right>21^7 (mod 55) =</TD>
    <TD align=right>&nbsp;1801088541 (mod 55) =</TD>
    <TD align=right>21</TD></TR></TBODY></TABLE>
<P>
<P>So, our encrypted message is 26,&nbsp;28,&nbsp;24,&nbsp;7,&nbsp;21 -- or 
"RTQEO" in our personalized character set. 
<P>When the message "RTQEO" arrives on the other end of our insecure phone line, 
we can decrypt it simply by repeating the process -- this time using Q, our 
private key, in place of P. 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>R:</TD>
    <TD align=right>26^23 (mod 55) =</TD>
    <TD align=right>&nbsp;350257144982200575261531309080576 (mod 55) =</TD>
    <TD align=right>31</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>T:</TD>
    <TD align=right>28^23 (mod 55) =</TD>
    <TD align=right>1925904380037276068854119113162752 (mod 55) =</TD>
    <TD align=right>&nbsp;7</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>Q:</TD>
    <TD align=right>24^23 (mod 55) =</TD>
    <TD align=right>&nbsp;&nbsp;55572324035428505185378394701824 (mod 55) =</TD>
    <TD align=right>19</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>E:</TD>
    <TD align=right>&nbsp;7^23 (mod 55) =</TD>
    <TD 
      align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27368747340080916343 
      (mod 55) =</TD>
    <TD align=right>13</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>O:</TD>
    <TD align=right>21^23 (mod 55) =</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;2576580875108218291929075869661 (mod 55) 
      =</TD>
    <TD align=right>21</TD></TR></TBODY></TABLE>
<P>
<P>The result is 31,&nbsp;7,&nbsp;19,&nbsp;13,&nbsp;21 -- or "VENIO", our 
original message. 
<P><A name=13></A>
<H2>How to Crack RSA </H2>
<P>Now, let's switch hats. Imagine that we've just managed to pluck the message 
"RTQEO" off of our wiretap. By looking up the message's destination in the 
public-key directory, we find that our message was encrypted with a value of 55 
for R and 7 for P. How do we go about decrypting it when we don't know the value 
for Q? 
<P>Well, we know that that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod phi(R)),</TD></TR></TBODY></TABLE>
<P>or, without the modulus arithmetic: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = K * phi(R) + 1.</TD></TR></TBODY></TABLE>
<P>We can divide both sides of the equation by P, which gives us a formula for 
Q: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>Q = (K * phi(R) + 1) / P.</TD></TR></TBODY></TABLE>
<P>K is also unknown, though, so we will try plugging in different numbers for 
K, and look for values for Q that meet all the necessary constraints. 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>(1 * 40 + 1) / 7 =</TD>
    <TD align=right>&nbsp;41 / 7</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(doesn't divide 
    evenly)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>(2 * 40 + 1) / 7 =</TD>
    <TD align=right>&nbsp;81 / 7</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ditto)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>(3 * 40 + 1) / 7 =</TD>
    <TD align=right>121 / 7</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ditto)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>(4 * 40 + 1) / 7 =</TD>
    <TD align=right>161 / 7</TD>
    <TD align=right>= 23</TD>
    <TD align=left>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(this could be 
  it!)</TD></TR></TBODY></TABLE>
<P>
<P>Each time we find a candidate for Q, we can test it out on the message. We 
might get gibberish, in which case we can continue searching. If 23 hadn't 
worked and we needed to continue the search, it would be pretty obvious that we 
only needed to test every seventh number, since those are the only numbers which 
will give us a result that is evenly divisible by 7. Furthermore, we only need 
to test values up 39, thanks to the modulus arithmetic. So, even though this 
process involves a brute-force search, it is very simple and very fast. 
<P>Well then, so what's the catch? Simply that, in order to do any of this, we 
first need to know the value of phi(R). Of course, we already know that R has 
exactly two prime factors, so calculating phi(R) is a snap once we know what 
those factors are. 
<P>Famous last words. 
<P>
<HR>

<P><A name=14></A>
<H2>How to Make RSA Uncrackable </H2>
<P>Of course, in our case the factors of R can be found by consulting a times 
table. So it's not much of a challenge. (For that matter, since we're encrypting 
one character at a time, our coded messages would also be vulnerable to good 
old-fashioned cryptanalysis). 
<P>To make it less easy to find R's factors, we need to pick larger prime 
numbers for U and V to begin with. If, instead of 5 and 11, we had chosen 673 
and 24971, we would have a value of 16805483 for R, and phi(R) would be 
16779840. (This would also give us enough room to encrypt more than one byte at 
a time, which seriously reduces the vulnerability to cryptanalysis.) Looking for 
a P and Q pair is no longer something you want to do with pencil and paper, of 
course, but it took me less than three minutes to find the usable pair 397 and 
211333 -- including the time it took to write and debug a Perl script. 
<P>On the other hand, it also took me less than three <EM>seconds</EM> to run 
"factor" on 16805483 to obtain 673 and 24971. Armed with those numbers, it 
wouldn't take much longer to derive 211333 from 397. So even these numbers 
aren't close to being large enough. We need <EM>really</EM> big numbers. 
<P>Well, we can certainly find huge values for R that are difficult to factor. 
But how far can we go before it becomes too difficult for us to use the number 
in the first place? 
<P><A name=15></A>
<H2>Huge Exponents in Modulus Arithmetic </H2>
<P>The problem is this: The bigger R gets, the bigger P and Q will be, and P and 
Q are to be used as exponents! Even the relatively tame-looking 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>9^(9^9)</TD></TR></TBODY></TABLE>
<P>produces a number over 350 million decimal digits long. How are we going to 
be able to encrypt anything without needing terabytes of storage? 
<P>The trick is that we only need to calculate these exponential values modulo 
R. As always, modulus arithmetic simplifies things a great deal. 
<P>Let's revisit our example, and look at how we could decrypt the number 28, 
remembering that R&nbsp;=&nbsp;55 and Q&nbsp;=&nbsp;23: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^23 (mod 55) = ?</TD></TR></TBODY></TABLE>
<P>To start with, we look at Q's binary representation. 23 in binary is 10111, 
which means that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>23 = 16 + 4 + 2 + 1, or</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>23 = 2^4 + 2^2 + 2^1 + 2^0.</TD></TR></TBODY></TABLE>
<P>We can now break the exponential calculation apart into several smaller ones: 

<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>28^23</TD>
    <TD align=left>= 28^(2^4 + 2^2 + 2^1 + 2^0)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 28^(2^4) * 28^(2^2) * 28^(2^1) * 28^(2^0)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 28^(2 * 2 * 2 * 2) * 28^(2 * 2) * 28^2 * 28</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= (((28^2)^2)^2)^2 * (28^2)^2 * 28^2 * 
28.</TD></TR></TBODY></TABLE>
<P>
<P>This may look like anything but an improvement, at first. But on a closer 
examination, you'll see that we actually have many repeated subterms. This 
simplifies matters, particularly when we take advantage of the fact that we are 
calculating in modulo 55. 
<P>We compute the first square in modulus arithmetic: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^2 = 784 = 14 (mod 55).</TD></TR></TBODY></TABLE>
<P>By substituting this value into our equation: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^23 = (((28^2)^2)^2)^2 * (28^2)^2 * 28^2 * 28 (mod 
  55),</TD></TR></TBODY></TABLE>
<P>we get: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^23 = ((14^2)^2)^2 * 14^2 * 14 * 28 (mod 
  55).</TD></TR></TBODY></TABLE>
<P>Now by computing that square: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>14^2 = 196 = 31 (mod 55),</TD></TR></TBODY></TABLE>
<P>we will have: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^23 = (31^2)^2 * 31 * 14 * 28 (mod 
55).</TD></TR></TBODY></TABLE>
<P>And, finally: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>31^2 = 961 = 26 (mod 55), and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>26^2 = 676 = 16 (mod 55);</TD></TR></TBODY></TABLE>
<P>and so: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>28^23 = 16 * 31 * 14 * 28 (mod 55).</TD></TR></TBODY></TABLE>
<P>We can continue to take advantage of the modulus when we do the final 
multiplications: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>28^23</TD>
    <TD align=left>= 16 * 31 * 14 * 28 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 16 * 31 * 392 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 16 * 31 * 7 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 16 * 217 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 16 * 52 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 832 (mod 55)</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD align=left>= 7 (mod 55)</TD></TR></TBODY></TABLE>
<P>
<P>Lo and behold: 7, the same result as when we did it the hard way. 
<P>This binary technique is really no different than how computers normally 
compute integer powers. However, the fact that we can break the process down to 
successive multiplications allows us to apply the modulus at every step of the 
way. This assures us that at no point will our algorithm have to handle a number 
larger than (R&nbsp;-&nbsp;1)^2. 
<P><A name=16></A>
<H2>Huge Factors in Modulus Arithmetic </H2>
<P>The magic of modulus arithmetic will also ensure that it's possible to find 
our P and Q pair. Remember that, after we've selected some humongous value for 
R, we need to find values to fit: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = 1 (mod phi(R)),</TD></TR></TBODY></TABLE>
<P>or, without the modulus arithmetic: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q = K * phi(R) + 1, where K is any 
number.</TD></TR></TBODY></TABLE>
<P>After picking a likely value for P -- which probably will <EM>not</EM> be a 
conveniently small number like 7 -- we will need to find a matching Q. By 
rewriting the above as: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>P * Q - phi(R) * K = 1,</TD></TR></TBODY></TABLE>
<P>with known values for P and phi(R), we have what is called a <DEF>Diophantine 
equation</DEF>. This really just means that we have more unknowns than 
equations. However, it also means that algorithms exist for solving it, the most 
well-known one being Euler's. (One thing you quickly discover when you dabble in 
number theory is that a lot of things are named after Euler.) While it's still 
not something you'd want to do with pencil and paper, it doesn't involve 
anything more advanced than a whole lot of long division. In short, it's 
something that a computer can do in a relatively brief amount of time. 
<P><A name=17></A>
<H2>Safety in Numbers </H2>
<P>Okay. So we know that the whole process is still practical, even if R is 
immense. But all of this is still moot unless we can select an R in the first 
place. R has to be the product of two prime numbers, don't forget. If we want R 
to be so big that it can't be factored easily, how are we going to find those 
factors to begin with? 
<P>It turns out that there is an interesting little asymmetry here. Determining 
whether or not a number is prime happens to be a relatively cheap process. 
<P>One of the most famous methods for testing a number for primality uses 
<DEF>Fermat's Little Theorem</DEF>. Here is the version of this Theorem that 
we're interested in: 
<P>
<BLOCKQUOTE>If P is prime, then 
  N^(P&nbsp;-&nbsp;1)&nbsp;=&nbsp;1&nbsp;(mod&nbsp;P) is true for every number 
  N&nbsp;&lt;&nbsp;P. </BLOCKQUOTE>
<P>Does this seems suspiciously reminiscent of Euler's Totient Theorem? It 
should. Euler was the first person to publish a proof of Fermat's Little 
Theorem, and his Totient Theorem is a generalization of Fermat's. You can see 
this for yourself by remembering that phi(P)&nbsp;=&nbsp;P&nbsp;-&nbsp;1 when P 
is prime. 
<P>Of course, as far as proofs go, this theorem is only useful for proving that 
a given number is composite. For example, it just so happens that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>4^14 (mod 15) = 268435456 (mod 15) = 1,</TD></TR></TBODY></TABLE>
<P>even though 15 is no prime. Nonetheless, it is also true that: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>3^14 (mod 15) = 4782969 (mod 15) = 9, and</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>5^14 (mod 15) = 6103515625 (mod 15) = 
10.</TD></TR></TBODY></TABLE>
<P>On the other hand, 17, which <EM>is</EM> prime, results in 1 every time: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>3^16 (mod 17) = 43046721 (mod 17) = 1,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>4^16 (mod 17) = 4294967296 (mod 17) = 1,</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD align=left>5^16 (mod 17) = 152587890625 (mod 17) = 1, and so 
  on.</TD></TR></TBODY></TABLE>
<P>So, if we want to know if a number is prime, we can run it through this test, 
using (say) 2 as the base. If anything besides 1 results, we know with certainty 
that the number is composite. If the answer is 1, however, we try the test again 
with 3, and then 4, and so on. If we keep getting back 1 as the result, it soon 
becomes rather unlikely that the number is anything but prime. 
<P>Unlikely, mind you, but not impossible. There are a handful of numbers which 
pass this test for every base, but which are not prime. Called <DEF>Carmichael 
numbers</DEF>, they are far more rare than the prime numbers -- but, like the 
primes numbers, there are still an infinite number of them. So we wouldn't want 
to rely on this test alone. 
<P>Fortunately, there are other tests for primality which are more reliable. But 
they all have at least one thing in common with this test: When they reject a 
number, they tell us only that the number can be factored. The test results give 
us no information at all as to what the factors might be. How unfortunate! 
<P>Unfortunate for the mathematicians, that is. Very fortunate for us. 
<P><A name=18></A>
<H2>Summing Up </H2>
<P>The basic truth is that, in order to find the factors of a composite number, 
we're pretty much stuck with using brute force: Divide the number by all the 
primes you can get your hands on until one of them goes in evenly. There are 
plenty of ways to improve on this approach (the <DEF>Number Field Sieve</DEF> 
currently being the best), but they are complicated, and all they do is allow 
you to narrow the scope of the search. They don't reduce the search enough to 
make this problem tractable in general. 
<P>Nor is it likely that new approaches will, either! The real issue is that the 
encrypting and decrypting algorithms have a running time that is linear with 
respect to the length of R. That is to say, doubling the number of digits in R 
doubles the amount of time (roughly) needed to encrypt, decrypt, and to select 
the two primes to make a key with. But the algorithms for factoring R have a 
running time that is exponential with respect to the length of R. That is to 
say, the time (roughly) doubles with every few digits! (Because every digit 
added to R makes it ten times larger, and thus multiplies the number of 
potential candidates for its measly two factors.) 
<P>So if a new technique is suddenly found that makes it a trillion times faster 
to factor a number, all we have to do is increase the size of R we use by enough 
digits, and the situation will be right back where it started -- and all it 
means to us is that it takes a little bit longer to send and receive our 
messages. Already some people are using keys that, in order to factor with the 
Number Field Sieve, would require more energy than exists in the known universe. 

<P>An illustration: At the time of my writing, one of the largest general 
numbers that has been independently factored was the number used as the modulus 
for the RSA-140 challenge. (By "general numbers", I'm excluding creatures like 
Mersenne numbers and Fermat numbers, which have specialized factoring techniques 
that are inapplicable elsewhere.) It was completed on February 2, 1999. Now, the 
record previous to this was the RSA-130 number, and the process of factoring it 
was estimated as taking a total of 1000 MIPS-years of computer time. RSA-140, a 
number only 10 decimal digits longer, required <EM>twice</EM> that amount. 
<P>This, finally, is the heart of what makes RSA a trapdoor function: the gap 
between obtaining a number with two prime factors, and rediscovering the factors 
from the number itself. And the gap just keeps expanding as the numbers get 
larger. 
<P>The breakthrough that would completely destroy RSA's security would be an 
algorithm that actually produced a number's factors directly, instead of merely 
narrowing the search's scope. Such a thing has not been proven impossible, and 
it may well be that such a proof will never be found. But considering that prime 
numbers have been studied for thousands of years, and given the renewed 
attention that has been focused on this problem in the last few decades, the 
likelihood of the existence of such an algorithm appears very remote. 
Discovering one would change the face of number theory as much as RSA has 
changed the face of cryptography. 
<P>However -- if this <EM>were</EM> to happen, there are other trapdoor 
functions out there, waiting to be found. Whatever the future of RSA may be, the 
trapdoor cipher has certainly changed the face of cryptography forever. 
<P>
<HR>

<P><A name=19></A>
<H2>References </H2>
<P>1. Clawson, Calvin C.: "Mathematical Mysteries", 1996, Plenum Press. (Clawson 
devotes an entire chapter to the mathematics behind RSA, and it is this that 
gave me the inspiration to create this text.) 
<P>2. Benson, Donald C.: "The Moment of Proof", 1999, Oxford University Press. 
(Like the previous one, this fine book discusses the mathematics of RSA 
alongside of many other topics.) 
<P>3. Gardner, Martin: "Penrose Tiles to Trapdoor Ciphers", 1989, W.H. Freeman 
&amp; Co. (This is another anthology of Gardner's wonderful columns for 
"Scientific American", and includes the column which was the first widely 
published description of the RSA cipher -- the one which set the NSA to 
frantically running around in circles.) 
<P>4. Ribenboim, Paulo: "The Little Book of Big Primes", 1991, Springer-Verlag. 
(The title should actually be "The Little Book of Big Number Theory" -- the book 
is chock full of theorems and conjectures that relate to prime numbers.) 
<P>5. Devlin, Keith: "All the Math that's Fit to Print", 1994, The Mathematical 
Association of America. (A collection of short columns from The Manchester 
Guardian, in which I learned that the set of Carmichael numbers has been proven 
to be infinite.) 
<P>6. Wells, David: "The Penguin Dictionary of Curious and Interesting Numbers", 
1986, Penguin Books. (I had to pull this out at the last minute to find out how 
many digits were in 9^(9^9). For the curious whose libraries lack this little 
gem, the exact number of digits is 369693100.) 
<P>Thanks to readers Joel Sturman and Lee Sloan for pointing out errors and 
ommisions in previous drafts. 
<P>
<HR>

<P><BR><FONT size=-1><A 
href="http://www.muppetlabs.com/~breadbox/txt/">Texts</A> </FONT><BR><FONT 
size=-1><A href="http://www.muppetlabs.com/~breadbox/">Brian Raiter</A></FONT> 
<BR><FONT size=-1><A href="http://www.muppetlabs.com/">Muppetlabs</A></FONT> 
</P></BODY></HTML>
