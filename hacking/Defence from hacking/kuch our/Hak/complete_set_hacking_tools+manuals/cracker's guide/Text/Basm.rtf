{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f56\froman\fcharset238\fprq2 Times New Roman CE;}{\f57\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f59\froman\fcharset161\fprq2 Times New Roman Greek;}{\f60\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f61\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f68\fmodern\fcharset238\fprq1 Courier New CE;}{\f69\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f71\fmodern\fcharset161\fprq1 Courier New Greek;}{\f72\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f73\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\lang3081\cgrid 
\snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang3081\cgrid \sbasedon0 \snext15 Plain Text;}}{\info{\title Basic Assembler}{\author Intern}{\operator Intern}
{\creatim\yr1999\mo6\dy3\hr17\min44}{\revtim\yr1999\mo6\dy3\hr17\min48}{\version6}{\edmins4}{\nofpages2}{\nofwords359}{\nofchars2051}{\*\company Intern}{\nofcharsws2518}{\vern71}}\paperw11906\paperh16838\margl1152\margr1152 
\widowctrl\ftnbj\aenddoc\formshade\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}\pard\plain \s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang3081\cgrid {\b\ul\cf2 Basic Assembler
\par }{
\par }{\b\ul Code Flow:
\par }{When analyzing a piece of code, you should realize that the processor is dumb and it just follows one line after the other... It does anything the code tells it to do.
\par 
\par To do this, the processor has an instruction pointer. With it, it points to the instruction it wants to execute.
\par 
\par The processor also executes instructions that change the flow of the code.
\par 
\par When trying to understand a piece of code, try to be the processor....
\par Compare registers, compare variables, execute jumps, and execute calls. This is the best way to understand a piece of code.
\par 
\par }{\b\ul Registers:}{ 
\par Registers are variables the processor uses. The most used ones are : }{\cf11 eax, ebx, ecx and edx}{. You will also see }{\cf10 edi, esi, esp, ebp.
\par }{
\par These registers which start with an e, are all 32 bits registers. The 16 bit equivalents of these registers you will also see here and there. These are actually the same registers, but the variable size is only 16 bits. These registers are: }{\cf11 
ax, bx, cx, dx, di, si, sp, bp}{.
\par 
\par While we are at it, there are also 8 bit values of some of the registers.
\par You might see the following 8 bit registers: al, ah, bl, bh, cl, ch, dl, dh.
\par Here the l stands for the lower and h for the higher 8 bits of a 16 bit register.
\par 
\par }{\b\ul Flags:}{ \tab \tab 
\par Flags are boolean variables the processor uses for itself to check what the result of a logical instruction was. The most important flag is the }{\b Zero Flag}{. Its value can be zero or non-zero.
\par 
\par }{\b\ul Frequently seen Assembler instructions:
\par }{
\par 
\par }{\b cmp}{ xxx, yyy\tab This instruction compares value xxx with value yyy.
\par \tab \tab \tab if they are equal, the zero flag is set. 
\par 
\par }{\b test}{ xxx, xxx\tab Compares if value xxx is equal to zero. If it is, the zero 
\par }\pard \s15\fi720\li1440\nowidctlpar\widctlpar\adjustright {flag is set.
\par }\pard \s15\nowidctlpar\widctlpar\adjustright {\tab \tab \tab 
\par }{\b jmp <address>\tab }{Unconditional jump. Jumps always. Not important for crackers
\par 
\par }{\b jz  <address>}{\tab jump if Zero flag is set. Same as }{\b je}{
\par }{\b jnz <address>}{\tab jump if Zero flag is Not set. same as }{\b jne}{
\par 
\par }{\b jxx <address>}{\tab jump if <condition>greater, less, greater or equal, less or 
\par }\pard \s15\fi720\li1440\nowidctlpar\widctlpar\adjustright {equal.
\par }\pard \s15\nowidctlpar\widctlpar\adjustright {
\par }{\b call}{ }{\b <address>}{\tab The Processor saves the address of the next instruction, then 
\par }\pard \s15\li2160\nowidctlpar\widctlpar\adjustright {it jumps to address <address>.
\par }\pard \s15\nowidctlpar\widctlpar\adjustright {\tab \tab \tab Executes all lines until it counters a ret instruction. After 
\par }\pard \s15\fi720\li1440\nowidctlpar\widctlpar\adjustright {the }{\b ret}{ instruction it returns to the line of next instruction
\par }\pard \s15\nowidctlpar\widctlpar\adjustright {\tab \tab \tab These are subroutines / procedures / functions.
\par 
\par }{\b push}{ }{\b <variable>}{\tab This moves a value into the memory the processor uses. This is 
\par }\pard \s15\fi720\li1440\nowidctlpar\widctlpar\adjustright {usually done before a call is executed. The parameters of the 
\par }\pard \s15\li2160\nowidctlpar\widctlpar\adjustright {function are 'pushed'. The values are moved into memory so that the subroutine can access them easily.\tab 
\par }}