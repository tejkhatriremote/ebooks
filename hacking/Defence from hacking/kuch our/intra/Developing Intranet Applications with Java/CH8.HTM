<HTML>

<HEAD>
   <TITLE>Chapter 8 -- Utility Classes</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 8</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Utility Classes</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#Introduction" >Introduction</A>
<LI><A HREF="#Timers" >Timers</A>
<UL>
<LI><A HREF="#TimerOperations" >Timer Operations</A>
<LI><A HREF="#Callbacks" >Callbacks</A>
<LI><A HREF="#EventTimers" >Event Timers</A>
<LI><A HREF="#WhyHaveTwoTimers" >Why Have Two Timers?</A>
</UL>
<LI><A HREF="#JavaExtensions" >Java Extensions</A>
<UL>
<LI><A HREF="#ExtendingJavasDateClass" >Extending Java's Date Class</A>
<LI><A HREF="#ApplicationConfigurationParameters" >Application Configuration Parameters</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<I><B><FONT SIZE=5 COLOR=#000000>utility \y&uuml;-'ti-l </FONT><FONT SIZE=5>&nbsp;-te-\
n:</FONT></B><FONT SIZE=5> something useful or designed for use</FONT></I>
<H2><A NAME="Introduction"><FONT SIZE=5 COLOR=#FF0000>Introduction</FONT></A>
</H2>
<P>
During the process of creating any type of software, one usually
ends up with many useful utilities. These utilities can range
from simple functions to complex objects or data structures. Centralizing
them where they are accessible to the entire application and can
easily be moved to other projects is essential. Even Java has
a utilities package called <TT>java.util</TT>;
no doubt you are familiar with it.
<P>
Java intranet applications are no different. You'll develop many
utilities during your development cycle. The utilities you create
will be Java classes, however. This chapter will serve as a starting
point for your utility class creation. In it you will find several
classes that are quite useful for constructing intranet applications.
You'll then learn how to keep all your classes together to easily
use them again.
<P>
The types of utility classes that we'll explore in this chapter
follow:
<UL>
<LI><FONT COLOR=#000000>Timers-These are like software alarm clocks.
You set the alarm time, and they alert you later.</FONT>
<LI><FONT COLOR=#000000>Dates-Java's standard </FONT><TT>Date</TT>
class is an excellent object. You'll look at how to tweak it just
a bit to do some cool tricks.
<LI><FONT COLOR=#000000>Properties-Java's </FONT><TT>Properties</TT>
class is also an excellent object. You'll see how you can mold
it to do your bidding.
</UL>
<H2><A NAME="Timers"><FONT SIZE=5 COLOR=#FF0000>Timers</FONT></A>
</H2>
<P>
A timer is a software mechanism designed to alert the program
and programmer when a specified interval of time has elapsed.
This mechanism is commonly used in all sorts of applications.
A specific example of timer usage is in intranet database applications.
You can use a timer to notify you whether certain events have
or have not occurred.
<P>
For example, consider connecting to a database server. When your
application attempts to connect with the server, your program
and user must wait until the connection has been established.
But how long do you wait? What if the server is down? What if
the connection between your computer and the server is down? Many
problems can occur, but if your program can be notified when a
certain amount of time has elapsed, it can take action.
<P>
Another example of timer usage is for application monitoring.
Perhaps you'd like to close any open server connections after
a period of inactivity. When you set and reset a timer after certain
events occur, your program can be notified of any inactivity.
<H3><A NAME="TimerOperations">Timer Operations</A></H3>
<P>
Timers work just like an alarm clock, which goes off when the
alarm time has been reached. If you don't change the alarm time,
the alarm will go off again in 24 hours.
<P>
Alarm clocks are far less versatile than timers, however. You
cannot set the interval at which the alarm will sound; you're
stuck with a 24-hour interval. If you want to set another time,
you must constantly reset the alarm time. On the other hand, timers
allow you to specify the interval of time between alarms, allowing
you to generate constant alerts or signals to your program. You
can then use these alerts however you'd like.
<P>
And how does your program receive these timer alerts? Your program
can receive timer alerts in one of two ways: from a callback or
from a Java event.
<H3><A NAME="Callbacks">Callbacks</A></H3>
<P>
Java does not support the notion of pointers. With pointers, a
conventional 3GL feature, you can pass the address of a method
around in your program or from process to process so that other
parts of your program, or other processes even, can call your
method. This practice is commonly called a callback.
<P>
A callback is a way in which a program can register for notification
when certain events occur. A real-world example of this is when
you go to your book store and order a book that is not in stock.
The clerk takes your name and phone number. Two weeks later, the
store calls you on the telephone to notify you that your book
has arrived. You've been called back.
<P>
A similar process takes place in programming. When certain programmatic
or system events occur, you want to be notified of them. In other
development environments, the callback is achieved by using pointers
to methods. When you register for your notification, you inform
the registrar of the method to call. The system then actually
calls your method when the event occurs.
<H4>Look Mom, No Pointers!</H4>
<P>
As you've learned, Java has no pointers and, therefore, no method
pointers. So how can you possibly create a callback mechanism?
Easily-by using an interface. An interface in Java is like a template
or hollow shell for classes. When a class implements an interface,
it must &quot;fill in&quot; the methods defined in the interface.
<P>
When you define an interface for callbacks, any class that wants
to receive them can implement this interface. The method that
the receiving class implements is actually called by the timer
object. Listing 8.1 shows an interface called <TT>TimeOut</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 8.1. The </B><TT><B>TimeOut</FONT></B></TT><B>
interface.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
TimeOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
public interface<BR>
TimeOut<BR>
{<BR>
<BR>
//****************************************************************************
<BR>
//* 
timeOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void<BR>
&nbsp;&nbsp;&nbsp;&nbsp;timeOut( CallbackTimer timer );<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>TimeOut</TT> interface defines
a single method: <TT>timeOut()</TT>.
A timer class can use this method to notify the user that a timer
event has occurred. The next section explores a class called <TT>CallbackTimer</TT>,
which uses this interface to implement a callback timer.
<H4><TT>CallbackTimer</TT></H4>
<P>
The <TT>CallbackTimer</TT> class uses
the <TT>TimeOut</TT> interface to
facilitate notification of timer events. When you create a <TT>CallbackTimer</TT>,
you simply pass in the object that is the recipient of the notification
as an argument. This passed-in object must be an implementor of
the <TT>TimeOut</TT> interface. In
addition, you must pass in the amount of time between notifications.
The time interval is in milliseconds.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=581><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=581>
<BLOCKQUOTE>
Milliseconds are 1/1000ths of a second; there are 1,000 milliseconds per second. Trying to keep seconds and milliseconds straight can be annoying, especially if your program uses both types at once. To help you remember, name your argument something that 
reminds you of the type. In our class, the argument is called <TT>msInterval</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 8.2 shows the constructor of the <TT>CallbackTimer</TT>.
The instance variables <TT>myTarget</TT>
and <TT>myInterval</TT> hold the values
for the rest of the object to use.
<HR>
<BLOCKQUOTE>
<B>Listing 8.2. The </B><TT><B>CallbackTimer</FONT></B></TT><B>
constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
CallbackTimer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CallbackTimer( TimeOut target, int msInterval
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Save
my values...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myTarget = target;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myInterval = msInterval;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Indicate
that this is not a user thread...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setDaemon( true
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>CallbackTimer</TT> class extends
Java's <TT>Thread</TT> class. The
reason for this is twofold. First and foremost, it is simple to
implement (the best reason!). The <TT>Thread</TT>
class provides much of the functionality needed for a notification
process.
<P>
Second, with the <TT>CallbackTimer</TT>,
you can create several timers and turn them off and on at will.
After you create them, you can (and must) <TT>start()</TT>
your timer, and whenever you want, you can <TT>stop()</TT>
it. These methods are inherited from the <TT>Thread</TT>
base class.
<P>
Note the last line of the constructor:
<BLOCKQUOTE>
<TT>setDaemon( true );</TT>
</BLOCKQUOTE>
<P>
This <TT>Thread</TT> method tells
the Java system that this thread is not a user thread. That means
that the Java engine will not stop running until all user threads
have died. If you have timers on in the background, your program
will not end until you've stopped them all. The <TT>setDaemon()</TT>
method informs the Java system that this thread is not a user
thread. Therefore, if only nonuser threads are left running (that
is, only timers), the system will stop your program immediately.
<P>
Implementing the callback mechanism is simple. Listing 8.3 shows
the <TT>run()</TT> method from our
<TT>CallbackTimer</TT> class.
<HR>
<BLOCKQUOTE>
<B>Listing 8.3. The </B><TT><B>run()</FONT></B></TT><B>
method from the </B><TT><B>CallbackTimer</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public void<BR>
&nbsp;&nbsp;&nbsp;&nbsp;run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Do
this forever!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( true )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Wait
until next interval...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(
myInterval );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
( InterruptedException ie ) {}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Notify
the target...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myTarget.timeOut(
this );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Because the target of the callback implements the <TT>TimeOut</TT>
interface, you are guaranteed that it will have a method called
<TT>timeOut()</TT>. This way, you
can call it when the timer goes off.
<P>
Let's create a Java program to illustrate the callback timer concept.
The following fragments are part of the <TT>TimerTester</TT>
application. The full source code, which can be found on the CD-ROM,
creates 16 timers and displays the effect of them going off in
16 different windows. Let's walk through each part individually.
<P>
First, the declaration:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
TimerTester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
public class<BR>
TimerTester<BR>
extends Frame<BR>
implements TimeOut</TT>
</BLOCKQUOTE>
<P>
As you can see, you've implemented the <TT>TimeOut</TT>
interface so that you can receive <TT>timeOut()</TT>
callbacks.
<P>
You need a few instance variables for your program. The declarations
follow:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
Members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CallbackTimer[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timers
= new CallbackTimer[ 16 ];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showers
= new TextArea[ 16 ];</TT>
</BLOCKQUOTE>
<P>
The first variable, <TT>timers</TT>,
is an array of 16 <TT>CallbackTimer</TT>s.
The second variable is <TT>showers</TT>
(not &quot;showers&quot;; &quot;show-ers&quot;). This array of
16 <TT>TextArea</TT> components will
show information about the 16 timers you will create.
<P>
Your next constructor follows:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
Constructor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TimerTester()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super( &quot;Timer
Tester!&quot; );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Create
a panel for our grid display<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panel p = new
Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.setLayout( new
GridLayout( 4, 4 ) );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Create
some showers &amp; timers...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int i =
0; i &lt; 16; i++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showers[
i ] = new TextArea( 5, 10 );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timers[
i ] = new CallbackTimer( this, 1000 * ( i + 1 ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.add(
showers[ i ] );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timers[
i ].start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Add
the timer panel to the frame...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add( &quot;Center&quot;,
p );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Pack
and show the panels...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
You've done several things in this constructor. Let's take a look
at them step by step:
<OL>
<LI>Call your base class constructor. First you must call your
base class's constructor to initialize your base class's instance
variable.
<LI>Create a <TT>Panel</TT> with a
<TT>GridLayout</TT>. The grid is set
at 4 rows high by 4 columns wide, which will lay out your 16 <TT>TextArea</TT>s
in a nice grid format.
<LI>Next, create the array elements for your instance variables.
The best way to do this is with a loop. You use a <TT>for</TT>
loop to create each component. The interval for the timer is set
to the iteration count times 1000. This gives you 16 timers ranging
in intervals from 1 to 16.
<LI>Also within the loop, you add the newly created <TT>TextArea</TT>
to your <TT>GridLayout</TT> and start
up each timer.
<LI>Then add the panel to the center of the <TT>Frame</TT>.
<LI>Finally, <TT>pack()</TT> the layout
and <TT>show()</TT> the window.
</OL>
<P>
The final important part of the <TT>TimerTester</TT>
example is the <TT>timeOut</TT> method
that implements the <TT>TimeOut</TT>
interface, as shown in the following code.
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
timeOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void<BR>
&nbsp;&nbsp;&nbsp;&nbsp;timeOut( CallbackTimer whichTimer )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int i =
0; i &lt; TIMER_COUNT; i++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( timers[ i ] == whichTimer )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showers[
i ].appendText( &quot;I ticked!\n&quot; );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
The <TT>timeOut</TT> method is called
when a timer goes off. In the example, however, you have 16 different
timers. How do you know which one you're dealing with?
<P>
You use a <TT>for</TT> loop to compare
each element in your array with the argument passed. The <TT>CallbackTimer</TT>
class sends itself as an argument to the <TT>timeOut</TT>
method. This way you can find out which timer it is.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
The alternative and much more object-oriented method of displaying the timer results in a window creates a new class that extends the <TT>TextArea</TT> component. This class could have a <TT>CallbackTimer</TT> as an instance variable set at construction. 
That way you are dealing with only a single timer and its display is itself.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Figure 8.1 shows the <TT>TimerTester</TT>
program in action.
<P>
<A HREF="f8-1.gif" ><B>Figure 8.1 : </B><I>The </I>TimerTester <I>program output.</I></A>
<H3><A NAME="EventTimers">Event Timers</A></H3>
<P>
Another method of receiving timer notifications is by using the
Java event system, provided to you by the <TT>EventTimer</TT>
class.
<H4>The <TT>EventTimer</TT> Class
</H4>
<P>
The <TT>EventTimer</TT> class is similar
to the <TT>CallbackTimer</TT> class
in that it is also a timer. The notification method is completely
different, however. The <TT>EventTimer</TT>
class sends an <TT>ACTION_EVENT</TT>
event to its owner when the timer goes off. What follows is the
same example given earlier, except it uses the <TT>EventTimer</TT>.
<P>
The <TT>EventTimer</TT> declaration
is similar to the <TT>CallbackTimer</TT>
<TT>TimerTester</TT> example program
except that classes using the <TT>EventTimer</TT>
class do not need to implement the <TT>TimeOut</TT>
interface. This is because the class that owns the <TT>EventTimer</TT>
object will receive notifications through the Java event system.
The following code is the declaration for the <TT>EventTimerTester</TT>
program.
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
EventTimerTester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
public class<BR>
EventTimerTester<BR>
extends Frame</TT>
</BLOCKQUOTE>
<P>
Notice that the preceding code does not implement any interfaces.
<P>
The constructor method of the <TT>EventTimerTester</TT>
program is identical to that of <TT>TimerTester</TT>.
In fact, the entire program is pretty much identical to the <TT>TimerTester</TT>
program except that instead of receiving notifications via the
<TT>timeOut()</TT> method, the <TT>EventTimerTester</TT>
program receives its notifications via the <TT>action()</TT>
event handler. The source code follows:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean<BR>
&nbsp;&nbsp;&nbsp;&nbsp;action( Event event, Object arg )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Locate
the timer that has ticked...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int i =
0; i &lt; TIMER_COUNT; i++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Is
this the one?<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( timers[ i ] == arg )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Show
it in the window...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showers[
i ].appendText( &quot;I ticked!\n&quot; );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
true );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( false
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<H3><A NAME="WhyHaveTwoTimers">Why Have Two Timers?</A></H3>
<P>
You might wonder why you're using two timer classes if one is
enough. One is enough, but sometimes you might want the flexibility
of two.
<P>
For example, the <TT>CallbackTimer</TT>
is excellent for use within other classes. If you have a class
that requires some sort of timer functionality, a <TT>CallbackTimer</TT>
as an instance variable is a cool thing. The timer is fully integrated
into your object and the consumer or user of your object does
not need to worry about using it.
<P>
The <TT>EventTimer</TT> is excellent
for on-the-fly timers. It's also good for adding timers to existing
code when you don't want to modify the implementations of some
classes. It can be used as a plug-and-play object.
<P>
And, because the bytecode for the two timers together is about
2KB, I'm not too worried about insufficient disk space.
<H2><A NAME="JavaExtensions"><FONT SIZE=5 COLOR=#FF0000>Java Extensions</FONT></A>
</H2>
<P>
The second half of this chapter is devoted to Java extension classes.
These classes extend, or augment, the functionality that the core
Java classes provide. Although this base functionality is useful,
you might like these objects to perform other tricks for your
intranet applications. Two classes that you extend here are the
<TT>Date</TT> and <TT>Properties</TT>
classes.
<H3><A NAME="ExtendingJavasDateClass">Extending Java's <TT><FONT SIZE=4 FACE="Courier">Date</TT></FONT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
The first class you'll extend is Java's <TT>Date</TT>
class. Although this class has many features, let's add a few
more that will help in building intranet applications. The big
change here is a string formatting method. You can configure this
method in terms of how it is constructed and which delimiters
to use. You'll call your new class <TT>FileDate</TT>
because the augmentations will provide nice features when you
create text files on disk.
<P>
To make this class robust and able to handle a variety of date
formats, you need to create input and output methods. These methods
will be the central point for date parsing and date string construction,
giving you a single point to make changes if you ever need to
implement new date formats or remove an existing format.
<H4>Parsing the Date Within a String</H4>
<P>
Java's <TT>Date</TT> class comes complete
with a method called <TT>parse()</TT>
to strip apart a string and convert it into a date. Although this
method can handle several formats, it is very specific about which
formats will work. If you look at the actual source code to the
<TT>Date.parse()</TT> method in the
JDK, you'll see that it is very difficult to follow. You'll take
a much simpler approach. For your applications, you want to parse
dates that are in the format of <TT>MM&lt;d&gt;DD&lt;d&gt;YY[YY]</TT>,
where the <TT>&lt;d&gt;</TT> is a
delimiter of the user's or programmer's choosing.
<P>
To quickly and easily parse the date from a string, you can use
Java's <TT>StringTokenizer</TT> class.
This breaks up the date string into tokens and you can then easily
digest and regurgitate these tokens into anything you'd like.
The following method, <TT>valueOf()</TT>,
takes a string representing a date and parses it into its three
components: month, day, and year. It looks like this:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
valueOf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static FileDate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;valueOf( String s )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throws IllegalArgumentException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;&nbsp;&nbsp;&nbsp;
st = new StringTokenizer( s, &quot;/.-,&quot; );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ms, ds, ys;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ms
= st.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds
= st.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys
= st.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch ( java.util.NoSuchElementException
e )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IllegalArgumentException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int m = Integer.parseInt(
ms );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int d = Integer.parseInt(
ds );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y = Integer.parseInt(
ys );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Convert
four digit year to Java year...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( y &gt; 1900
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
-= 1900;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( new FileDate(
y, m - 1, d ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The method is declared <TT>static</TT>
so that you can use it as a conversion method. With conversion
methods, you can use features of a class without actually instantiating
it. A good example of this is Java's <TT>Math</TT>
class. All of its methods are <TT>static</TT>
and all are called by prepending the class name (<TT>Math</TT>)
to the method. Another example of a <TT>static</TT>
method is used in the preceding parsing routine. When you use
the <TT>parseInt()</TT> method of
the <TT>Integer</TT> class, you are
calling a <TT>static</TT> method.
<P>
Because this method creates and returns a new object, you'll need
to throw the <TT>IllegalArgumentException</TT>
if you are given bad data. These are commonly called factory methods
because they build objects.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=562><B>What Does <TT><B>static</FONT></B></TT> Really Mean?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=562>
<BLOCKQUOTE>
When you declare a method or instance variable <TT>static</TT> in a Java class, you tell the compiler that that method or variable is the only copy for all instantiations of that class. This allows some special privileges and revokes some as well. For 
example, while gaining the ability to perform operations without actual instantiation, you can't reference any non-static member of your class. This can be annoying at times.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT>static</TT><B> </B>class methods are well suited for conversion or factory functionality and <TT>static</TT> instance variables are excellent for counters. You could create an instance counter that increments each time your class is created and 
decrements when the class is destroyed. If you declare your counter <TT>static</TT>, only a single copy will exist for all instances of your class.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The next step is to create a <TT>StringTokenizer</TT>
for the string that was passed into your method. This tokenizer
should recognize the following delimiters for dates: &quot;<TT>/</TT>&quot;,
&quot;<TT>-</TT>&quot;, &quot;<TT>.</TT>&quot;,
or &quot;<TT>,</TT>&quot;. You specify
this as the second argument in the <TT>StringTokenizer</TT>'s
constructor. You then attempt to pull out three tokens from the
tokenizer. If this fails, you know you don't have a good date,
and you throw your exception.
<P>
After you've received three good tokens from your main string,
you simply convert them to integers. These integers are used to
create a new instance of <TT>FileDate</TT>,
which is returned.
<H4>Constructing a String with a Date</H4>
<P>
The second important method in this class is the output method,
which will be responsible for creating a <TT>String</TT>
from the date and returning it to the caller. This method must
be able to handle a variety of formats easily and without too
much effort. The more code you write, the more likely you are
to make errors.
<P>
First, you need to establish the date formats that you'll support.
Use three major formats: MDY, DMY, and YMD. MDY is the standard
U.S. date format. DMY is common in Europe and favored by some
in the U.S. The last format, YMD, can be used to format dates
in a manner that will sort alphabetically. In addition to these
formats, the option of returning the year in four digits must
be available.
<P>
You also want your date formatter to return the month name instead
of the month number. This can be used when talking to Oracle databases,
for instance. The default date format accepted by Oracle is <TT>DD-MMM-YY[YY]</TT>.
<P>
You'll handle these formatting options with constants. Constants
in Java are declared <TT>final</TT>
and <TT>static</TT>. Your declarations
follow:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public final
static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MDY
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMY
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YMD
= 2;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MMMDY
= 3;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMMMY
= 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YMMMD
= 5;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MDYYYY
= 6;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMYYYY
= 7;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YYYYMD
= 8;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MMMDYYYY
= 9;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMMMYYYY
= 10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YYYYMMMD
= 11;</TT>
</BLOCKQUOTE>
<P>
These constants mimic the order of the dates they represent. This
is easy to remember from a coding standpoint and easy to debug
if there is a problem. The constants with <TT>YYYY</TT>
in them represent four-digit years. The constants with <TT>MMM</TT>
in them represent the non-numeric months.
<P>
In one instance variable, you need to format the month into a
string. This is an array to hold the names of the months, which
is declared as follows:
<BLOCKQUOTE>
<TT>static String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monthNamess[]
= { &quot;JAN&quot;, &quot;FEB&quot;, &quot;MAR&quot;, &quot;APR&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;MAY&quot;, &quot;JUN&quot;, &quot;JUL&quot;,
&quot;AUG&quot;, &quot;SEP&quot;, &quot;OCT&quot;, &quot;NOV&quot;,
&quot;DEC&quot; };</TT>
</BLOCKQUOTE>
<P>
This array is easily accessed with a month variable. It is declared
static because, as you know, month names never change.
<P>
Implementing this formatter is simple. You'll take the year, month,
and day and create strings of them, padding them as necessary.
When you have the three elements as strings, the rest is a cake
walk. Depending on the format, you concatenate the three parts
together, separated by the delimiter selected. The final result
is returned to the caller.
<P>
The source code for your formatter method follows:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public static
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( int y, int m, int
d, String delimiter, int fmtOpt )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;ms,
ys, ds;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Build
the month and day strings...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ms = ( m &lt;
10 ) ? &quot;0&quot; + Integer.toString( m ) : Integer.toString(
m );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds = ( d &lt;
10 ) ? &quot;0&quot; + Integer.toString( d ) : Integer.toString(
d );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Convert
the year to four digit if requested...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( fmtOpt ==
MDYYYY || fmtOpt == DMYYYY || fmtOpt == YYYYMD ||<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmtOpt
== MMMDYYYY || fmtOpt == DMMMYYYY || fmtOpt == YYYYMMMD )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( y &lt; 1900 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
+= 1900;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Force
it to two digits...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
%= 100;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Finally
build the year string...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys = ( y &lt;
10 ) ? &quot;0&quot; + Integer.toString( y ) : Integer.toString(
y );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Build
the return string...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( fmtOpt
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
MDY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
MDYYYY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
ms + delimiter + ds + delimiter + ys );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
MMMDY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
MMMDYYYY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
monthNames[ m - 1 ] + delimiter + ds +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delimiter
+ ys );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
DMY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
DMYYYY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
ds + delimiter + ms + delimiter + ys );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
DMMMY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
DMMMYYYY:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
ds + delimiter + monthNames[ m - 1 ] +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delimiter
+ ys );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
YMD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
YYYYMD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
ys + delimiter + ms + delimiter + ds );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
YMMMD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
YYYYMMMD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
ys + delimiter + monthNames[ m - 1 ] +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delimiter
+ ds );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Unknown
format option? Return MDY...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( ms + delimiter
+ ds + delimiter + ys );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This method has been declared <TT>static</TT>
so that it can be used as a conversion function or by an instantiation
of the class.
<P>
One feature available in other languages but not in Java is a
string formatting function. For you C and C++ programmers out
there, I'm talking about <TT>printf</TT>
functionality. With these functions, you usually can create a
string of placeholders for various elements. The placeholders
define the size of the substring in addition to padding. A set
of arguments to put into those placeholders follows all of this.
Unfortunately, Java does not have the capability to accept an
unknown number of arguments to a function, which is required to
provide general string formatting.
<P>
Java's <TT>String</TT> class is an
awesome beast, however. It is well implemented and supports the
<TT>+</TT> operator for concatenation.
Although it's not the perfect solution, it will fit your needs
just fine. By checking to see whether the month or day is less
than 10, you know to add a leading 0.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=590><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=590>
<BLOCKQUOTE>
Notice that when the requested year is not in four digits, you modulus the value with 100. This is a neat and necessary little trick to always keep your year in the range of 0 to 99. When you reach the year 2000, the Java <TT>Date</TT> will return 100 or 
more because the Java <TT>Date</TT> class represents the year as an offset from 1900. Any year over 1999 will result in a number greater than 100.
</BLOCKQUOTE>
<BLOCKQUOTE>
By using the modulus operator, you can ensure that your software will work well into the 21st century.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
You also need to provide some alternative access methods to the
<TT>formatDateToString()</TT> method.
I have created some, but you might want to create more. Those
that I have created follow.
<P>
This default date formatter will create a date of <TT>MM/DD/YY</TT>
from the current value of the <TT>FileDate</TT>
object:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public String
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
&quot;/&quot;, MDY ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
You might select the delimiter and formatting option, however,
which is similar to the default:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public String
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( String delimiter,
int fmtOpt )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
getYear(), getMonth() + 1, getDate(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delimiter,
fmtOpt ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This default date formatter will create a date of <TT>MM/DD/YY</TT>
from the value parsed from string <TT>s</TT>:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public static
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( String s )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
s, &quot;/&quot;, MDY ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This method parses string <TT>s</TT>
and selects a delimiter. It defaults to <TT>MDY</TT>
order:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public static
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( String s, String delimiter
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
s, delimiter, MDY ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This method parses string <TT>s</TT>
and selects a delimiter and an order:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public static
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( String s, String delimiter,
int fmtOpt )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDate date;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date
= FileDate.valueOf( s );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch ( IllegalArgumentException
e )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(
&quot;&quot; );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;Send
a blank delimiter...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
date.getYear(), date.getMonth() + 1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date.getDate(),
delimiter, fmtOpt ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This default date formatter will create a date of <TT>MM/DD/YY</TT>
from the values passed in:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public static
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( int y, int m, int
d )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
y, m, d, &quot;/&quot;, MDY ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This method uses the passed in values and allows the selection
of a delimiter. It defaults to <TT>MDY</TT>
order:
<BLOCKQUOTE>
<TT>public static String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;formatDateToString( int y, int m, int
d, String delimiter )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( formatDateToString(
y, m, d, delimiter, MDY ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<H3><A NAME="ApplicationConfigurationParameters">Application Configuration
Parameters</A></H3>
<P>
The second Java class that you will create for your purposes is
the <TT>ConfigProperties</TT> class.
It extends the Java <TT>Properties</TT>
class to add some unique functionality.
<P>
The intranet applications that you build can become quite complex,
which only results in more testing when you implement changes.
One excellent way to add functionality to complex programs without
programming is by using configuration files. The more you are
able to configure your program, the more useful it is.
<P>
Configuration files are not a new idea; they have been around
for years. Many programmers avoid using them because of the parsing
involved-parsing each line and figuring out what the configuration
line means. Java makes this really easy for you to do, so you
should take advantage of it.
<P>
Application configuration parameters, or properties, can come
from two places: the command line and a configuration file. You
want your class to provide a unified, or merged, set of properties.
To do this, your class should accept an array of properties stored
in strings as input. This array will merge with the array read
from the configuration file stored on disk. The resulting combination
represents all the properties.
<H4>The <TT>ConfigProperties</TT>
Class</H4>
<P>
The declaration for your extension is as follows:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
ConfigProperties&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
<BR>
//****************************************************************************
<BR>
<BR>
public class<BR>
ConfigProperties<BR>
extends Properties</TT>
</BLOCKQUOTE>
<P>
<TT>ConfigProperties</TT> simply extends
the Java <TT>Properties</TT> object.
The real functionality is in the constructor, which for this object
accepts two parameters: an array of property strings and a filename.
<P>
Property strings are strings in the format:
<BLOCKQUOTE>
<TT>key = value</TT>
</BLOCKQUOTE>
<P>
Here, <TT>key</TT> is the name associated
with the value. <TT>key</TT> and <TT>value</TT>
are standard Java property strings that can be passed in on the
command line to any Java application or applet with the <TT>-D</TT>
option. For example, to set the property <TT>head.size</TT>
to <TT>large</TT> in the application
<TT>InflateHead</TT>, the command
line would be as follows:
<BLOCKQUOTE>
<TT>java -Dhead.size=large InflateHead</TT>
</BLOCKQUOTE>
<P>
This and any other arguments are passed into your application's
<TT>main</TT> method as an argument.
If you pass this array of strings onto the <TT>ConfigProperties</TT>
object, it will be merged in with the configuration parameters
in the configuration file.
<P>
The property string array passed in is parsed into a temporary
<TT>Properties</TT> object, as follows:
<BLOCKQUOTE>
<TT>//****************************************************************************
<BR>
//* 
parseArguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*<BR>
//****************************************************************************
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int<BR>
&nbsp;&nbsp;&nbsp;&nbsp;parseArguments( String args[] )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i
= 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( args != null
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( i = 0; i &lt; args.length; i++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
st = new StringTokenizer( args[ i ], &quot;=&quot; );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( st.countTokens() == 2 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argProperties.put(
st.nextToken(), st.nextToken() );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return( i );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
You use the <TT>StringTokenizer</TT>
to break up the strings into their key and value components. The
components are then added to the <TT>argProperties</TT>
object, which is an instance variable of the class. After the
argument properties are parsed and stored, the configuration file
is read in and the argument properties are merged in.
<P>
An important design decision was made for this class. The configuration
file properties are replaced by any matching argument properties.
This is standard operating procedure. For the most part, command
line parameters should always override any stored functionality,
including configuration file parameters. This class implements
that philosophy by adding the argument properties to the configuration
properties after they have been read from disk.
<H4>The Configuration File</H4>
<P>
The configuration file is nothing more than a file containing
lines of the key and value pairs. Listing 8.4 shows a sample configuration
file.
<HR>
<BLOCKQUOTE>
<B>Listing 8.4. A sample configuration file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#<BR>
# Employee.cfg<BR>
# Employee maintenance configuration file<BR>
#<BR>
Title=Employee Files<BR>
user=dia_user<BR>
password=dia<BR>
server=dia_database</TT>
</BLOCKQUOTE>
<HR>
<P>
Use this file to store user names, titles, servers, or just about
any parameter that will help the user to better control your programs.
You'll use these files in your sample intranet applications later
on in the book.
<P>
In <A HREF="ch12.htm" >Chapter 12</A>, &quot;Putting Them All
Together,&quot; you'll see how you can use this class to provide
a unique Java applet function to your intranet applications.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
You've come to the end of your first foray into extending Java
for intranets. Hopefully your interest is piqued. This chapter
introduced you to some utility classes that will be useful when
you develop intranet applications. These classes included timers,
date formatters, and a class to help configure your applications.
<P>
You now should have a decent understanding of these classes and
how you can use them. I showed example programs along with their
output, and you can peruse and run the source code on the CD-ROM.
<P>
In <A HREF="ch9.htm" >Chapter 9</A>, &quot;Logging Classes,&quot;
you will learn all about writing text to a window and to disk
files. That chapter is all about logging-and not the kind that
lumberjacks do!

<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch7.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch9.htm"><IMG 
SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
