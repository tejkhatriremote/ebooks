// Copyright Allen & Company 2005 - all rights reserved
if (Ln>=8) {s=Xc+"8.3</SPAN> (refers to an old-style MS-DOS filename)"+Xb+"Before Windows 95, file (and folder) names were limited to a maximum of 8 characters in the base name (the part before the <SPAN CLASS=ky>&nbsp;Period&nbsp;</SPAN>), and a maximum of 3 characters in the extension. Now, Long File (or Folder) Names can have up to 255 characters (base name plus extension). Old-style names are often referred to as <SPAN CLASS=ci>8.3</SPAN> names (from their length limits)."+Xb+"Windows allocates <B>short-form aliases</B> to all Long Names, for use by old software that can&#39;t read the new Long Names. Short-form aliases are <SPAN CLASS=ci>8.3</SPAN> names (normally generated from the first 6 characters of the base name plus a <SPAN CLASS=ky>&nbsp;~&nbsp;</SPAN> and a digit, and the first 3 characters of the extension)."+Xb+"Long File (or Folder) Names take up more space in the disk file index. So it&#39;s more efficient to use <SPAN CLASS=ci>8.3</SPAN> names when you can. To create a true <SPAN CLASS=ci>8.3</SPAN> name, you must use <SPAN CLASS=br>UPPERCASE</SPAN>, otherwise you create a <B>hybrid name</B> (a name that has a wasteful duplicate Long Name entry in the disk index). Once an <SPAN CLASS=ci>8.3</SPAN> name is properly created, lowercase will do to address it later. In this Course, we use <SPAN CLASS=br>UPPERCASE</SPAN> for <SPAN CLASS=ci>8.3</SPAN> names when first creating them.";Cn["8.3"]=s}
if (Ln>=8) {s=Xc+"COPY</SPAN> (copies files, leaving the original files in place)<BR>"+Xh+Xi+Xaw+Xb+"<NOBR><SPAN CLASS=fx>copy c:&#92;src&#92;file.txt c:&#92;dest&#92;NEW.TXT</SPAN></NOBR><BR><SPAN CLASS=lg>Copies <SPAN CLASS=rfs>file.txt</SPAN> from <SPAN CLASS=rfs>c:&#92;src</SPAN> to <SPAN CLASS=rfs>c:&#92;dest</SPAN> (which <SPAN CLASS=br>must exist</SPAN> already). Copied file is given name <SPAN CLASS=rfs>NEW.TXT</SPAN></SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>copy c:&#92;src&#92;myfile.txt</SPAN></NOBR><BR><SPAN CLASS=lg>No destination is specified, so <SPAN CLASS=rfs>myfile.txt</SPAN> from <SPAN CLASS=rfs>c:&#92;src</SPAN> is copied to the "+Xo+"(&#39;current folder&#39;)'>current folder</A>). The copy retains same name as original.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>copy &#34;c:&#92;my src&#92;a file.txt&#34; &#34;A New.TXT&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Copies the file <NOBR><SPAN CLASS=rfs>a file.txt</SPAN></NOBR> from <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> to the "+Xo+"(&#39;current folder&#39;)'>current folder</A>) as <NOBR><SPAN CLASS=rfs>A New.TXT</SPAN></NOBR> "+Xq+".</SPAN>"+Xb+"See also "+(Ln>=9?Xo+"(&#39;xcopy&#39;)'>xcopy</A>, ":"")+Xo+"(&#39;device&#39;)'>device</A>.";Cn["COPY"]=s}
if (Ln>=8) {s=Xc+"deltree</SPAN> (delete files and entire folder trees)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>DELTREE.EXE</SPAN>). "+Xaw+Xb+"<NOBR><SPAN CLASS=fx>deltree /<SPAN CLASS=or>y</SPAN> &#34;c:&#92;my src&#92;*.*&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Deletes all files and all subfolders of folder <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> assuming <SPAN CLASS=br>y</SPAN>es (<SPAN CLASS=rfs>/<SPAN CLASS=or>y</SPAN></SPAN>) = permission to go ahead. Does <SPAN CLASS=br>not</SPAN> delete the folder <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> itself. Does not report any error if the folder doesn&#39;t exist "+Xq+".</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>deltree /<SPAN CLASS=or>y</SPAN> &#34;c:&#92;my src&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>As above, but <SPAN CLASS=br>also</SPAN> deletes the folder <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> "+Xq+".</SPAN>"+Xb+"Take <SPAN CLASS=br>great care</SPAN> whenever using <SPAN CLASS=ci>deltree</SPAN>!<BR>See also "+Xo+"(&#39;DEL&#39;)'>DEL</A>.";Cn["deltree"]=s}
if (Ln>=9) {s=Xc+"fc</SPAN> (compares two files or two sets of files)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>FC.EXE</SPAN>). "+Xaw+Xb+"<NOBR><SPAN CLASS=fx>fc /<SPAN CLASS=hr>b</SPAN> &#34;c:&#92;my src&#92;*.*&#34; &#34;c:&#92;my dest&#92;*.*&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Makes a <SPAN CLASS=br>b</SPAN>inary comparison of each file in <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> with its same-name counterpart in <NOBR><SPAN CLASS=rfs>c:&#92;my dest</SPAN></NOBR>, if there is one "+Xq+".</SPAN>"+Xb+"A binary comparison compares files byte-by-byte, and is the default for files with extensions <SPAN CLASS=fs>EXE</SPAN>, <SPAN CLASS=fs>COM</SPAN>, <SPAN CLASS=fs>SYS</SPAN>, <SPAN CLASS=fs>OBJ</SPAN>, <SPAN CLASS=fs>LIB</SPAN>, or <SPAN CLASS=fs>BIN</SPAN>. The <SPAN CLASS=ci>fc</SPAN> <SPAN CLASS=fs>/a</SPAN> (=ASCII) switch specifies line-by-line comparison (suitable for text files). In ASCII mode, <SPAN CLASS=ci>fc</SPAN> attempts to resynchronize (rematch) the files after any difference."+(Ln>=14?Xb+"<SPAN CLASS=fg>&nbsp;Note&nbsp;</SPAN> <SPAN CLASS=ci>fc</SPAN> doesn't "+Xo+"(&#39;SET&#39;)'>SET</A> an "+Xo+"(&#39;ERRORLEVEL&#39;)'>ERRORLEVEL</A> directly, but you can use a "+Xo+"(&#39;find&#39;)'>find</A> "+Xo+"(&#39;pipe&#39;)'>pipe</A> with its output to return an "+Xo+"(&#39;ERRORLEVEL&#39;)'>ERRORLEVEL</A> from comparisons. For a detailed example, see Batch Lesson 20 (Exercises 50-56).":"");Cn["fc"]=s}
if (Ln>=9) {s=Xc+"PAUSE</SPAN> (pauses Batch file until key pressed)<BR>"+Xh+Xi+Xb+"<SPAN CLASS=fx>PAUSE&#62;NUL</SPAN><BR><SPAN CLASS=lg>Suppresses standard <SPAN CLASS=qu>Press any key to continue....</SPAN> message by "+Xo+"(&#39;redirection&#39;)'>redirection</A> to "+Xo+"(&#39;NUL&#39;)'>NUL</A>. You should "+Xo+"(&#39;ECHO&#39;)'>ECHO</A> your own message before using this syntax, so the user knows a key (usually <SPAN CLASS=ky>&nbsp;Return&nbsp;</SPAN>) must be pressed to resume.</SPAN>"+(Ln>=10?Xb+"See also "+Xo+"(&#39;choice&#39;)'>choice</A>.":"");Cn["PAUSE"]=s}
if (Ln>=9) {s=Xc+"xcopy</SPAN> (extended copy of files and folders)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>XCOPY.EXE</SPAN>). "+Xaw+(Ln>=14?Xb+"<NOBR><SPAN CLASS=fx>xcopy c:&#92;src&#92;*.* &#34;d:&#92;my dest&#92;*.*&#34; /<SPAN CLASS=or>s</SPAN> /<SPAN CLASS=op>y</SPAN></SPAN></NOBR><BR><SPAN CLASS=lg>Copies all files from <SPAN CLASS=rfs>c:&#92;src</SPAN> and all its <SPAN CLASS=br>s</SPAN>ubfolders to <NOBR><SPAN CLASS=rfs>d:&#92;my dest</SPAN></NOBR>, creating destination folder, if necessary. Assumes <SPAN CLASS=bp>y</SPAN>es to permission to overwrite any existing destination files "+Xq+". In <SPAN CLASS=rfs>d:&#92;my dest&#92;*.*</SPAN>, the "+Xo+"(&#39;wildcard&#39;)'>wildcard</A> prevents <SPAN CLASS=ci>xcopy</SPAN> asking whether or not destination is a folder.</SPAN>":"")+(Ln>=14?Xb+"Many useful <SPAN CLASS=ci>xcopy</SPAN> switches, such as /<SPAN CLASS=bg>l</SPAN> (=<SPAN CLASS=bg>l</SPAN>ist-only) and /<SPAN CLASS=br>h</SPAN> (include <SPAN CLASS=br>h</SPAN>idden and system files) apply only when it&#39;s used in the GUI (not in real-mode). The <SPAN CLASS=ci>xcopy</SPAN> file is a stub that calls further code in another module (usually <SPAN CLASS=fs>XCOPY32.EXE</SPAN> or <SPAN CLASS=fs>XCOPY32.MOD</SPAN>).":"");Cn["xcopy"]=s}
if (Ln>=10) {s=Xc+"EXIST</SPAN> (for use of this test see "+Xo+"(&#39;IF&#39;)'>IF</A>)";Cn["EXIST"]=s}
if (Ln>=10) {s=Xc+"pipe</SPAN> (join the output side of one command to the input side of another)"+(Ln>=16?Xb+"<NOBR><SPAN CLASS=fx>DIR C:&#92;README.TXT /s &#124; find /i &#34;README&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>The pipe operator <SPAN CLASS=fx>&#124;</SPAN> routes the output of the "+Xo+"(&#39;DIR&#39;)'>DIR</A> command to become the input to the "+Xo+"(&#39;find&#39;)'>find</A> command, filtering the "+Xo+"(&#39;DIR&#39;)'>DIR</A> output to show only lines containing the target <SPAN CLASS=rfs>README</SPAN>.</SPAN>":"")+(Ln>=16?Xb+"<NOBR><SPAN CLASS=fx>ECHO.<SPAN CLASS=or>&#124;</SPAN>TIME<SPAN CLASS=op>&#124;</SPAN>find &#34;Current&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>The first pipe operator <SPAN CLASS=fx><SPAN CLASS=or>&#124;</SPAN></SPAN> sends the <NOBR><SPAN CLASS=rfs>ECHO.</SPAN></NOBR> output (a carriage return plus linefeed) to the <NOBR><SPAN CLASS=rfs>TIME</SPAN></NOBR> command (preventing it stalling for input). The second pipe operator <SPAN CLASS=fx><SPAN CLASS=op>&#124;</SPAN></SPAN> then sends the output of the <NOBR><SPAN CLASS=rfs>TIME</SPAN></NOBR> command to become input to the "+Xo+"(&#39;find&#39;)'>find</A> command (passing only the line that shows <SPAN CLASS=rfs>Current</SPAN> time). For explanation of <SPAN CLASS=rfs>TIME</SPAN> command, use <NOBR><SPAN CLASS=rfs>time /?</SPAN></NOBR>.</SPAN>":"");Cn["pipe"]=s}
if (Ln>=13) {s=Xc+"FOR</SPAN> (<SPAN CLASS=ci>IN DO</SPAN>, repeat command on files, or strings)<BR>"+Xh+Xi+Xaw+Xb+"<NOBR><SPAN CLASS=fx>for %%f in (*.txt) do type %%f</SPAN></NOBR><BR><SPAN CLASS=lg>For each file (not hidden or system) with extension <SPAN CLASS=rfs>TXT</SPAN> in "+Xo+"(&#39;current folder&#39;)'>current folder</A>), "+Xo+"(&#39;TYPE&#39;)'>TYPE</A>s the file.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>for %%n in (one two three) do echo.%%n</SPAN></NOBR><BR><SPAN CLASS=lg>"+Xo+"(&#39;ECHO&#39;)'>ECHO</A>es <SPAN CLASS=rfs>one</SPAN>, then <SPAN CLASS=rfs>two</SPAN>, then <SPAN CLASS=rfs>three</SPAN> as if you&#39;d used three separate "+Xo+"(&#39;ECHO&#39;)'>ECHO</A> commands.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>for %%n in (one two) do echo.%%n&#62;&#62;F.TXT</SPAN></NOBR><BR><SPAN CLASS=lg>Writes <SPAN CLASS=rfs>one</SPAN>, then <SPAN CLASS=rfs>two</SPAN> on separate lines to <SPAN CLASS=rfs>F.TXT</SPAN> (note the need to use <SPAN CLASS=fs>&#62;&#62;</SPAN> append operator, otherwise the file will contain only the last item (<SPAN CLASS=rfs>two</SPAN>).</SPAN>"+(Ln>=20?Xb+"<NOBR><SPAN CLASS=fx>for %%s in (&#34;one two three&#34;) do echo.%%s</SPAN></NOBR><BR><SPAN CLASS=lg>Treats <SPAN CLASS=rfs>one two three</SPAN> as single string. "+Xo+"(&#39;ECHO&#39;)'>ECHO</A>es it without the &#34;quotes&#34;.</SPAN>":"")+Xb+"The metavariable <NOBR><SPAN CLASS=fx>%%v</SPAN></NOBR> can use any letter (or most other characters). You can use <NOBR><SPAN CLASS=fx>%v</SPAN></NOBR> (single <SPAN CLASS=ky>&nbsp;%&nbsp;</SPAN>) in immediate mode. Use <SPAN CLASS=ky>&nbsp;%%&nbsp;</SPAN> format in a Batch file."+(Ln>=20?Xb+"See also "+Xo+"(&#39;LFNFOR&#39;)'>LFNFOR</A>, "+Xo+"(&#39;attrib&#39;)'>attrib</A>.":"");Cn["FOR"]=s}
if (Ln>=14) {s=Xc+"find</SPAN> (searches for a text target in one or more files)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>FIND.EXE</SPAN>). "+Xaw+Xb+"<NOBR><SPAN CLASS=fx>find /<SPAN CLASS=or>i</SPAN> &#34;String&#34; &#34;c:&#92;my src&#92;myfile.txt&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Looks for target <SPAN CLASS=rfs>String</SPAN> in <NOBR><SPAN CLASS=rfs>c:&#92;my src&#92;myfile.txt</SPAN></NOBR> <SPAN CLASS=br>i</SPAN>gnoring case in search"+Xq+". A dashed line header with the file name is displayed, and: (a) If target found, the line with it is displayed and "+Xo+"(&#39;ERRORLEVEL&#39;)'>ERRORLEVEL</A> <SPAN CLASS=bg>0</SPAN> (=F<SPAN CLASS=bg>0</SPAN>und) is returned; OR (b) if target missing, "+Xo+"(&#39;ERRORLEVEL&#39;)'>ERRORLEVEL</A> <SPAN CLASS=br>1</SPAN> (=M<SPAN CLASS=br>1</SPAN>ssing) is returned.</SPAN>"+(Ln>=16?Xb+"<NOBR><SPAN CLASS=fx>find /i &#34;String&#34;&#60;&#34;c:&#92;my src&#92;myfile.txt&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Same as above, but with input "+Xo+"(&#39;redirection&#39;)'>redirection</A> (&#60;), <SPAN CLASS=ci>find</SPAN> doesn't output the dashed line header and file name. This is useful in Batch files "+Xq+".</SPAN>":"");Cn["find"]=s}
if (Ln>=15) {s=Xc+"format</SPAN> (creates file system data structures on a disk)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>FORMAT.COM</SPAN>). "+Xaw+(Ln>=17?Xb+"<NOBR><SPAN CLASS=fx>ECHO.N&#124;more&#124;format a: /q /v:MYDISK</SPAN></NOBR><BR><SPAN CLASS=lg>Performs a quick format on the floppy disk in drive <SPAN CLASS=rfs>A:</SPAN>, with usual format questions answered by <SPAN CLASS=rfs>ECHO.N</SPAN> piped through the "+Xo+"(&#39;more&#39;)'>more</A> filter. Volume Label is set to <SPAN CLASS=rfs>MYDISK</SPAN>. This is a quick way of clearing a floppy disk  in a Batch file without any user interaction.</SPAN>":"")+Xb+"<SPAN CLASS=br>Warning</SPAN>: Do not format a disk that contains valuable data. Access to the data will be lost.";Cn["format"]=s}
if (Ln>=16) {s=Xc+"&#60;</SPAN> (Input "+Xo+"(&#39;redirection&#39;)'>redirection</A> operator, see "+Xo+"(&#39;redirection&#39;)'>redirection</A>)";Cn["<"]=s}
if (Ln>=16) {s=Xc+"STDERR</SPAN> (name of handle for Standard Error)"+Xstd+"<SPAN CLASS=ci>STDERR</SPAN> <SPAN CLASS=lg>is the name of the standard error handle. It points to the monitor display ("+Xo+"(&#39;CON&#39;)'>CON</A>), and is used for some error messages. Unlike "+Xo+"(&#39;STDIN&#39;)'>STDIN</A> and "+Xo+"(&#39;STDOUT&#39;)'>STDOUT</A>, messages to <SPAN CLASS=ci>STDERR</SPAN> cannot be re-routed by normal "+Xo+"(&#39;redirection&#39;)'>redirection</A> techniques.</SPAN>"+Xb+"See also "+Xo+"(&#39;STDOUT&#39;)'>STDOUT</A>, "+Xo+"(&#39;STDIN&#39;)'>STDIN</A>, "+Xo+"(&#39;redirection&#39;)'>redirection</A>, "+Xo+"(&#39;pipe&#39;)'>pipe</A>, "+Xo+"(&#39;PRN&#39;)'>PRN</A>.";Cn["STDERR"]=s}
if (Ln>=16) {s=Xc+"STDIN</SPAN> (name of handle for Standard Input)"+Xstd+"<SPAN CLASS=ci>STDIN</SPAN> <SPAN CLASS=lg>is the name of the standard input handle. It normally points to the keyboard ("+Xo+"(&#39;CON&#39;)'>CON</A>), but "+Xo+"(&#39;redirection&#39;)'>redirection</A> can be used to point it elsewhere, typically to a file used as input to a command.</SPAN>"+Xb+"See also "+Xo+"(&#39;STDOUT&#39;)'>STDOUT</A>, "+Xo+"(&#39;STDERR&#39;)'>STDERR</A>, "+Xo+"(&#39;pipe&#39;)'>pipe</A>, "+Xo+"(&#39;redirection&#39;)'>redirection</A>, "+Xo+"(&#39;device&#39;)'>device</A>.";Cn["STDIN"]=s}
if (Ln>=17) {s=Xc+"more</SPAN> (displays output one screenful at a time)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>MORE.COM</SPAN>). "+Xb+"<NOBR><SPAN CLASS=fx>xcopy /? &#124; more</SPAN></NOBR><BR><SPAN CLASS=lg>Displays the extensive <SPAN CLASS=fx>/?</SPAN> help from "+Xo+"(&#39;xcopy&#39;)'>xcopy</A> one screenful at a time.</SPAN>"+Xb+"<SPAN CLASS=ci>more</SPAN> prepends an initial blank line to any text "+Xo+"(&#39;pipe&#39;)'>pipe</A>d through it (useful in Batch files, see "+Xo+"(&#39;format&#39;)'>format</A>).";Cn["more"]=s}
if (Ln>=17) {s=Xc+"REN</SPAN> (rename files or folders)<BR>"+Xh+Xi+Xaw+Xb+"<NOBR><SPAN CLASS=fx>ren &#34;c:&#92;my src&#92;*.txt&#34; *.DOC</SPAN></NOBR><BR><SPAN CLASS=lg>Renames all <SPAN CLASS=rfs>TXT</SPAN> files in <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> to extension <SPAN CLASS=rfs>DOC</SPAN>. Don&#39;t repeat the path (<NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR>) in the new name "+Xq+".</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>ren &#34;c:&#92;csw&#92;my src&#34; &#34;my files&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Renames <NOBR><SPAN CLASS=rfs>c:&#92;csw&#92;my src</SPAN></NOBR> to <NOBR><SPAN CLASS=rfs>c:&#92;csw&#92;my files</SPAN></NOBR>. Again, use only the new subfolder name, don&#39;t repeat the full path "+Xq+".</SPAN>"+Xb+"You can use <SPAN CLASS=ci>RENAME</SPAN> as an alias for <SPAN CLASS=ci>REN</SPAN>.";Cn["REN"]=s};
if (Ln>=17) {s=Xc+"RENAME</SPAN> (see "+Xo+"(&#39;REN&#39;)'>REN</A>, for which <SPAN CLASS=ci>RENAME</SPAN> is an alias)";Cn["RENAME"]=s}
if (Ln>=18) {s=Xc+"move</SPAN> (moves files, renames files and folders)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>MOVE.EXE</SPAN>). "+Xaw+Xb+"<NOBR><SPAN CLASS=fx>move &#34;c:&#92;my src&#34; &#34;c:&#92;src files&#92;new src&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Folder <NOBR><SPAN CLASS=rfs>c:&#92;src files</SPAN></NOBR> must exist beforehand. Then (a) if folder <NOBR><SPAN CLASS=rfs>c:&#92;src files&#92;new src</SPAN></NOBR> also exists, <NOBR><SPAN CLASS=bp>c:&#92;my src</SPAN></NOBR> is renamed to <NOBR><SPAN CLASS=rfs>c:&#92;src files&#92;new src&#92;<SPAN CLASS=bp>my src</SPAN></SPAN></NOBR>; OR (b) if <NOBR><SPAN CLASS=rfs>c:&#92;src files&#92;new src</SPAN></NOBR> doesn't exist: <NOBR><SPAN CLASS=bp>c:&#92;my src</SPAN></NOBR> is itself renamed to <NOBR><SPAN CLASS=rfs>c:&#92;src files&#92;<SPAN CLASS=bp>new src</SPAN></SPAN></NOBR> "+Xq+". In either case, any files in <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> are &#34;moved&#34; along with it.</SPAN>"+Xb+"<SPAN CLASS=ci>move</SPAN> doesn&#39;t physically &#34;move&#34; files, it simply resets the path to them. This is faster than copying files to a new location then deleting the originals.";Cn["move"]=s}
if (Ln>=19) {s=Xc+"doskey</SPAN> (command-line recall, editing, and macros)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>DOSKEY.COM</SPAN>)."+Xb+"<SPAN CLASS=ci>Doskey</SPAN> recalls and repeats previous command lines (with or without changes). It enables <B>macros</B> (brief mnemonics that can invoke several long command lines). Once you are experienced, it will speed up your immediate mode work."+Xb+"However, for this Course to work, you must type out all the Exercises fully. That&#39;s how you learn and remember the syntax. If you were to use <SPAN CLASS=ci>doskey</SPAN> for this Course, it would <SPAN CLASS=br>slow down</SPAN> your learning.";Cn["doskey"]=s}
if (Ln>=20) {s=Xc+"attrib</SPAN> (list and change file or folder attributes)<BR>"+Xh+Xe+"(file=<SPAN CLASS=fs>ATTRIB.EXE</SPAN>). "+Xaw+Xb+"<NOBR><SPAN CLASS=fx>attrib &#34;c:&#92;my src&#92;*.ext&#34; -<SPAN CLASS=hr>s</SPAN> -<SPAN CLASS=op>h</SPAN> -<SPAN CLASS=ob>r</SPAN> -<SPAN CLASS=og>a</SPAN> /s</SPAN></NOBR><BR><SPAN CLASS=lg>Clears the <SPAN CLASS=br>s</SPAN>ystem, <SPAN CLASS=bp>h</SPAN>idden, <SPAN CLASS=ci>r</SPAN>ead-only and <SPAN CLASS=bg>a</SPAN>rchive attributes of all files with extension <SPAN CLASS=rfs>EXT</SPAN> in <SPAN CLASS=rfs>c:&#92;my src</SPAN> and in all its <SPAN CLASS=rfs>/s</SPAN>ubfolders "+Xq+".</SPAN>"+Xb+"<SPAN CLASS=fx>attrib &#34;c:&#92;my src&#34; +<SPAN CLASS=or>s</SPAN> +<SPAN CLASS=op>h</SPAN> +<SPAN CLASS=ob>r</SPAN></SPAN><BR><SPAN CLASS=lg>Sets <SPAN CLASS=br>s</SPAN>ystem, <SPAN CLASS=bp>h</SPAN>idden, and <SPAN CLASS=ci>r</SPAN>ead-only attributes of the folder <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> "+Xq+". "+Xo+"(&#39;wildcard&#39;)'>Wildcards</A> <SPAN CLASS=br>not</SPAN> accepted for folders. Folder names <SPAN CLASS=br>not</SPAN> listed when listing attributes.</SPAN>"+Xb+"File or folder <B>attributes</B> are single-bit flags kept in the file&#39;s or the folder&#39;s entry in its parent folder. Files with hidden or system attributes are <SPAN CLASS=br>not</SPAN> returned by "+Xo+"(&#39;FOR&#39;)'>FOR</A>.";Cn["attrib"]=s}
if (Ln>=20) {s=Xc+"CALL</SPAN> (runs a Batch file, then returns control to caller)<BR>"+Xh+Xi+Xnw+Xb+"<NOBR><SPAN CLASS=fx>CALL MyBatch.bat Par1 Par2</SPAN></NOBR><BR><SPAN CLASS=lg>Runs <SPAN CLASS=rfs>MyBatch.bat</SPAN> in "+Xo+"(&#39;current folder&#39;)'>current folder</A>) then <SPAN CLASS=br>returns control</SPAN> to calling Batch file. Passes <SPAN CLASS=rfs>Par1</SPAN> and <SPAN CLASS=rfs>Par2</SPAN> to <SPAN CLASS=rfs>Mybatch.bat</SPAN> as <NOBR><SPAN CLASS=fx>%1</SPAN></NOBR> and <NOBR><SPAN CLASS=fx>%2</SPAN></NOBR>. If <SPAN CLASS=rfs>MyBatch.bat</SPAN> is not found in "+Xo+"(&#39;current folder&#39;)'>current folder</A>), the "+Xo+"(&#39;PATH&#39;)'>PATH</A> is searched for it.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>CALL MyBatch</SPAN></NOBR><BR><SPAN CLASS=lg>Checks for <SPAN CLASS=rfs>Mybatch.com</SPAN>, <SPAN CLASS=rfs>Mybatch.exe</SPAN>, and <SPAN CLASS=br>lastly</SPAN> for <SPAN CLASS=rfs>Mybatch.bat</SPAN>. Runs the <SPAN CLASS=br>first one</SPAN> found. If none are found in "+Xo+"(&#39;current folder&#39;)'>current folder</A>), "+Xo+"(&#39;PATH&#39;)'>PATH</A> is then searched.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>CALL c:&#92;src&#92;MyBatch.bat</SPAN></NOBR><BR><SPAN CLASS=lg>Checks <SPAN CLASS=br>only</SPAN> for <SPAN CLASS=rfs>MyBatch.bat</SPAN> in <SPAN CLASS=rfs>c:&#92;src</SPAN> folder.</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>CALL &#34;c:&#92;my src&#92;MyBatch.bat&#34; &#34;One Par&#34;</SPAN></NOBR><BR><SPAN CLASS=lg>Runs <SPAN CLASS=rfs>MyBatch.bat</SPAN> in <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR> "+Xq+". Quoted <NOBR><SPAN CLASS=rfs>&#34;One Par&#34;</SPAN></NOBR> is passed as <NOBR><SPAN CLASS=fx>%1</SPAN></NOBR></SPAN>"+Xb+"Variables "+Xo+"(&#39;SET&#39;)'>SET</A> in a <SPAN CLASS=ci>CALL</SPAN> can be used by the caller.<BR>See also "+Xo+"(&#39;command&#39;)'>command</A>.";Cn["CALL"]=s}
if (Ln>=20) {s=Xc+"LFNFOR</SPAN> (use Long File Names with "+Xo+"(&#39;FOR&#39;)'>FOR</A> command)<BR>"+Xh+Xi+Xb+"<NOBR><SPAN CLASS=fx>LFNFOR ON</SPAN></NOBR><BR><SPAN CLASS=lg>Subsequent "+Xo+"(&#39;FOR&#39;)'>FOR</A> commands will return long forms of any filenames found. Thus, in the "+Xo+"(&#39;FOR&#39;)'>FOR</A> command:</SPAN>"+Xb+"<NOBR><SPAN CLASS=fx>FOR %%F IN (&#34;c:&#92;my src&#92;*.txt&#34;) DO ECHO.%%F</SPAN></NOBR><BR><SPAN CLASS=lg>With <NOBR><SPAN CLASS=rfs>LFNFOR ON</SPAN></NOBR>, this "+Xo+"(&#39;ECHO&#39;)'>ECHO</A>es long forms of the <SPAN CLASS=rfs>TXT</SPAN> file names "+Xq+". Only the <SPAN CLASS=br>first</SPAN> file found will include the path <NOBR><SPAN CLASS=rfs>c:&#92;my src</SPAN></NOBR>, however. For any further files found, <SPAN CLASS=br>only</SPAN> the bare name (<SPAN CLASS=br>not</SPAN> the folder) is returned.</SPAN>";Cn["LFNFOR"]=s}
if (Ln>=20) {s=Xc+"SHIFT</SPAN> (move <NOBR><SPAN CLASS=fx>%0-%9</SPAN></NOBR> parameter &#34;window&#34; one step)<BR>"+Xh+Xi+Xb+"<SPAN CLASS=fx>SHIFT</SPAN><BR><SPAN CLASS=lg>In a Batch file, each <SPAN CLASS=rfs>SHIFT</SPAN> moves what was in <NOBR><SPAN CLASS=fx>%1</SPAN></NOBR> to <NOBR><SPAN CLASS=fx>%0</SPAN></NOBR>, moves <NOBR><SPAN CLASS=fx>%2</SPAN></NOBR> to <NOBR><SPAN CLASS=fx>%1</SPAN></NOBR>, and so on for whole command line. Often used to process parameters one-by-one. After a <SPAN CLASS=ci>SHIFT</SPAN>, the previous value of <NOBR><SPAN CLASS=fx>%0</SPAN></NOBR> is <SPAN CLASS=br>lost</SPAN>.</SPAN>"+Xb+"<NOBR>"+Xo+"(&#39;FOR&#39;)'>FOR</A><SPAN CLASS=fx> %%C IN (1 2 3) DO SHIFT</SPAN></NOBR><BR><SPAN CLASS=lg>Does three <SPAN CLASS=rfs>SHIFT</SPAN>s in one operation: moves <NOBR><SPAN CLASS=fx>%3</SPAN></NOBR> to <NOBR><SPAN CLASS=fx>%0</SPAN></NOBR>, moves <NOBR><SPAN CLASS=fx>%4</SPAN></NOBR> to <NOBR><SPAN CLASS=fx>%1</SPAN></NOBR>, and so on for whole command line.</SPAN>";Cn["SHIFT"]=s}
