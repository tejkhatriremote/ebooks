<html>
<head>
<meta name=vsisbn content="067231486x">
<meta name=vstitle content="Programming Microsoft Windows 2000 Unleashed">
<meta name=vsauthor content="MICKEY WILLIAMS">
<meta name=vsimprint content="Sams">
<meta name=vspublisher content="Macmillan Computer Publishing">
<meta name=vspubdate content="06/21/99">
<meta name=vscategory content="Operations Systems: Windows 2000">



<title>Programming Microsoft Windows 2000 Unleashed:Building Components for COM[TITLE]#43; Services</TITLE>
<!-- BEGIN HEADER -->
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//--></SCRIPT>

<!-- HEADER -->
<style type="text/css">
<!--
A:hover { color:red }
-->
</STYLE>

<!-- HEADER -->
<style type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
 </STYLE>

</HEAD>
<BODY bgcolor=#FFFFFF><FONT size=2 face="Arial, verdana, helvetica"><table width=100% border=0 cellspacing=0 cellpadding=2><tr bgcolor=#000000><td width=100% align=right><b><font color=#FFFFFF>Gotcha</font></b></td></tr></table><br><!--Begin Content Column -->

<table border=0 cellspacing=0 cellpadding=0>
<tr>
<td width=75 valign=top>
<img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/images/sm_covers/067231486x.gif" width=60 height=73 alt="Programming Microsoft Windows 2000 Unleashed" border="1">
</td>
<td align="left">
    <font face="arial, helvetica" size="-1" color="#336633"><b>Programming Microsoft Windows 2000 Unleashed</b></font>
    <br>
    <font face="arial, helvetica" size="-1"><i>by MICKEY WILLIAMS</i>
    <br>
    Sams,&nbsp;Macmillan Computer Publishing
    <br>
    <b>ISBN:</b>&nbsp;067231486x<b>&nbsp;&nbsp;&nbsp;Pub Date:</b>&nbsp;06/21/99</font>
</td>
</tr>
</table>
<p>
<!-- Empty Reference Subhead-->

<!--ISBN=067231486x//-->
<!--TITLE=Programming Microsoft Windows 2000 Unleashed//-->
<!--AUTHOR=Mickey Williams//-->
<!--PUBLISHER=Macmillan Computer Publishing//-->
<!--IMPRINT=sams//-->
<!--CHAPTER=22//-->
<!--PAGES=748-753//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<center>
<table border>
<tr>
<td><a href="22-06.html">Previous</A></TD>
<td><a href="../ewtoc.html">Table of Contents</A></TD>
<td><a href="22-08.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<p><br></P>
<p><font size="+1"><b>Specifying the Transaction Attribute</B></FONT></P>
<p>To specify the Visual Basic transaction attribute, open the Visual Basic environment and create a class file. Then, from the Properties dialog box shown in Figure 22.11, look at <small>MTSTransactionMode</SMALL>.</P>
<p><a name="Fig11"></A><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-11.jpg',263,358 )"><img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-11t.jpg"></A>
<br><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-11.jpg',263,358)"><font color="#000077"><b>Figure 22.11</B></FONT></A>&nbsp;&nbsp;Visual Basic transactional properties.</P>
<p>You can specify the following standard properties:
</P>
<dl>
<dd><b>&#149;</B>&nbsp;&nbsp;<small>NotAnMTSObject</SMALL> is not a transactional property within the COM&#43; services.
<dd><b>&#149;</B>&nbsp;&nbsp;<small>RequiresTransaction</SMALL> is <small>TRANSACTION_REQUIRED</SMALL>.
<dd><b>&#149;</B>&nbsp;&nbsp;<small>UsesTransaction</SMALL> is <small>TRANSACTION_SUPPORTED</SMALL>.
<dd><b>&#149;</B>&nbsp;&nbsp;<small>NoTransactions</SMALL> is <small>TRANSACTION_NOT_SUPPORTED</SMALL>.
<dd><b>&#149;</B>&nbsp;&nbsp;<small>RequiresNewTransaction</SMALL> is <small>TRANSACTION_REQUIRES_NEW</SMALL>.
</DL>
<h3><a name="Heading10"></A><font color="#000077">Using COM Compiler Support</FONT></H3>
<p>The COM compiler support classes make it a breeze to work with COM interfaces. Basically, the COM compiler support classes perform the following functions:
</P>
<dl>
<dd><b>&#149;</B>&nbsp;&nbsp;When used in conjunction with the <small>#import</SMALL> tag, they generate an easy-to-use interface for methods and properties.
<dd><b>&#149;</B>&nbsp;&nbsp;They define a simpler variant and <small>BSTR</SMALL> class.
<dd><b>&#149;</B>&nbsp;&nbsp;They include an automatic reference-counting scheme.
<dd><b>&#149;</B>&nbsp;&nbsp;They use assignment overloading with <small>QueryInterface</SMALL> to make it simple to assign variables to interface.
</DL>
<p>The notation for using COM compiler support is as follows:
</P>
<!-- CODE SNIP //-->
<pre>
   #import &#147;file&#148; attributes
</PRE>
<!-- END CODE SNIP //-->
<p>Or you can use this:
</P>
<!-- CODE SNIP //-->
<pre>
   #import &ltfile&gt attributes
</PRE>
<!-- END CODE SNIP //-->
<p>Here are the file types involved:
</P>
<dl>
<dd><b>&#149;</B>&nbsp;&nbsp;A type library (such as TLB or ODL)
<dd><b>&#149;</B>&nbsp;&nbsp;An executable file (EXE)
<dd><b>&#149;</B>&nbsp;&nbsp;A library file (such as DLL or OCX)
<dd><b>&#149;</B>&nbsp;&nbsp;A compound document that contains a type library definition
<dd><b>&#149;</B>&nbsp;&nbsp;Anything that can be understood by the <small>LoadTypeLib</SMALL> WINAPI
</DL>
<p>What is generated is a series of classes that make it possible to use COM objects as if they were regular C<small>&#43;&#43;</SMALL> objects. The output includes TLI (type library implementation) and TLH (type library header) files. These files can be used without calling <small>#import</SMALL>. They&#146;re straight C<small>&#43;&#43;</SMALL>. This process is illustrated in Figure 22.12.</P>
<p><a name="Fig12"></A><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-12.jpg',198,420 )"><img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-12t.jpg"></A>
<br><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/067231486x/ch22/images/22-12.jpg',198,420)"><font color="#000077"><b>Figure 22.12</B></FONT></A>&nbsp;&nbsp;The TLH and TLI generation process.</P>
<h4 align="LEFT"><a name="Heading11"></A><font color="#000077">TLH and TLI: Examining the Output</FONT></H4>
<p>Consider the following actual IDL definition:
</P>
<!-- CODE //-->
<pre>
       [
           object,
           uuid(AD8A2F1F-9D18-11D2-86DF-0000B45FCBCB),
           dual,
           helpstring(&#147;IICaller Interface&#148;),
           pointer_default(unique)
       ]
       interface IICaller : IDispatch
       {
           [id(1), helpstring(&#147;method callChild&#148;)] HRESULT callChild();
       };
</PRE>
<!-- END CODE //-->
<p>When this IDL is compiled as part of a library, the COM compiler will generate the following code:
</P>
<p><i>COMCompiler.TLH</I></P>
<!-- CODE //-->
<pre>
   // Created by Microsoft (R) C/C&#43;&#43; Compiler Version 11.00.0000 (c9163f02).
   //
   // Debug/COMCompiler.tlh
   //
   // C&#43;&#43; source equivalent of Win32 type library C:\docs\COMCompiler\
   // Debug\COMCompiler.dll
   // compiler-generated file created 11/05/97 at 02:09:19 - DO NOT EDIT!

   #pragma once
   #pragma pack(push, 8)
   #include &ltcomdef.h&gt
   namespace COMCOMPILERLib {
   //
   // Forward references and typedefs
   //
   struct /* coclass */ Caller;
   struct __declspec(uuid(&#147;421a0bce-5574-11d1-a503-0080c886ec30&#148;))
   /* dual interface */ ICaller;
   //
   // Smart pointer typedef declarations
   //
   _COM_SMARTPTR_TYPEDEF(ICaller, __uuidof(ICaller));
   //
   // Type library items
   //
   struct __declspec(uuid(&#147;421a0bcf-5574-11d1-a503-0080c886ec30&#148;))
   Caller;
   // [ default ] interface ICaller
   struct __declspec(uuid(&#147;421a0bce-5574-11d1-a503-0080c886ec30&#148;))
   ICaller : IDispatch
   {
       //
       // Wrapper methods for error-handling
       //
       HRESULT callChild ( );
       //
       // Raw methods provided by interface
       //
       virtual HRESULT __stdcall raw_callChild ( ) = 0;
   };
   //
   // Wrapper method implementations
   //
   #include &#147;Debug/COMCompiler.tli&#148;
   } // namespace COMCOMPILERLib
   #pragma pack(pop)
</PRE>
<!-- END CODE //-->
<p><i>COMCompiler.TLI</I></P>
<!-- CODE //-->
<pre>
   // Created by Microsoft (R) C/C&#43;&#43; Compiler Version 11.00.0000 (c9163f02).
   //
   // Debug/COMCompiler.tli
   //
   // Wrapper implementations for Win32 type library C:\docs\ProMTS\08chap\
   // COMCompiler\Debug\COMCompiler.dll
   // compiler-generated file created 11/05/97 at 02:09:19 - DO NOT EDIT!

   #pragma once

   //
   // interface ICaller wrapper method implementations
   //

   inline HRESULT ICaller::callChild ( ) {
       HRESULT _hr = raw_callChild();
       if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
       return _hr;
   }
</PRE>
<!-- END CODE //-->
<p>Without any attributes, all the generate COM classes are encapsulated within a namespace. In this example, it&#146;s <small>COMCOMPILERLib</SMALL>. I recommend that you leave it &#147;as is,&#148; because in the future there will be class naming conflicts. Without a namespace, interfaces require a longer, more-complex naming convention.</P>
<p>COM uses a vtable (virtual table) as a method signature. Now, look at how the COM compiler generates the vtable. It creates two methods: <small>callChild</SMALL> and <small>raw_callChild</SMALL>. The method <small>callChild</SMALL> is what you would use in your implementation. The method <small>raw_callChild</SMALL> is part of the vtable and represents the COM object. Here are the reasons for the two methods:</P>
<dl>
<dd><b>&#149;</B>&nbsp;&nbsp;The COM compiler can generate an exception if the method returns an incorrect answer.
<dd><b>&#149;</B>&nbsp;&nbsp;The exposed method uses the simpler wrapper classes for <small>BSTR</SMALL>s and variants.
<dd><b>&#149;</B>&nbsp;&nbsp;Properties are implemented like properties and not like method calls using &#147;out&#148; pointers.
</DL>
<p>The smart pointer is defined in <small>_COM_SMARTPTR_TYPEDEF</SMALL>, which is a macro that creates a type that adds <small>Ptr</SMALL> to the interface. Therefore, in our example</P>
<!-- CODE SNIP //-->
<pre>
   ICaller
</PRE>
<!-- END CODE SNIP //-->
<p>becomes
</P>
<!-- CODE SNIP //-->
<pre>
   ICallerPtr
</PRE>
<!-- END CODE SNIP //-->
<p>This makes it possible for any interface to be converted into a smart pointer. Just use the macro definition and the interface you want as a smart pointer. The only difference is that the wrapper methods will not be visible, because the COM compiler generates them.
</P>
<blockquote>
<p><font size="-1"><hr><b>Tip:&nbsp;&nbsp;</B><p>When passing a COM compiler&#150;generated class back to the original caller using an <small>[out]</SMALL> parameter, you need to use the notation <small>ptrRet = smrtPtr.Detach()</SMALL>, because when a smart pointer class is assigned, an <small>AddRef</SMALL> is not called. This could cause the object to be released too early.</P>
</FONT><hr>
</BLOCKQUOTE>
<h4 align="LEFT"><a name="Heading12"></A><font color="#000077">COM Compiler Command Attributes</FONT></H4>
<p>You can specify a variety of attributes in the file that will help you in importing your typelib information. The most common attribute that you may use is the <small>no_namespace</SMALL> tag. It allows you to add your typelib information without a namespace definition. Although this makes it easier to define and implement objects, it&#146;s really a trade-off, because you open yourself to the possibility that two suppliers might name their objects identically. For example, an object named <small>String</SMALL> is very generic and could be a part of many libraries. Therefore, you should leave the namespace extension.</P>
<p>While we&#146;re on the topic of namespaces, keep in mind that the COM compiler creates a namespace based on the library name defined in the component IDL file. Very often, this name is obtuse and not fun to reference. In fact, the namespace being used by the component could conflict with the namespace of another component.</P>
<p>When you&#146;re creating a typelib that needs to be used in an MTS context, such as the <small>IObjectContext::CreateInstance</SMALL> function, the method expects to see GUID definitions such as <small>IID_<i>xxx</I></SMALL> and <small>CLSID_<i>xxx</I></SMALL>. By default, the COM compiler does not generate this information. Instead, the interface pointer and the method <small>__uuidof</SMALL> is used to retrieve the GUID. Here&#146;s an example:</P>
<!-- CODE SNIP //-->
<pre>
   __uuidof( IMySampleInterface)
</PRE>
<!-- END CODE SNIP //-->
<p>Here&#146;s the same example represented in old GUID terms:
</P>
<!-- CODE SNIP //-->
<pre>
   IID_MySampleInterface
</PRE>
<!-- END CODE SNIP //-->
<p>Both are okay, but to make the COM compiler generate the old GUIDs, the attribute <small>named_guids</SMALL> has to be added to the <small>#import</SMALL> line.</P>
<p>Very often in COM components, some elements are defined that have already been defined elsewhere. And, very often in these cases, a conflict will happen and an error will be reported. This error makes it impossible to compile the application or component. The simplest solution to this problem is to <i>not</I> add the conflicting component, but very often this means that it&#146;s impossible to use both components at the same time. This is another unpleasant occurrence. The way that the COM compiler solves this is by adding the attribute <small>exclude</SMALL>:</P>
<!-- CODE SNIP //-->
<pre>
   exclude(&#147;item1&#148;, &#147;item2&#148;, ...)
</PRE>
<!-- END CODE SNIP //-->
<p>Here, <small>item<i>x</I></SMALL> can be anything defined within the component being imported.</P><p><br></P>
<center>
<table border>
<tr>
<td><a href="22-06.html">Previous</A></TD>
<td><a href="../ewtoc.html">Table of Contents</A></TD>
<td><a href="22-08.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


</font></BODY></HTML>