<html>
<head>
<meta name=vsisbn content="0782124488">
<meta name=vstitle content="Mastering Windows 2000 Professional">
<meta name=vsauthor content="Mark Minasi, Todd Phillips">
<meta name=vspublisher content="Sybex, Inc.">
<meta name=vspubdate content="01/01/00">
<meta name=vscategory content="Operations Systems: Windows 2000">



<title>Mastering Windows 2000 Professional:Understanding the Architecture</TITLE>
<!-- BEGIN HEADER -->
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//--></SCRIPT>

<!-- HEADER -->
<style type="text/css">
<!--
A:hover { color:red }
-->
</STYLE>

<!-- HEADER -->
<style type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
 </STYLE>

<script language="JavaScript1.2">
<!--
function checkForQuery(fm) {
  /* get the query value */
  var i = escape(fm.query.value);
  if (i == "") {
      alert('Please enter a search word or phrase');
      return false;
  }                  /* query is blank, dont run the .jsp file */
  else return true;  /* execute the .jsp file */
}
//--></script>

</HEAD>
<BODY bgcolor=#FFFFFF><FONT size=2 face="Arial, verdana, helvetica"><table width=100% border=0 cellspacing=0 cellpadding=2><tr bgcolor=#000000><td width=100% align=right><b><font color=#FFFFFF>Gotcha</font></b></td></tr></table><br><!--Begin Content Column -->

<table border=0 cellspacing=0 cellpadding=0>
<tr>
<td width=75 valign=top>
<img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/images/sm_covers/0782124488.gif" width=60 height=73 alt="Mastering Windows 2000 Professional" border="1">
</td>
<td align="left">
    <font face="arial, helvetica" size="-1" color="#336633"><b>Mastering Windows 2000 Professional</b></font>
    <br>
    <font face="arial, helvetica" size="-1"><i>by Mark Minasi, Todd Phillips</i>
    <br>
    Sybex, Inc.
    <br>
    <b>ISBN:</b>&nbsp;0782124488<b>&nbsp;&nbsp;&nbsp;Pub Date:</b>&nbsp;01/01/00</font>
</td>
</tr>
</table>
<p>
<!-- Empty Reference Subhead-->

<!--ISBN=0782124488//-->
<!--TITLE=Mastering Windows 2000 Professional//-->
<!--AUTHOR=Mark Minasi//-->
<!--AUTHOR=Todd Phillips//-->
<!--PUBLISHER=SYBEX//-->
<!--CHAPTER=18//-->
<!--PAGES=552-554//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<center>
<table border>
<tr>
<td><a href="549-551.html">Previous</A></TD>
<td><a href="../ewtoc.html">Table of Contents</A></TD>
<td><a href="556-559.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<p><br></P>
<h4 align="LEFT"><a name="Heading11"></A><font color="#000077">A Basic Layered Operating System</FONT></H4>
<p>Most PC operating systems are <i>layered</I> operating systems, meaning that they consist of a bunch of pieces of software stacked one atop the other. The pieces tied most closely to the hardware are always represented at the bottom and application software is always at the top. Sandwiched between the applications that users want to run and the hardware on which they want to run, the applications are the intermediary programs that communicate between the two. Figure 18.1 depicts a basic representation of a layered operating system.</P>
<p><a name="Fig1"></A><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-01.jpg',500,403)"><img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-01t.jpg"></A>
<br><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-01.jpg',500,403)"><font color="#000077"><b>Figure 18.1</B></FONT></A>&nbsp;&nbsp;The structure of a typical layered operating system, the very basis of more advanced architectures</P>
<p>To a certain extent, the layered structure in Figure 18.1 also represents the design of DOS, OS/2, Windows 3.1, and Windows 9<i>x</I>.</P>
<p>At the lowest level of software are the device drivers, which manipulate the system hardware. The APIs, or <i>application programming interfaces</I>, are the doorway to the operating system as far as the applications are concerned. If an application wants to create a file, read a keystroke, or paint the screen blue, it must go through the operating system, and it must access the operating system through the APIs. DOS has an API of its own, as do Windows 3.1 and Windows 9<i>x</I>, so modern layered operating systems often support multiple APIs to allow backward compatibility.</P>
<p>An API is the published set of legal tasks that an operating system can do for an application&#151;examples include opening a file, reading a keystroke, or ending a program. Of course, since we are dealing with computers, there are <i>i</I>&#146;s to be dotted and <i>t</I>&#146;s to be crossed. For example, one operating system might open a file with the command <tt>DOSOPENFILE</TT>, and another might open a file with the <tt>makefile</TT> command. Those two commands do the same thing, but they do it in different operating systems, in much the same way that you express the idea <i>hello</I> differently in different languages.</P>
<p>Windows NT, OS/2, and Windows 3<i>.x</I> all used different APIs, and so developers have always had to decide which API to focus their efforts on. Because of the large size of the Windows market, most vendors work first in Windows and then port their applications from Windows to some other operating system. An application trying to access a modern operating system from anything other than the APIs will crash. (We say <i>modern</I> operating system because it was possible under DOS to jump into the operating system at any old place, leading to a host of compatibility nightmares for people trying to build &#147;compatible&#148; PC computers.)</P>
<p>In between the APIs and the device drivers is the Kernel, which manages the whole thing.</P>
<h4 align="LEFT"><a name="Heading12"></A><font color="#000077">A Client-Server, Microkernel Operating System</FONT></H4>
<p>The only thing wrong with the previous model is that virtually all the applications themselves must live in Kernel mode. That <i>does</I> make securing the operating system a bit harder, at least when compared with a <i>client-server</I> or <i>micro</I>kernel architecture, which is depicted in Figure 18.2. (It&#146;s called client-server because parts of the operating system treat each other as clients or servers.)</P>
<p><a name="Fig2"></A><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-02.jpg',500,625)"><img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-02t.jpg"></A>
<br><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-02.jpg',500,625)"><font color="#000077"><b>Figure 18.2</B></FONT></A>&nbsp;&nbsp;The microkernel or client-server operating system model moves more of the software into the User mode.</P>
<p>Notice that Figure 18.2 distinguishes between Kernel mode and User mode. The basic layered operating system presented in the preceding section puts everything but the applications in the Kernel mode. The client-server or microkernel model puts only the bare minimum (hence the <i>micro</I> part of microkernel) in Kernel mode. One reason that the client-server model seems worth the effort is that operating system designers want their systems to be robust and stable.</P>
<p>One way to accomplish those goals is to simply write operating systems without bugs in them. (Now that we&#146;ve had a little laugh, let&#146;s look at another way.) Another way is to exploit the memory protection functions built right into modern processor chips. Kernel mode programs are scary in that they can scribble all over <i>any</I> part of the system&#146;s memory. Also, User mode programs can be imprisoned in memory areas, and if they try to escape by exceeding their bounds, the CPU hardware automatically sounds the alarm.</P>
<p>One of the major goals of the client-server model is, then, to minimize the number of parts that run in Kernel mode. There is, of course, a downside to the client-server model, one that can significantly affect performance and that we consider in the next section.</P>
<h4 align="LEFT"><a name="Heading13"></A><font color="#000077">The Cost of Client-Server</FONT></H4>
<p>The processor requires a bit of time&#151;a few tens of microseconds&#151;to shift between Kernel mode and User mode. Although that may not sound like very much, consider that a 100MHz microprocessor can sometimes get <i>1,000 instructions</I> to execute in 10 microseconds. Consequently, every User/Kernel mode shift is expensive in terms of operating system performance.</P>
<p>Now consider that in a microkernel operating system, User modules cannot see other User modules (applications that don&#146;t run in Kernel mode) and cannot directly communicate with them. This necessitates mode shifts. For example, imagine that an application wants to tell the operating system to read a keystroke. To do this, it needs to make an API function call, because the APIs are the authorized doorways into the operating system. In a simple layered model, the application simply calls the API, which takes care of communicating with the operating system. But the lines of communication aren&#146;t so straightforward in a microkernel model, where the communication flow looks more like Figure 18.3.</P>
<p><a name="Fig3"></A><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-03.jpg',500,517)"><img webstripperattrwas="src" webstripperlinkwas="http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-03t.jpg"></A>
<br><a href="javascript:displayWindow('../WebStripper/protected.html#link=http://corpitk.earthweb.com/reference/pro/0782124488/ch18/images/18-03.jpg',500,517)"><font color="#000077"><b>Figure 18.3</B></FONT></A>&nbsp;&nbsp;User module communication in a microkernel model</P>
<p>In the microkernel model, the application, instead of calling the API, calls a piece of the microkernel whose only job is to pass messages (in Windows 2000, it&#146;s called the <i>Local Procedure Call</I> facility or <i>LPC</I>). The LPC forwards the message to the API.</P>
<p>Here&#146;s the path of the message: The message goes from the application across the User/Kernel boundary to the LPC, and from the LPC back to the API across the User/ Kernel boundary again. That&#146;s the point at which the API knows to ask the operating system to do something, and this of course generates another User/Kernel mode shift. Further, accessing the network, the file system, the display, or the user interface involves piles of mode shifts. The latter are all User modules as well, so messages passed between them must go through the User/Kernel boundary.</P><p><br></P>
<center>
<table border>
<tr>
<td><a href="549-551.html">Previous</A></TD>
<td><a href="../ewtoc.html">Table of Contents</A></TD>
<td><a href="556-559.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


</font></BODY></HTML>