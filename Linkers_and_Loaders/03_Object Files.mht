From: <Saved by Microsoft Internet Explorer 5>
Subject: Object Files
Date: Fri, 13 May 2005 09:49:58 +0530
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_002A_01C557A1.1FB0D180"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1441

This is a multi-part message in MIME format.

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.iecc.com/linker/linker03.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Object Files</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252">
<META content=3D"MSHTML 6.00.2800.1498" name=3DGENERATOR></HEAD>
<BODY>
<H1>Object Files</H1><I>$Revision: 2.6 $</I> <BR><I>$Date: 1999/06/29 =
04:21:48=20
$</I>=20
<P>
<P>
<TABLE cellSpacing=3D0 cols=3D1 cellPadding=3D0 bgColor=3Dpink>
  <TBODY>
  <TR>
    <TD>Compilers and assemblers create object files containing the =
generated=20
      binary code and data for a source file. Linkers combine multiple =
object=20
      files into one, loaders take object files and load them into =
memory. (In=20
      an integrated programming environment, the compilers, assemblers, =
and=20
      linkers are run implicitly when the user tells it to build a =
program, but=20
      they're there under the covers.) In this chapter we delve into the =
details=20
      of object file formats and contents. </TD></TR></TBODY></TABLE>
<P>
<H2>What goes into an object file?</H2>An object file contains five =
kinds of=20
information.=20
<UL>
  <LI><I>Header information:</I> overall information about the file, =
such as the=20
  size of the code, name of the source file it was translated from, and =
creation=20
  date.=20
  <LI><I>Object code:</I> Binary instructions and data generated by a =
compiler=20
  or assembler.=20
  <LI><I>Relocation:</I> A list of the places in the object code that =
have to be=20
  fixed up when the linker changes the addresses of the object code.=20
  <LI><I>Symbols:</I> Global symbols defined in this module, symbols to =
be=20
  imported from other modules or defined by the linker.=20
  <LI><I>Debugging information:</I> Other information about the object =
code not=20
  needed for linking but of use to a debugger. This includes source file =
and=20
  line number information, local symbols, descriptions of data =
structures used=20
  by the object code such as C structure definitions. </LI></UL>(Some =
object files=20
contain even more than this, but these are plenty to keep us occupied in =
this=20
chapter.)=20
<P>
<P>Not all object formats contain all of these kinds of information, and =
it's=20
possible to have quite useful formats with little or no information =
beyond the=20
object code.=20
<P>
<H3>Designing an object format</H3>The design of an object format is a=20
compromise driven by the various uses to which an object file is put. A =
file may=20
be <I>linkable</I>, used as input by a link editor or linking loader. It =
my be=20
<I>executable</I>, capable of being loaded into memory and run as a =
program,=20
<I>loadable</I>, capable of being loaded into memory as a library along =
with a=20
program, or any combination of the three. Some formats support just one =
or two=20
of these uses, others support all three.=20
<P>
<P>A linkable file contains extensive symbol and relocation information =
needed=20
by the linker along with the object code. The object code is often =
divided up=20
into many small logical segments that will be treated differently by the =
linker.=20
An executable file contains object code, usually page aligned to permit =
the file=20
to be mapped into the address space, but doesn't need any symbols =
(unless it=20
will do runtime dynamic linking), and needs little or no relocation =
information.=20
The object code is a single large segment or a small set of segments =
that=20
reflect the hardware execution environment, most often read-only vs. =
read-write=20
pages. Depending on the details of a system's runtime environment, a =
loadable=20
file may consist solely of object code, or may contain complete symbol =
and=20
relocation information to permit runtime symbolic linking.=20
<P>
<P>There is some conflict among these applications. The logically =
oriented=20
grouping of linkable segments rarely matches the hardware oriented =
grouping of=20
executable segments. Particularly on smaller computers, linkable files =
are read=20
and written by the linker a piece at a time, while executable files are =
loaded=20
in their entirely into main memory. This distinction is most obvious in =
the=20
completely different MS-DOS linkable OMF format and executable EXE =
format.=20
<P>
<P>We'll tour a series of popular formats, starting with the simplest, =
and=20
working up to the most complicated.=20
<P>
<H2>The null object format: MS-DOS .COM files</H2>It's quite possible to =
have a=20
usable object file with no information in it whatsoever other than the =
runnable=20
binary code. The MS-DOS .COM format is the best-known example. A .COM =
file=20
literally consists of nothing other than binary code. When the operating =
system=20
runs a .COM file, it merely loads the contents of the file into a chunk =
of free=20
memory starting at offset 0x100, (0-FF are the, PSP, Program Segment =
Prefix with=20
command line arguments and other parameters), sets the x86 segment =
registers all=20
to point to the PSP, the SP (stack pointer) register to the end of the =
segment,=20
since the stack grows downward, and jumps to the beginning of the loaded =

program.=20
<P>
<P>The segmented architecture of the x86 makes this work. Since all x86 =
program=20
addresses are interpreted relative to the base of the current segment =
and the=20
segment registers all point to base of the segment, the program is =
always loaded=20
at segment-relative location 0x100. Hence, for a program that fits in a =
single=20
segment, no fixups are needed since segment-relative addresses can be =
determined=20
at link time.=20
<P>
<P>For programs that don't fit in a single segment, the fixups are the=20
programmer's problem, and there are indeed programs that start out by =
fetching=20
one of their segment registers, and adding its contents to stored =
segment values=20
elsewhere in the program. Of course, this is exactly the sort of tedium =
that=20
linkers and loaders are intended to automate, and MS-DOS does that with =
.EXE=20
files, described later in this chapter.=20
<P>
<H2>Code sections: Unix a.out files</H2>Computers with hardware memory=20
relocation (nearly all of them, these days) usually create a new process =
with an=20
empty address space for each newly run program, in which case programs =
can be=20
linked to start at a fixed address and require no relocation at load =
time. The=20
Unix a.out object format handles this situation.=20
<P>
<P>In the simplest case, an a.out file consisted of a small header =
followed by=20
the executable code (called the text section for historical reasons) and =
the=20
initial values for static data, Figure 1. The PDP-11 had only 16 bit =
addressing,=20
which limited programs to a total of 64K. This limit quickly became too =
small,=20
so later models in the PDP-11 line provided separate address spaces for =
code (I=20
for Instruction space) and data (D space), so a single program could =
contain=20
both 64K of code and 64K of data. To support this feature, the =
compilers,=20
assembler, and linker were modified to create two-section object files, =
with the=20
code in the first section and the data in the second section, and the =
program=20
loader loaded the first section into a process' I space and the second =
into the=20
D space.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-01.html"><IMG=20
      height=3D104 =
src=3D"http://www.iecc.com/linker/thumb-linker03-01.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 1:</I> Simplifed a.out <BR>a.out header text section =
data=20
      section other sections </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>Separate I and D space had another performance advantage: since a =
program=20
couldn't change its own I space, multiple copies of a single program =
could share=20
a single copy of a program's code, while keeping separate copies of the=20
program's data. On a time-shared system like Unix, multiple copies of =
the shell=20
(the command interpreter) and network daemons are common, and shared =
program=20
code saves considerable real memory.=20
<P>
<P>The only currently common computer that still uses separate =
addressing for=20
code and data is the 286 (or 386 in 16 bit protected mode). Even on more =
modern=20
machines with large address spaces, the operating system can handle =
shared=20
read-only code pages in virtual memory much more efficiently than =
read/write=20
pages, so all modern loaders support them. This means that linker =
formats must=20
at the least mark read-only versus read-write sections. In practice, =
most linker=20
formats have many sections, such as read-only data, symbols and =
relocation for=20
subsequent linking, debugging symbols, and shared library information. =
(Unix=20
convention confusingly calls the file sections segments, so we use that =
term in=20
discussions of Unix file formats.)=20
<P>
<H3>a.out headers</H3>The header varies somewhat from one version of =
Unix to=20
another, but the version in BSD Unix, Figure 2 is typical. (In the =
examples in=20
this chapter, int values are 32 bits, and short are 16 bits.)=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 2 --></TD>
    <TD><I>Figure 2:</I> a.out header <BR>
      <P><TT><BR>int a_magic; // magic number <BR>int a_text; // text =
segment=20
      size <BR>int a_data; // initialized data size <BR>int a_bss; //=20
      uninitialized data size <BR>int a_syms; // symbol table size =
<BR>int=20
      a_entry; // entry point <BR>int a_trsize; // text relocation size =
<BR>int=20
      a_drsize; // data relocation size=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>The magic number <TT>a_magic</TT> indicates what kind of executable =
file this=20
is. ( <I>Make this a footnote:</I> Historically, the magic number on the =

original PDP-11 was octal 407, which was a branch instruction that would =
jump=20
over the next seven words of the header to the beginning of the text =
segment.=20
That permitted a primitive form of position independent code. A =
bootstrap loader=20
could load the entire executable including the file header to be loaded =
by into=20
memory, usually at location zero, and then jump to the beginning of the =
loaded=20
file to start the program. Only a few standalone programs ever used this =

ability, but the 407 magic number is still with us 25 years later.) =
Different=20
magic numbers tell the operating system program loader to load the file =
in to=20
memory differently; we discuss these variations below. The text and data =
segment=20
sizes <TT>a_text</TT> and <TT>a_data</TT> are the sizes in bytes of the=20
read-only code and read-write data that follow the header. Since Unix=20
automatically initializes newly allocated memory to zero, any data with =
an=20
initial contents of zero or whose contents don't matter need not be =
present in=20
the a.out file. The uninitialized size <TT>a_bss</TT> says how much=20
uninitialized data (really zero-initialized) data logically follows the =
data in=20
the a.out file.=20
<P>
<P>The <TT>a_entry</TT> field gives the starting address of the program, =
while=20
<TT>a_syms</TT>, <TT>a_trsize</TT>, and <TT>a_drsize</TT> say how much =
symbol=20
table and relocation information follow the data segment in the file. =
Programs=20
that have been linked and are ready to run need no symbol nor relocation =
info,=20
so these fields are zero in runnable files unless the linker has =
included=20
symbols for the debugger.=20
<P>
<H3>Interactions with virtual memory</H3>The process involved when the =
operating=20
system loads and starts a simple two-segment file is straightforward, =
Figure 3:=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-03.html"><IMG=20
      height=3D149 =
src=3D"http://www.iecc.com/linker/thumb-linker03-03.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 3:</I> Loading an a.out into a process <BR>picture of =
file=20
      and segments with arrows pointing out data flows=20
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>
<UL>
  <LI>Read the a.out header to get the segment sizes.=20
  <LI>Check to see if there's already a sharable code segment for this =
file. If=20
  so, map that segment into the process' address space. If not, create =
one, map=20
  it into the address space, and read the text segment from the file =
into the=20
  new memory segment.=20
  <LI>Create a private data segment large enough for the combined data =
and BSS,=20
  map it into the process, and read the data segment from the file into =
the data=20
  segment. Zero out the BSS segment.=20
  <LI>Create and map in a stack segment (usually separate from the data =
segment,=20
  since the data heap and stack grow separately.) Place arguments from =
the=20
  command line or calling program on the stack.=20
  <LI>Set registers appropriately and jump to the starting address. =
</LI></UL>
<P>
<P>This scheme (known as NMAGIC, where the N means new, as of about =
1975) works=20
quite well, and PDP-11 and early VAX Unix systems used it for years for =
all=20
object files, and linkable files used it throughout the life of the =
a.out format=20
into the 1990s. When Unix systems gained virtual memory, several =
improvements to=20
this simple scheme sped up program loading and saved considerable real =
memory.=20
<P>
<P>On a paging system, the simple scheme above allocates fresh virtual =
memory=20
for each text segment and data segment. Since the a.out file is already =
stored=20
on the disk, the object file itself can be mapped into the process' =
address=20
space. This saves disk space, since new disk space for virtual memory =
need only=20
be allocated for pages that the program writes into, and can speed =
program=20
startup, since the virtual memory system need only load in from disk the =
pages=20
that the program's actually using, not the whole file.=20
<P>
<P>A few changes to the a.out format make this possible, Figure 4,. and =
create=20
what's known as ZMAGIC format. These changes align the segments in the =
object=20
file on page boundaries. On systems with 4K pages, the a.out header is =
expanded=20
to 4K, and the text segment's size is rounded up to the next 4K =
boundary.=20
There's no need to round up the size of the data segment, since the BSS =
segment=20
logically follows the data segment, and is zeroed by the program loader =
anyway.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-04.html"><IMG=20
      height=3D95 =
src=3D"http://www.iecc.com/linker/thumb-linker03-04.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 4:</I> Mapping an a.out into a process <BR>Picture of =
file=20
      and segments, with page frames mapping into segments=20
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>ZMAGIC files reduce unneeded paging, but at the cost of wasting a lot =
of disk=20
space. The a.out header is only 32 bytes long, yet an entire 4K of disk =
space is=20
allocated. The gap between the text and data also wastes 2K, half a 4K =
page, on=20
average. Both of these are fixed in the compact pagable format known as =
QMAGIC.=20
<P>
<P>Compact pagable files consider the a.out header to be part of the =
text=20
segment, since there's no particular reason that the code in the text =
segment=20
has to start at location zero. Indeed, program zero is a particularly =
bad place=20
to load a program since uninitialized pointer variables often contain =
zero. The=20
code actually starts immediately after the header, and the whole page is =
mapped=20
into the second page of the process, leaving the first page unmapped so =
that=20
pointer references to location zero will fail, Figure 5. This has the =
harmless=20
side-effect of mapping the header into the process as well.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-05.html"><IMG=20
      height=3D113 =
src=3D"http://www.iecc.com/linker/thumb-linker03-05.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 5:</I> Mapping a compact a.out into a process =
<BR>Picture of=20
      file and segments, with page frames mapping into segments=20
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>The text and data segments in a QMAGIC executable are each rounded up =
to a=20
full page, so the system can easily map file pages to address space =
pages. The=20
last page of the data segment is padded out with zeros for BSS data; if =
there is=20
more BSS data than fits in the padding area, the a.out header contains =
the size=20
of the remaining BSS area to allocate.=20
<P>
<P>Although BSD Unix loads programs at location zero (or 0x1000 for =
QMAGIC),=20
other versions of Unix load programs at other addresses. For example, =
System V=20
for the Motorola 68K series loads at 0x80000000, and for the 386 loads =
at=20
0x8048000. It doesn't matter where the load address is so long as it's =
page=20
aligned, and the linker and operating system can permanently agree what =
it is.=20
<P>
<H2>Relocation: MS-DOS EXE files</H2>The a.out format is quite adequate =
for=20
systems that assign a fresh address space to each process so that every =
program=20
can be loaded at the same logical address. Many systems are not so =
fortunate.=20
Some load all the programs into the same address space. Others give each =
program=20
its own address space, but don't always load the program at the same =
address.=20
(32 bit versions of Windows fall into this last category.)=20
<P>
<P>In these cases, executable files contain <I>relocation entries</I> =
often=20
called <I>fixups</I> that identify the places in the program where =
addresses=20
need to be modified when the program is loaded. One of the simplest =
formats with=20
fixups is the MS-DOS EXE format.=20
<P>
<P>As we saw with the .COM format above, DOS loads a program into a =
contiguous=20
chunk of available real-mode memory. If the program doesn't fit in one =
64K=20
segment, the program has to use explicit segment numbers to address =
program and=20
data, and at load time the segment numbers in the program have to be =
fixed up to=20
match the address where the program is actually loaded. The segment =
numbers in=20
the file are stored as though the program will be loaded at location =
zero, so=20
the fixup action is to add to every stored segment number the base =
paragraph=20
number at which the program is actually loaded. That is, if the program =
is=20
loaded at location 0x5000, which is paragraph 0x500, a reference to =
segment 12=20
is relocated to be a reference to segment 512. The offsets within the =
segments=20
don't change, since the program is relocated as a unit, so the loader =
needn't=20
adjust anything other than the segment numbers.=20
<P>
<P>Each .EXE File starts with a header shown in Figure 6. Following the =
header=20
is some extra information of variable length (used for overlay loaders,=20
self-extracting archives, and other application-specific hackery) and a =
list of=20
the fixup addresses in 32 bit segment:offset format. The fixup addresses =
are=20
relative to the base of the program, so the fixups themselves have to be =

relocated to find the addresses in the program to change. After the =
fixups comes=20
the program code. There may be more information, ignored by the program =
loader,=20
after the code. (In the example below, far pointers are 32 bits with a =
16 bit=20
segment number and 16 bit offset.)=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 6 --></TD>
    <TD><I>Figure 6:</I> Format of .EXE file header <BR>
      <P><TT><BR>char signature[2] =3D "MZ"; // magic number <BR>short =
lastsize;=20
      // # bytes used in last block <BR>short nblocks; // number of 512 =
byte=20
      blocks <BR>short nreloc; // number of relocation entries <BR>short =

      hdrsize; // size of file header in 16 byte paragraphs <BR>short =
minalloc;=20
      // minimum extra memory to allocate <BR>short maxalloc; // maximum =
extra=20
      memory to allocate <BR>void far *sp; // initial stack pointer =
<BR>short=20
      checksum; // ones complement of file sum <BR>void far *ip; // =
initial=20
      instruction pointer <BR>short relocpos; // location of relocation =
fixup=20
      table <BR>short noverlay; // Overlay number, 0 for program =
<BR>char=20
      extra[]; // extra material for overlays, etc. <BR>void far =
*relocs[]; //=20
      relocation entries, starts at relocpos=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>Loading an .EXE file is only slightly more complicated than loading a =
.COM=20
file.=20
<UL>
  <LI>Read in the header, check the magic number for validity.=20
  <LI>Find a suitable area of memory. The <TT>minalloc</TT> and=20
  <TT>maxalloc</TT> fields say the minimum and maximum number of extra=20
  paragraphs of memory to allocate beyond the end of the loaded program. =

  (Linkers invariably default the minimum to the size of the program's =
BSS-like=20
  uninitialized data, and the maximum to 0xFFFF.)=20
  <LI>Create a PSP, the control area at the head of the program.=20
  <LI>Read in the program code immediately after the PSP. The =
<TT>nblocks</TT>=20
  and <TT>lastsize</TT> fields define the length of the code.=20
  <LI>Start reading <TT>nreloc</TT> fixups at <TT>relocpos</TT>. For =
each fixup,=20
  add the base address of the program code to the segment number in the =
fixup,=20
  then use the relocated fixup as a pointer to a program address to =
which to add=20
  the base address of the program code.=20
  <LI>Set the stack pointer to <TT>sp</TT>, relocated, and jump to =
<TT>ip</TT>,=20
  relocated, to start the program. </LI></UL>
<P>
<P>Other than the peculiarities associated with segmented addressing, =
this is a=20
pretty typical setup for program loading. In a few cases, different =
pieces of=20
the program are relocated differently. In 286 protected mode, which EXE =
files do=20
not support, each segment of code or data in the executable file is =
loaded into=20
a separate segment in the system, but the segment numbers cannot for=20
architectural reasons be consecutive. Each protected mode executable has =
a table=20
near the beginning listing all of the segments that the program will =
require.=20
The system makes a table of actual segment numbers corresponding to each =
segment=20
in the executable. When processing fixups, the system looks up the =
logical=20
segment number in that table and replaces it with the actual segment =
number, a=20
process more akin to symbol binding than to relocation.=20
<P>
<P>Some systems permit symbol resolution at load time as well, but we =
save that=20
topic for Chapter 10.=20
<P>
<H2>Symbols and relocation</H2>The object formats we've considered so =
far are=20
all loadable, that is, they can be loaded into memory and run directly. =
Most=20
object files aren't loadable, but rather are intermediate files passed =
from a=20
compiler or assembler to a linker or library manager. These linkable =
files can=20
be considerably more complex than runnable ones. Runnable files have to =
be=20
simple enough to run on the ``bare metal'' of the computer, while =
linkable files=20
are processed by a layer of software which can do very sophisticated =
processing.=20
In principle, a linking loader could do all of functions of a linker as =
a=20
program was loaded, but for efficiency reasons the loader is generally =
as simple=20
as possible to speed program startup. (Dynamic linking, which we cover =
in=20
chapter 10, moves a lot of the function of the linker into the loader, =
with=20
attendant performance loss, but modern computers are fast enough that =
the gains=20
from dynamic linking outweigh the performance penalty.)=20
<P>
<P>We look at five formats of increasing complexity: relocatable a.out =
used on=20
BSD UNIX systems, ELF used on System V, IBM 360 objects, the extended =
COFF=20
linkable and PE executable formats used on 32 bit Windows, and the OMF =
linkable=20
format used on pre-COFF Windows systems.=20
<P>
<H2>Relocatable a.out</H2>Unix systems have always used a single object =
format=20
for both runnable and linkable files, with the runnable files leaving =
out the=20
sections of use only to the linker. The a.out format we saw in Figure 2 =
includes=20
several fields used by the linker. The sizes of the relocation tables =
for the=20
text and data segments are in <TT>a_trsize</TT> and <TT>a_drsize</TT>, =
and the=20
size of the symbol table is in <TT>a_syms</TT>. The three sections =
follow the=20
text and data, Figure 7.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-07.html"><IMG=20
      height=3D189 =
src=3D"http://www.iecc.com/linker/thumb-linker03-07.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 7:</I> Simplifed a.out <BR>a.out header text section =
data=20
      section text relocation data relocation symbol table string table=20
  </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<H3>Relocation entries</H3>Relocation entries serve two functions. When =
a=20
section of code is relocated to a different base address, relocation =
entries=20
mark the places in the code that have to be modified. In a linkable =
file, there=20
are also relocation entries that mark references to undefined symbols, =
so the=20
linker knows where to patch in the symbol's value when the symbol is =
finally=20
defined.=20
<P>
<P>Figure 8 shows the format of a relocation entry. Each entry contains =
the=20
address within the text or data section to be relocated, along with =
information=20
that defines what to do. The address is the offset from the beginning of =
the=20
text or data segment of a relocatable item. The length field says how =
long the=20
item is, values 0 through three mean 1, 2, 4, or (on some architectures) =
8=20
bytes. The pcrel flag means that this is a ``PC relative'' item, that =
is, it's=20
used in an instruction as a relative address.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-08.html"><IMG=20
      height=3D98 =
src=3D"http://www.iecc.com/linker/thumb-linker03-08.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 8:</I> Relocation entry format <BR>Draw this with =
boxes --=20
      four byte address -- three byte index, one bit pcrel flag, 2 bit =
length=20
      field, one bit extern flag, four spare bits =
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>The extern flag controls the interpretation of the index field to =
determine=20
which segment or symbol the relocation refers to. If the extern flag is =
off,=20
this is a plain relocation item, and the index tells which segment =
(text, data,=20
or BSS) the item is addressing. If the extern flag is on, this is a =
reference to=20
an external symbol, and the index is the symbol number in the file's =
symbol=20
table.=20
<P>
<P>This relocation format is adequate for most machine architectures, =
but some=20
of the more complex ones need extra flag bits to indicate, e.g., =
three-byte 370=20
address constants or high and low half constants on the SPARC.=20
<P>
<H3>Symbols and strings</H3>The final section of an a.out file is the =
symbol=20
table. Each entry is 12 bytes and describes a single symbol, Figure 9.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-09.html"><IMG=20
      height=3D61 =
src=3D"http://www.iecc.com/linker/thumb-linker03-09.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 9:</I> Symbol format <BR>Draw this with boxes, too: - =
four=20
      byte name offset - one byte type - one spare byte - two byte =
debugger info=20
      - four byte value </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>Unix compilers permit arbitrarily long identifiers, so the name =
strings are=20
all in a string table that follows the symbol table. The first item in a =
symbol=20
table entry is the offset in the string table of the null-terminated =
name of the=20
symbol. In the type byte, if the low bit is set the symbol is external =
(a=20
misnomer, it'd better be called global, visible to other modules). =
Non-external=20
symbols are not needed for linking but can be used by debuggers. The =
rest of the=20
bits are the symbol type. The most important types include:=20
<UL>
  <LI><I>text</I>, <I>data</I>, or <I>bss</I>: A symbol defined in this =
module.=20
  External bit may or may not be on. Value is the relocatable address in =
the=20
  module corresponding to the symbol.=20
  <LI><I>abs</I>: An absolute non-relocatable symbol. (Rare outside of =
debugger=20
  info.) External bit may or may not be on. Value is the absolute value =
of the=20
  symbol.=20
  <LI><I>undefined</I>: A symbol not defined in this module. External =
bit must=20
  be on. Value is usually zero, but see the ``common block hack'' below. =

</LI></UL>These symbol types are adequate for older languages such as C =
and=20
Fortran and, just barely, for C++.=20
<P>
<P>As a special case, a compiler can use an undefined symbol to request =
that the=20
linker reserve a block of storage by that symbol's name. If an undefined =

external symbol has a non-zero value, that value is a hint to the linker =
how=20
large a block of storage the program expects the symbol to address. At =
link=20
time, if there is no definition of the symbol, the linker creates a =
block of=20
storage by that name in the BSS segment with the size being the largest =
hint=20
value found in any of the linked modules. If the symbol is defined in =
any=20
module, the linker uses the definition and ignores the size hints. This =
``common=20
block hack'' supports typical (albeit non standard conformant) usage of =
Fortran=20
common blocks and uninitialized C external data.=20
<P>
<H3>a.out summary</H3>The a.out format is a simple and effective one for =

relatively simple systems with paging. It has fallen out of favor =
because it=20
doesn't easily support for dynamic linking. Also, a.out doesn't support =
C++,=20
which requires special treatment of initializer and finalizer code, very =
well.=20
<P>
<H2>Unix ELF</H2>The traditional a.out format served the Unix community =
for over=20
a decade, but with the advent of Unix System V, AT&amp;T decided that it =
needed=20
something better to support cross-compilation, dynamic linking and other =
modern=20
system features. Early versions of System V used COFF, Common Object =
File=20
Format, which was originally intended for cross-compiled embedded =
systems and=20
didn't work all that well for a time-sharing system, since it couldn't =
support=20
C++ or dynamic linking without extensions. In later versions of System =
V, COFF=20
was superseded by ELF, Executable and Linking Format. ELF has been =
adopted by=20
the popular freeware Linux and BSD variants of Unix as well. ELF has an=20
associated debugging format called DWARF which we visit in Chapter 5. In =
this=20
discussion we treat the 32 bit version of ELF. There are 64 bit variants =
that=20
extend sizes and addresses to 64 bits in a straightforward way.=20
<P>
<P>ELF files come in three slightly different flavors: relocatable, =
executable,=20
and shared object. Relocatable files are created by compilers and =
assemblers but=20
need to be processed by the linker before running. Executable files have =
all=20
relocation done and all symbols resolved except perhaps shared library =
symbols=20
to be resolved at runtime. Shared objects are shared libraries, =
containing both=20
symbol information for the linker and directly runnable code for =
runtime.=20
<P>
<P>ELF files have an unusual dual nature, Figure 10. Compilers, =
assemblers, and=20
linkers treat the file as a set of logical sections described by a =
section=20
header table, while the system loader treats the file as a set of =
segments=20
described by a program header table. A single segment will usually =
consist of=20
several sections. For example, a ``loadable read-only'' segment could =
contain=20
sections for executable code, read-only data, and symbols for the =
dynamic=20
linker. Relocatable files have section tables, executable files have =
program=20
header tables, and shared objects have both. The sections are intended =
for=20
further processing by a linker, while the segments are intended to be =
mapped=20
into memory.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-10.html"><IMG=20
      height=3D87 =
src=3D"http://www.iecc.com/linker/thumb-linker03-10.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 10:</I> Two views of an ELF file <BR>linking view and=20
      execution view, adapted from fig 1-1 in Intel TIS document=20
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>ELF files all start with the ELF header, Figure 11. The header is =
designed to=20
be decodable even on machines with a different byte order from the =
file's target=20
architecture. The first four bytes are the magic number identifying an =
ELF file,=20
followed by three bytes describing the format of the rest of the header. =
Once a=20
program has read the <TT>class</TT> and <TT>byteorder</TT> flags, it =
knows the=20
byte order and word size of the file and can do the necessary byte =
swapping and=20
size conversions. Other fields provide the size and location of the =
section=20
header and program header, if present,=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 11 --></TD>
    <TD><I>Figure 11:</I> ELF header <BR>
      <P><TT><BR>char magic[4] =3D "\177ELF"; // magic number <BR>char =
class; //=20
      address size, 1 =3D 32 bit, 2 =3D 64 bit <BR>char byteorder; // 1 =
=3D=20
      little-endian, 2 =3D big-endian <BR>char hversion; // header =
version, always=20
      1 <BR>char pad[9]; short filetype; // file type: 1 =3D =
relocatable, 2 =3D=20
      executable, <BR>// 3 =3D shared object, 4 =3D core image <BR>short =
archtype;=20
      // 2 =3D SPARC, 3 =3D x86, 4 =3D 68K, etc. <BR>int fversion; // =
file version,=20
      always 1 <BR>int entry; // entry point if executable <BR>int =
phdrpos; //=20
      file position of program header or 0 <BR>int shdrpos; // file =
position of=20
      section header or 0 <BR>int flags; // architecture specific flags, =
usually=20
      0 <BR>short hdrsize; // size of this ELF header <BR>short phdrent; =
// size=20
      of an entry in program header <BR>short phdrcnt; // number of =
entries in=20
      program header or 0 <BR>short shdrent; // size of an entry in =
section=20
      header <BR>short phdrcnt; // number of entries in section header =
or 0=20
      <BR>short strsec; // section number that contains section name =
strings=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<H3>Relocatable files</H3>A relocatable or shared object file is =
considered to=20
be a collection of sections, defined in section headers, Figure 12. Each =
section=20
contains a single type of information, such as program code, read-only =
or=20
read-write data, relocation entries, or symbols. Every symbol defined in =
the=20
module is defined relative to a section, so a procedure's entry point =
would be=20
relative to the program code section that contains that procedure's =
code. There=20
are also two pseudo-sections <TT>SHN_ABS</TT> (number 0xfff1) which =
logically=20
contains absolute non-relocatable symbols, and <TT>SHN_COMMON</TT> =
(number=20
0xfff2) that contains uninitialized data blocks, the descendant of the =
a.out=20
common block hack. Section zero is always a null section, with an =
all-zero=20
section table entry.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 12 --></TD>
    <TD><I>Figure 12:</I> Section header <BR>
      <P><TT><BR>int sh_name; // name, index into the string table =
<BR>int=20
      sh_type; // section type <BR>int sh_flags; // flag bits, below =
<BR>int=20
      sh_addr; // base memory address, if loadable, or zero <BR>int =
sh_offset;=20
      // file position of beginning of section <BR>int sh_size; // size =
in bytes=20
      <BR>int sh_link; // section number with related info or zero =
<BR>int=20
      sh_info; // more section-specific info <BR>int sh_align; // =
alignment=20
      granularity if section is moved <BR>int sh_entsize; // size of =
entries if=20
      section is an array=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>Section types include:=20
<UL>
  <LI><TT>PROGBITS</TT>: Program contents including code, data, and =
debugger=20
  info.=20
  <LI><TT>NOBITS</TT>: Like <TT>PROGBITS</TT> but no space is allocated =
in the=20
  file itself. Used for BSS data allocated at program load time.=20
  <LI><TT>SYMTAB</TT> and <TT>DYNSYM</TT>: Symbol tables, described in =
more=20
  detail later. The <TT>SYMTAB</TT> table contains all symbols and is =
intended=20
  for the regular linker, while <TT>DYNSYM</TT> is just the symbols for =
dynamic=20
  linking. (The latter table has to be loaded into memory at runtime, so =
it's=20
  kept as small as possible.)=20
  <LI><TT>STRTAB</TT>: A string table, analogous to the one in a.out =
files.=20
  Unlike a.out files, ELF files can and often do contain separate string =
tables=20
  for separate purposes, e.g. section names, regular symbol names, and =
dynamic=20
  linker symbol names.=20
  <LI><TT>REL</TT> and <TT>RELA</TT>: Relocation information. =
<TT>REL</TT>=20
  entries add the relocation value to the base value stored in the code =
or data,=20
  while <TT>RELA</TT> entries include the base value for relocation in =
the=20
  relocation entries themselves. (For historical reasons, x86 objects =
use=20
  <TT>REL</TT> relocation and 68K objects use <TT>RELA</TT>.) There are =
a bunch=20
  of relocation types for each architecture, similar to (and derived =
from) the=20
  a.out relocation types.=20
  <LI><TT>DYNAMIC</TT> and <TT>HASH</TT>: Dynamic linking information =
and the=20
  runtime symbol hash table. </LI></UL>There are three flag bits used:=20
<TT>ALLOC</TT>, which means that the section occupies memory when the =
program is=20
loaded, <TT>WRITE</TT> which means that the section when loaded is =
writable, and=20
<TT>EXECINSTR</TT> which means that the section contains executable =
machine=20
code.=20
<P>
<P>A typical relocatable executable has about a dozen sections. Many of =
the=20
section names are meaningful to the linker, which looks for the section =
types it=20
knows about for specific processing, while either discarding or passing =
through=20
unmodified sections (depending on flag bits) that it doesn't know about. =

<P>
<P>Sections include:=20
<UL>
  <LI><TT>.text</TT> which is type PROGBITS with attributes =
ALLOC+EXECINSTR.=20
  It's the equivalent of the a.out text segment.=20
  <LI><TT>.data</TT> which is type PROGBITS with attributes ALLOC+WRITE. =
It's=20
  the equivalent of the a.out data segment.=20
  <LI><TT>.rodata</TT> which is type <TT>PROGBITS</TT> with attribute =
ALLOC.=20
  It's read-only data, hence no WRITE.=20
  <LI><TT>.bss</TT> which is type NOBITS with attributes ALLOC+WRITE. =
The BSS=20
  section takes no space in the file, hence NOBITS, but is allocated at =
runtime,=20
  hence ALLOC.=20
  <LI><TT>.rel.text</TT>, <TT>.rel.data</TT>, and <TT>.rel.rodata</TT>, =
each=20
  which is type REL or RELA. The relocation information for the =
corresponding=20
  text or data section.=20
  <LI><TT>.init</TT> and <TT>.fini</TT>, each type PROGBITS with =
attributes=20
  ALLOC+EXECINSTR. These are similar to <TT>.text</TT>, but are code to =
be=20
  executed when the program starts up or terminates, respectively. C and =
Fortran=20
  don't need these, but they're essential for C++ which has global data =
with=20
  executable initializers and finalizers.=20
  <LI><TT>.symtab</TT>, and <TT>.dynsym</TT> types SYMTAB and DYNSYM=20
  respectively, regular and dynamic linker symbol tables. The dynamic =
linker=20
  symbol table is ALLOC set, since it's loaded at runtime.=20
  <LI><TT>.strtab</TT>, and <TT>.dynstr</TT> both type STRTAB, a table =
of name=20
  strings, for a symbol table or the section names for the section =
table. The=20
  <TT>dynstr</TT> section, the strings for the dynamic linker symbol =
table, has=20
  ALLOC set since it's loaded at runtime. </LI></UL>There are also some=20
specialized sections like <TT>.got</TT> and <TT>.plt</TT>, the Global =
Offset=20
Table and Procedure Linkage Table used for dynamic linking (covered in =
Chapter=20
10), <TT>.debug</TT> which contains symbols for the debugger, =
<TT>.line</TT>=20
which contains mappings from source line numbers to object code =
locations again=20
for the debugger, and <TT>.comment</TT> which contains documentation =
strings,=20
usually version control version numbers.=20
<P>
<P>An unusual section type is <TT>.interp</TT> which contains the name =
of a=20
program to use as an interpreter. If this section is present, rather =
than=20
running the program directly, the system runs the interpreter and passes =
it the=20
ELF file as an argument. Unix has for many years had self-running =
interpreted=20
text files, using=20
<P><TT><BR>#! /path/to/interpreter=20
<P></TT>
<P>as the first line of the file. ELF extends this facility to =
interpreters=20
which run non-text programs. In practice this is used to call the =
run-time=20
dynamic linker to load the program and link in any required shared =
libraries.=20
<P>
<P>The ELF symbol table is similar to the a.out symbol table. It =
consists of an=20
array of entries, Figure 13.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 13 --></TD>
    <TD><I>Figure 13:</I> ELF symbol table <BR>
      <P><TT><BR>int name; // position of name string in string table =
<BR>int=20
      value; // symbol value, section relative in reloc, <BR>// absolute =
in=20
      executable <BR>int size; // object or function size <BR>char =
type:4; //=20
      data object, function, section, or special case file <BR>char =
bind:4; //=20
      local, global, or weak <BR>char other; // spare <BR>short sect; // =
section=20
      number, ABS, COMMON or UNDEF =
</TT></P></TD></TR></TBODY></TABLE></CENTER>
<P><BR>The a.out symbol entry is fleshed out with a few more fields. =
<BR>The=20
size field tells how large a data object is (particularly for =
<BR>undefined BSS,=20
the common block hack again.) <BR>A symbol's binding can be local, just =
visible=20
in this module, global, <BR>visible everywhere, or weak. <BR>A weak =
symbol is a=20
half-hearted global symbol: if a definition is <BR>available for an =
undefined=20
weak symbol, the linker will use it, but if <BR>not the value defaults =
to zero.=20
<P>
<P>The symbol's type is normally data or function. There is a section =
symbol=20
defined for each section, usually with the same name as the section =
itself, for=20
the benefit of relocation entries. (ELF relocation entries are all =
relative to=20
symbols, so a section symbol is necessary to indicate that an item is =
relocated=20
relative to one of the sections in the file.) A file entry is a =
pseudo-symbol=20
containing the name of the source file.=20
<P>
<P>The section number is the section relative to which the symbol is =
defined,=20
e.g., function entry points are defined relative to <TT>.text</TT>. =
Three=20
special pseudo-sections also appear, UNDEF for undefined symbols, ABS =
for=20
non-relocatable absolute symbols, and COMMON for common blocks not yet=20
allocated. (The value of a COMMON symbol gives the required alignment=20
granularity, and the size gives the minimum size. Once allocated by the =
linker,=20
COMMON symbols move into the <TT>.bss</TT> section.)=20
<P>
<P>A typical complete ELF file, Figure 14, contains quite a few sections =
for=20
code, data, relocation information, linker symbols, and debugger =
symbols. If the=20
file is a C++ program, it will probably also contain <TT>.init</TT>,=20
<TT>.fini</TT>, <TT>.rel.init</TT>, and <TT>.rel.fini</TT> sections as =
well.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-14.html"><IMG=20
      height=3D140 =
src=3D"http://www.iecc.com/linker/thumb-linker03-14.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 14:</I> Sample relocatable ELF file <BR>ELF header =
<BR>.text=20
      <BR>.data <BR>.rodata <BR>.bss <BR>.sym <BR>.rel.text =
<BR>.rel.data=20
      <BR>.rel.rodata <BR>.line <BR>.debug <BR>.strtab <BR>(section =
table, not=20
      considered to be a section) </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<H3>ELF executable files</H3>An ELF executable file has the same general =
format=20
as a relocatable ELF, but the data are arranged so that the file can be =
mapped=20
into memory and run. The file contains a program header that follows the =
ELF=20
header in the file. The program header defines the segments to be =
mapped. The=20
program header, Figure 15, is an array of segment descriptions.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 15 --></TD>
    <TD><I>Figure 15:</I> ELF program header <BR>
      <P><TT><BR>int type; // loadable code or data, dynamic linking =
info, etc.=20
      <BR>int offset; // file offset of segment <BR>int virtaddr; // =
virtual=20
      address to map segment <BR>int physaddr; // physical address, not =
used=20
      <BR>int filesize; // size of segment in file <BR>int memsize; // =
size of=20
      segment in memory (bigger if contains BSS) <BR>int flags; // Read, =
Write,=20
      Execute bits <BR>int align; // required alignment, invariably =
hardware=20
      page size=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>An executable usually has only a handful of segments, a read-only one =
for the=20
code and read-only data, and a read-write one for read/write data. All =
of the=20
loadable sections are packed into the appropriate segments so the system =
can map=20
the file with one or two operations.=20
<P>
<P>ELF files extend the ``header in the address space'' trick used in =
QMAGIC=20
a.out files to make the executable files as compact as possible at the =
cost of=20
some slop in the address space. A segment can start and end at arbitrary =
file=20
offsets, but the virtual starting address for the segment must have the =
same low=20
bits modulo the alignment as the starting offset in the file, i.e, must =
start in=20
the same offset on a page. The system maps in the entire range from the =
page=20
where the segment starts to the page where the segment ends, even if the =
segment=20
logically only occupies part of the first and last pages mapped. Figure =
16 shows=20
a typical segment arrangement.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 16 --></TD>
    <TD><I>Figure 16:</I> ELF loadable segments <BR>|l|n|n|l|. _ File =
offset=20
      Load address Type _ ELF header 0 0x8000000 _ Program header 0x40 =
0x8000040=20
      _ Read only text 0x100 0x8000100 LOAD, Read/Execute (size 0x4500) =
_=20
      Read/write data 0x4600 0x8005600 LOAD, Read/Write/Execute (file =
size=20
      0x2200, memory size 0x3500) _ non-loadable info and optional =
section=20
      headers </TD></TR></TBODY></TABLE></CENTER>
<P>The mapped text segment consists of the ELF header, program header, =
and=20
read-only text, since the ELF and program headers are in the same page =
as the=20
beginning of the text. The read/write but the data segment in the file =
starts=20
immediately after the text segment. The page from the file is mapped =
both=20
read-only as the last page of the text segment in memory and =
copy-on-write as=20
the first page of the data segment. In this example, if a computer has =
4K pages,=20
and in an executable file the text ends at 0x80045ff, then the data =
starts at=20
0x8005600. The file page is mapped into the last page of the text =
segment at=20
location 0x8004000 where the first 0x600 bytes contain the text from=20
0x8004000-0x80045ff, and into the data segment at 0x8005000 where the =
rest of=20
the page contain the initial contents of data from 0x8005600-0x80056ff.=20
<P>
<P>The BSS section again is logically continuous with the end of the =
read write=20
sections in the data segment, in this case 0x1300 bytes, the difference =
between=20
the file size and the memory size. The last page of the data segment is =
mapped=20
in from the file, but as soon as the operating system starts to zero the =
BSS=20
segment, the copy-on-write system makes a private copy of the page.=20
<P>
<P>If the file contains <TT>.init</TT> or <TT>.fini</TT> sections, those =

sections are part of the read only text segment, and the linker inserts =
code at=20
the entry point to call the <TT>.init</TT> section code before it calls =
the main=20
program, and the <TT>.fini</TT> section code after the main program =
returns.=20
<P>
<P>An ELF shared object contains all the baggage of a relocatable and an =

executable file. It has the program header table at the beginning, =
followed by=20
the sections in the loadable segments, including dynamic linking =
information.=20
Following sections comprising the loadable segments are the relocatable =
symbol=20
table and other information that the linker needs while creating =
executable=20
programs that refer to the shared object, with the section table at the =
end.=20
<P>
<H3>ELF summary</H3>ELF is a moderately complex format, but it serves =
its=20
purposes well. It's a flexible enough relocatable format to support C++, =
while=20
being an efficient executable format for a virtual memory system with =
dynamic=20
linking, and makes it easy to map executable pages directly into the =
program=20
address space. It also permits cross-compilation and cross-linking from =
one=20
platform to another, with enough information in each ELF file to =
identify the=20
target architecture and byte order.=20
<P>
<H2>IBM 360 object format</H2>The IBM 360 object format was designed in =
the=20
early 1960s, but remains in use today. It was originally designed for 80 =
column=20
punch cards, but has been adapted for disk files on modern systems. Each =
object=20
file contains a set of control sections (csects), which are optionally =
named=20
separately relocatable chunks of code and/or data. Typically each source =
routine=20
is compiled into one csect, or perhaps one csect for code and another =
for data.=20
A csect's name, if it has one, can be used as a symbol that addresses =
the=20
beginning of the csect; other types of symbols include those defined =
within a=20
csect, undefined external symbols, common blocks, and a few others. Each =
symbol=20
defined or used in an object file is assigned a small integer External =
Symbol ID=20
(ESID). An object file is a sequence of 80 byte records in a common =
format,=20
Figure 17. The first byte of each record is 0x02, a value that marks the =
record=20
as part of an object file. (A record that starts with a blank is treated =
as a=20
command by the linker.) Bytes 2-4 are the record type, TXT for program =
code or=20
"text", ESD for an external symbol directory that defines symbols and =
ESIDs, RLD=20
for Relocation Directory, and END for the last record that also defines =
the=20
starting point. The rest of the record up through byte 72 is specific to =
the=20
record type. Bytes 73-80 are ignored. On actual punch cards they were =
usually a=20
sequence number.=20
<P>
<P>An object file starts with some ESD records that define the csects =
and all=20
symbols, then the TXT records, the RLD records and the END. There's =
quite a lot=20
of flexibility in the order of the records. Several TXT records can =
redefine the=20
contents of a single location, with the last one in the file winning. =
This made=20
it possible (and not uncommon) to punch a few ``patch'' cards to stick =
at the=20
end of an object deck, rather than reassembling or recompiling.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 17 --></TD>
    <TD><I>Figure 17:</I> IBM object record format <BR>
      <P><TT><BR>char flag =3D 0x2; <BR>char rtype[3]; // three letter =
record type=20
      <BR>char data[68]; // format specific data <BR>char seq[8]; // =
ignored,=20
      usually sequence numbers =
</TT></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<H3>ESD records</H3>Each object file starts with ESD records, Figure 18, =
that=20
define the csects and symbols used in the file and give them all ESIDs.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 18 --></TD>
    <TD><I>Figure 18:</I> ESD format <BR>
      <P><TT><BR>char flag =3D 0x2; // 1 <BR>char rtype[3] =3D "ESD"; // =
2-4 three=20
      letter type <BR>char pad1[6]; <BR>short nbytes; // 11-12 number of =
bytes=20
      of info: 16, 32, or 48 <BR>char pad2[2]; <BR>short esid; // 15-16 =
ESID of=20
      first symbol { // 17-72, up to 3 symbols <BR>char name[8]; // =
blank padded=20
      symbol name <BR>char type; // symbol type <BR>char base[3]; // =
csect=20
      origin or label offset <BR>char bits; // attribute bits <BR>char =
len[3];=20
      // length of object or csect ESID <BR>}=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>Each ESD records defines up to three symbols with sequential ESIDs. =
Symbols=20
are up to eight EBCDIC characters. The symbol types are:=20
<UL>
  <LI>SD and PC: Section Definition or Private Code, defines a csect. =
The csect=20
  origin is the logical address of the beginning of the csect, usually =
zero, and=20
  the length is the length of the csect. The attribute byte contains =
flags=20
  saying whether the csect uses 24 or 31 bit program addressing, and =
whether it=20
  needs to be loaded into a 24 or 31 bit address space. PC is a csect =
with a=20
  blank name; names of csects must be unique within a program but there =
can be=20
  multiple unnamed PC sections.=20
  <LI>LD: label definition. The base is the label's offset within its =
csect, the=20
  len field is the ESID of the csect. No attribute bits.=20
  <LI>CM: common. Len is the length of the common block, other fields =
are=20
  ignored.=20
  <LI>ER and WX: external reference and weak external. Symbols defined=20
  elsewhere. The linker reports an error if an ER symbol isn't defined =
elsewhere=20
  in the program, but an undefined WX is not an error.=20
  <LI>PR: pseudoregister, a small area of storage defined at link time =
but=20
  allocated at runtime. Attribute bits give the required alignment, 1 to =
8=20
  bytes, and len is the size of the area. </LI></UL>
<P>
<H3>TXT records</H3>Next come text records, Figure 19, that contain the =
program=20
code and data. Each text record defines up to 56 contiguous bytes within =
a=20
single csect.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 19 --></TD>
    <TD><I>Figure 19:</I> TXT format <BR>
      <P><TT><BR>char flag =3D 0x2; // 1 <BR>char rtype[3] =3D "TXT"; // =
2-4 three=20
      letter type <BR>char pad; <BR>char loc[3]; // 6-8 csect relative =
origin of=20
      the text <BR>char pad[2]; <BR>short nbytes; // 11-12 number of =
bytes of=20
      info <BR>char pad[2]; <BR>short esid; // 15-16 ESID of this csect =
<BR>char=20
      text[56]; // 17-72 data=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<H3>RLD records</H3>After the text come RLD records, Figure 20, each of =
which=20
contains a sequence of relocation entries.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 20 --></TD>
    <TD><I>Figure 20:</I> RLD format <BR>
      <P><TT><BR>char flag =3D 0x2; // 1 <BR>char rtype[3] =3D "TXT"; // =
2-4 three=20
      letter type <BR>char pad[6]; <BR>short nbytes; // 11-12 number of =
bytes of=20
      info <BR>char pad[7]; { // 17-72 four or eight-byte relocation =
entries=20
      <BR>short t_esid; // target, ESID of referenced csect or symbol =
<BR>// or=20
      zero for CXD (total size of PR defs) <BR>short p_esid; // pointer, =
ESID of=20
      csect with reference <BR>char flags; // type and size of ref, =
<BR>char=20
      addr[3]; // csect-relative ref address <BR>}=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>Each entry has the ESIDs of the target and the pointer, a flag byte, =
and the=20
csect-relative address of the pointer. The flag byte has bits giving the =
type of=20
reference (code, data, PR, or CXD), the length (1, 2, 3, or 4 bytes), a =
sign bit=20
saying whether to add or subtract the relocation, and a "same" bit. If =
the=20
"same" bit is set, the next entry omits the two ESIDs and uses the same =
ESIDs as=20
this entry.=20
<P>
<H3>END records</H3>The end record, Figure 21, gives the starting =
address for=20
the program, either an address within a csect or the ESID of an external =
symbol.=20

<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 21 --></TD>
    <TD><I>Figure 21:</I> END format <BR>
      <P><TT><BR>char flag =3D 0x2; // 1 <BR>char rtype[3] =3D "END"; // =
2-4 three=20
      letter type <BR>char pad; <BR>char loc[3]; // 6-8 csect relative =
start=20
      address or zero <BR>char pad[6]; <BR>short esid; // 15-16 ESID of =
csect or=20
      symbol=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>
<H3>Summary</H3>Although the 80 column records are quite dated, the IBM =
object=20
format is still surprisingly simple and flexible. Extremely small =
linkers and=20
loaders can handle this format; on one model of 360, I used an absolute =
loader=20
that fit on a single 80 column punch card and could load a program, =
interpreting=20
TXT and END records, and ignoring the rest.=20
<P>
<P>Disk based systems either store object files as card images, or use a =
variant=20
version of the format with the same record types but much longer records =
without=20
sequence numbers. The linkers for DOS (IBM's lightweight operating =
system for=20
the 360) produce a simplified output format with in effect one csect and =
a=20
stripped down RLD without ESIDs.=20
<P>
<P>Within object files, the individual named csects permit a programmer =
or=20
linker to arrange the modules in a program as desired, putting all the =
code=20
csects together, for example. The main places this format shows its age =
is in=20
the eight-character maximum symbol length, and no type information about =

individual csects.=20
<P>
<H2>Microsoft Portable Executable format</H2>Microsoft's Windows NT has=20
extremely mixed heritage including earlier versions of MS-DOS and =
Windows,=20
Digital's VAX VMS (on which many of the programmers had worked), and =
Unix System=20
V (on which many of the rest of the programmers had worked.) NT's format =
is=20
adapted from COFF, a file format that Unix versions used after a.out but =
before=20
ELF. We'll take a look at PE and, where it differs from PE, Microsoft's =
version=20
of COFF.=20
<P>
<P>Windows developed in an underpowered environment with slow =
processors,=20
limited RAM, and originally without hardware paging, so there was always =
an=20
emphasis on shared libraries to save memory, and ad-hoc tricks to =
improve=20
performance, some of which are apparent in the PE/COFF design. Most =
Windows=20
executables contain <I>resources</I>, a general term that refers to =
objects such=20
as cursors, icons, bitmaps, menus, and fonts that are shared between the =
program=20
and the GUI. A PE file can contain a resource directory for all of the =
resources=20
the program code in that file uses.=20
<P>
<P>PE executable files are intended for a paged environment, so pages =
from a PE=20
file are usually be mapped directly into memory and run, much like an =
ELF=20
executable. PE's can be either EXE programs or DLL shared libraries =
(known as=20
dynamic link libraries). The format of the two is the same, with a =
status bit=20
identifying a PE as one or the other. Each can contain a list of =
exported=20
functions and data that can be used by other PE files loaded into the =
same=20
address space, and a list of imported functions and data that need to be =

resolved from other PE's at load time. Each file contains a set of =
chunks=20
analogous to ELF segments that have variously been called sections, =
segments,=20
and objects. We call them sections here, the term that Microsoft now =
uses.=20
<P>
<P>A PE file, Figure 22, starts with a small DOS .EXE file that prints =
out=20
something like "This program needs Microsoft Windows." (Microsoft's =
dedication=20
to certain kinds of backward compatibility is impressive.) A previously =
unused=20
field at the end of the EXE header points to the PE signature, which is =
followed=20
by the file header which consists of a COFF section and the ``optional'' =
header,=20
which despite its name appears in all PE files, and a list of section =
headers.=20
The section headers describe the various sections of the file. A COFF =
object=20
file starts with the COFF header, and omits the optional header.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-22.html"><IMG=20
      height=3D84 =
src=3D"http://www.iecc.com/linker/thumb-linker03-22.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 22:</I> Microsoft PE and COFF file <BR>DOS header (PE =
only)=20
      <BR>DOS program stub (PE only) <BR>PE signature (PE only) <BR>COFF =
header=20
      <BR>Optional header (PE only) <BR>Section table <BR>Mappable =
sections=20
      (pointed to from section table) <BR>COFF line numbers, symbols, =
debug info=20
      (optional in PE File) </TD></TR></TBODY></TABLE></CENTER>
<P>Figure 23 shows the PE, COFF, and "optional" headers. The COFF header =

describes the contents of the file, with the most important values being =
the=20
number of entries in the section table, The "optional" header contains =
pointers=20
to the most commonly used file sections. Addresses are all kept as =
offsets from=20
the place in memory that the program is loaded, also called Relative =
Virtual=20
Addresses or RVAs.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 23 --></TD>
    <TD><I>Figure 23:</I> PE and COFF header <BR>PE signature=20
      <P><TT><BR>char signature[4] =3D "PE\0\0"; // magic number, also =
shows byte=20
      order=20
      <P></TT>
      <P>COFF header=20
      <P><TT><BR>unsigned short Machine; // required CPU, 0x14C for =
80386, etc.=20
      <BR>unsigned short NumberOfSections; // creation time or zero =
<BR>unsigned=20
      long TimeDateStamp; // creation time or zero <BR>unsigned long=20
      PointerToSymbolTable; // file offset of symbol table in COFF or =
zero=20
      <BR>unsigned long NumberOfSymbols; // # entries in COFF symbol =
table or=20
      zero <BR>unsigned short SizeOfOptionalHeader; // size of the =
following=20
      optional header <BR>unsigned short Characteristics; // 02 =3D =
executable,=20
      0x200 =3D nonrelocatable, <BR>// 0x2000 =3D DLL rather than EXE=20
      <P></TT>
      <P>Optional header that follows PE header, not present in COFF =
objects=20
      <P><TT><BR>// COFF fields <BR>unsigned short Magic; // octal 413, =
from=20
      a.out ZMAGIC <BR>unsigned char MajorLinkerVersion; <BR>unsigned =
char=20
      MinorLinkerVersion; <BR>unsigned long SizeOfCode; // .text size=20
      <BR>unsigned long SizeOfInitializedData; // .data size =
<BR>unsigned long=20
      SizeOfUninitializedData; // .bss size <BR>unsigned long=20
      AddressOfEntryPoint; // RVA of entry point <BR>unsigned long =
BaseOfCode;=20
      // RVA of .text <BR>unsigned long BaseOfData; // RVA of .data //=20
      additional fields. unsigned long ImageBase; // virtual address to =
map=20
      beginning of file <BR>unsigned long SectionAlignment; // section=20
      alignment, typically 4096, or 64K <BR>unsigned long FileAlignment; =
// file=20
      page alignment, typically 512 <BR>unsigned short=20
      MajorOperatingSystemVersion; <BR>unsigned short=20
      MinorOperatingSystemVersion; <BR>unsigned short MajorImageVersion; =

      <BR>unsigned short MinorImageVersion; <BR>unsigned short=20
      MajorSubsystemVersion; <BR>unsigned short MinorSubsystemVersion;=20
      <BR>unsigned long Reserved1; <BR>unsigned long SizeOfImage; // =
total size=20
      of mappable image, rounded to SectionAlignment <BR>unsigned long=20
      SizeOfHeaders; // total size of headers up through section table=20
      <BR>unsigned long CheckSum; // often zero <BR>unsigned short =
Subsystem;//=20
      required subsystem: 1 =3D native, 2 =3D Windows GUI, <BR>// 3 =3D =
Windows=20
      non-GUI, 5 =3D OS/2, 7 =3D POSIX <BR>unsigned short =
DllCharacteristics; //=20
      when to call initialization routine (obsolescent) <BR>// 1 =3D =
process=20
      start, 2 =3D process end, 4 =3D thread start, 8 =3D thread end =
<BR>unsigned long=20
      SizeOfStackReserve; // size to reserve for stack <BR>unsigned long =

      SizeOfStackCommit; // size to allocate initially for stack =
<BR>unsigned=20
      long SizeOfHeapReserve; // size to reserve for heap <BR>unsigned =
long=20
      SizeOfHeapCommit; // size to allocate initially for heap =
<BR>unsigned long=20
      LoaderFlags; // obsolete <BR>unsigned long NumberOfRvaAndSizes; // =
number=20
      of entries in following image data directory <BR>// following pair =
is=20
      repeated once for each directory <BR>{ <BR>unsigned long =
VirtualAddress;=20
      // relative virtual address of directory <BR>unsigned long Size; =
<BR>}=20
      <P></TT>
      <P>Directories are, in order: <BR>Export Directory <BR>Import =
Directory=20
      <BR>Resource Directory <BR>Exception Directory <BR>Security =
Directory=20
      <BR>Base Relocation Table <BR>Debug Directory <BR>Image =
Description String=20
      <BR>Machine specific data <BR>Thread Local Storage Directory =
<BR>Load=20
      Configuration Directory </P></TD></TR></TBODY></TABLE></CENTER>
<P>Each PE file is created in a way that makes it straightforward for =
the system=20
loader to map it into memory. Each section is physically aligned on a =
disk block=20
boundary or greater (the filealign value), and logically aligned on a =
memory=20
page boundary (4096 on the x86.) The linker creates a PE file for a =
specific=20
target address at which the file will be mapped (imagebase). If a chunk =
of=20
address space at that address is available, as it almost always is, no =
load-time=20
fixups are needed. In a few cases such as the old win32s compatbility =
system=20
target addresses aren't available so the loader has to map the file =
somewhere=20
else, in which case the file must contain relocation fixups in the =
.reloc=20
section that tell the loader what to change. Shared DLL libraries also =
are=20
subject to relocation, since the address at which a DLL is mapped =
depends on=20
what's already occupying the address space.=20
<P>
<P>Following the PE header is the section table, an array of entries =
like Figure=20
24.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 24 --></TD>
    <TD><I>Figure 24:</I> Section table <BR>
      <P><TT><BR>// array of entries <BR>unsigned char Name[8]; // =
section name=20
      in ASCII <BR>unsigned long VirtualSize; // size mapped into memory =

      <BR>unsigned long VirtualAddress; // memory address relative to =
image base=20
      <BR>unsigned long SizeOfRawData; // physical size, mumtiple of =
file=20
      alignment <BR>unsigned long PointerToRawData; // file offset =
<BR>// next=20
      four entries present in COFF, present or 0 in PE <BR>unsigned long =

      PointerToRelocations; // offset of relocation entries <BR>unsigned =
long=20
      PointerToLinenumbers; // offset of line number entries =
<BR>unsigned short=20
      NumberOfRelocations; // number of relocation entries <BR>unsigned =
short=20
      NumberOfLinenumbers; // number of line number entries <BR>unsigned =
long=20
      Characteristics; // 0x20 =3D text, 0x40 =3D data, 0x80 =3D bss, =
0x200 =3D no-load,=20
      <BR>// 0x800 =3D don't link, 0x10000000 =3D shared, <BR>// =
0x20000000 =3D=20
      execute, 0x40000000 =3D read, 0x80000000 =3D write=20
      <P></TT>
      <P></P></TD></TR></TBODY></TABLE></CENTER>
<P>Each section has both a file address and size (PointerToRawData and=20
SizeOfRawData) and a memory address and size (VirtualAddress and =
VirtualSize)=20
which aren't necessarily the same. The CPU's page size is often larger =
than the=20
disk's block size, typically 4K pages and 512 byte disk blocks, and a =
section=20
that ends in the middle of a page need not have blocks for the rest of =
the page=20
allocated, saving small amounts of disk space. Each section is marked =
with the=20
hardware permissions appropriate for the pages, e.g. read+execute for =
code and=20
read+write for data.=20
<P>
<H3>PE special sections</H3>A PE file includes .text, .data, and =
sometimes .bss=20
sections like a Unix executable (usually under those names, in fact) as =
well as=20
a lot of Windows-specific sections.=20
<UL>
  <LI><I>Exports</I>: A list of the symbols defined in this module and =
visible=20
  to other modules. EXE files typically export no symbols, or maybe one =
or two=20
  for debugging. DLLs export symbols for the routines and data that they =

  provide. In keeping with Windows space saving tradition, exported =
symbols can=20
  be references via small integers called export ordinals as well as by =
names.=20
  The exports section contains an array of the RVAs of the exported =
symbols. It=20
  also contains two parallel arrays of the name of the symbol (as the =
RVA of an=20
  ASCII string), and the export ordinal for the symbol, sorted by string =
name.=20
  To look up a symbol by name, perform a binary search in the string =
name table,=20
  then find the entry in the ordinal table in the position corresponding =
to the=20
  found name, and use that ordinal to index the array of RVAs. (This is =
arguably=20
  faster than iterating over an array of three-word entries.) Exports =
can also=20
  be ``forwarders'' in which case the RVA points to a string naming the =
actual=20
  symbol which is found in another library.=20
  <LI><I>Imports</I>: The imports table lists all of the symbols that =
need to be=20
  resolved at load time from DLLs. The linker predetermines which =
symbols will=20
  be found in which DLLs, so the imports table starts with an import =
directory,=20
  consisting of one entry per referenced DLL. Each directory entry =
contains the=20
  name of the DLL, and parallel arrays one identifying the required =
symbols, and=20
  the other being the place in the image to store the symbol value. The =
entries=20
  in the first value can be either an ordinal (if the high bit is set), =
or a=20
  pointer to a name string preceded by a guess at the ordinal to speed =
up the=20
  search. The second array contains the place to store the symbol's =
value; if=20
  the symbol is a procedure, the linker will already have adjusted all =
calls to=20
  the symbol to call indirectly via that location, if the symbol is =
data,=20
  references in the importing module are made using that location as a =
pointer=20
  to the actual data. (Some compilers provide the indirection =
automatically,=20
  others require explicit program code.)=20
  <LI><I>Resources</I>: The resource table is organized as a tree. The =
structure=20
  supports arbitrarily deep trees, but in practice the tree is three =
levels,=20
  resource type, name, and language. (Language here means a natural =
language,=20
  this permits customizing executables for speakers of languages other =
than=20
  English.) Each resource can have either a name or and numbers. A =
typical=20
  resource might be type DIALOG (Dialog box), name ABOUT (the About This =
Program=20
  box), language English. Unlike symbols which have ASCII names, =
resources have=20
  Unicode names to support non-English languages. The actual resources =
are=20
  chunks of binary data, with the format of the resource depending on =
the=20
  resource type.=20
  <LI><I>Thread Local Storage</I>: Windows supports multiple threads of=20
  execution per process. Each thread can have its own private storage, =
Thread=20
  Local Storage or TLS. This section points to a chunk of the image used =
to=20
  initialize TLS when a thread starts, and also contains pointers to=20
  initialization routines to call when each thread starts. Generally =
present in=20
  EXE but not DLL files, because Windows doesn't allocate TLS storage =
when a=20
  program dynamically links to a DLL. (See Chapter 10.)=20
  <LI><I>Fixups</I>: If the executable is moved, it is moved as a unit =
so all=20
  fixups have the same value, the difference between the actual load =
address and=20
  the target address. The fixup table, if present, contains an array of =
fixup=20
  blocks, each containing the fixups for one 4K page of the mapped =
executable.=20
  (Executables with no fixup table can only be loaded at the linked =
target=20
  address.) Each fixup block contains the base RVA of the page, the =
number of=20
  fixups, and an array of 16 bit fixup entries. Each entry contains in =
the low=20
  12 bits the offset in the block that needs to be relocated, and in the =
high 4=20
  bits the fixup type, e.g., add 32 bit value, adjust high 16 bits or =
low 16=20
  bits (for MIPS architecture). This block-by-block scheme saves =
considerable=20
  space in the relocation table, since each entry can be squeezed to two =
bytes=20
  rather than the 8 or 12 bytes the ELF equivalent takes. </LI></UL>
<P>
<H3>Running a PE executable</H3>Starting a PE executable process is a =
relatively=20
straightforward procedure.=20
<UL>
  <LI>Read in the first page of the file with the DOS header, PE header, =
and=20
  section headers.=20
  <LI>Determine whether the target area of the address space is =
available, if=20
  not allocate another area.=20
  <LI>Using the information in the section headers, map all of the =
sections of=20
  the file to the appropriate place in the allocated address space.=20
  <LI>If the file is not loaded into its target address, apply fixups.=20
  <LI>Go through the list of DLLs in the imports section and load any =
that=20
  aren't already loaded. (This process may be recursive.)=20
  <LI>Resolve all the imported symbols in the imports section.=20
  <LI>Create the initial stack and heap using values from the PE header. =

  <LI>Create the initial thread and start the process. </LI></UL>
<P>
<H3>PE and COFF</H3>A Windows COFF relocatable object file has the same =
COFF=20
file header and section headers as a PE, but the structure is more =
similar to=20
that of a relocatable ELF file. COFF files don't have the DOS header nor =
the=20
optional header following the PE header. Each code or data section also =
carries=20
along relocation and line number information. (The line numbers in an =
EXE file,=20
if any, are collected in in a debug section not handled by the system =
loader.)=20
COFF objects have section-relative relocations, like ELF files, rather =
than RVA=20
relative relocations, and invariably contain a symbol table with the =
symbols=20
needed. COFF files from language compilers typically do not contain any=20
resources, rather, the resources are in a separate object file created =
by a=20
specialized resource compiler.=20
<P>
<P>COFF files can also have several other section types not used in PE. =
The most=20
notable is the .drective section which contains text command strings for =
the=20
linker. Compilers usually use .drective to tell the linker to search the =

appropriate language-specific libraries. Some compilers including MSVC =
also=20
include linker directives to export code and data symbols when creating =
a DLL.=20
(This mixture of commands and object code goes way back; IBM linkers =
accepted=20
mixed card decks of commands and object files in the early 1960s.)=20
<P>
<H3>PE summary</H3>The PE file format is a competent format for a =
linearly=20
addressed operating system with virtual memory, with only small amounts =
of=20
historical baggage from its DOS heritage. It includes some extra =
features such=20
as ordinal imports and exports intended to speed up program loading on =
small=20
systems, but of debatable effectiveness on modern 32 bit systems. The =
earlier NE=20
format for 16 bit segmented executables was far more complicated, and PE =
is a=20
definite improvement.=20
<P>
<H2>Intel/Microsoft OMF files</H2>The penultimate format we look at in =
this=20
chapter is one of the oldest formats still in use, the Intel Object =
Module=20
Format. Intel originally defined OMF in the late 1970s for the 8086. =
Over the=20
years a variety of vendors, including Microsoft, IBM, and Phar Lap (who =
wrote a=20
very widely used set of 32 bit extension tools for DOS), defined their =
own=20
extensions. The current Intel OMF is the union of the original spec and =
most of=20
the extensions, minus a few extensions that either collided with other=20
extensions or were never used.=20
<P>
<P>All of the formats we've seen so far are intended for environments =
with=20
random access disks and enough RAM to do compiler and linker processing =
in=20
straightforward ways. OMF dates from the early days of microprocessor=20
development when memories were tiny and storage was often punched paper =
tapes.=20
As a result, OMF divides the object file into a series of short records, =
Figure=20
25. Each record contains a type byte, a two-byte length, the contents, =
and a=20
checksum byte that makes the byte-wise sum of the entire record zero. =
(Paper=20
tape equipment had no built-in error detection, and errors due to dust =
or sticky=20
parts were not rare.) OMF files are designed so that a linker on a =
machine=20
without mass storage can do its job with a minimum number of passes over =
the=20
files. Usually 1 1/2 passes do the trick, a partial pass to find the =
symbol=20
names which are placed near the front of each file, and then a full pass =
to do=20
the linking and produce the output.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><A href=3D"http://www.iecc.com/linker/linkerfig03-25.html"><IMG=20
      height=3D31 =
src=3D"http://www.iecc.com/linker/thumb-linker03-25.jpg"=20
      width=3D100></A> </TD>
    <TD><I>Figure 25:</I> OMF record format <BR>picture of <BR>-- type =
byte=20
      <BR>-- two-byte length <BR>-- variable length data <BR>-- checksum =
byte=20
  </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>OMF is greatly complicated by the need to deal with the 8086 =
segmented=20
architecture. One of the major goal of an OMF linker is to pack code and =
data=20
into a minimum number of segments and segment groups. Every piece of =
code or=20
data in an OMF object is assigned to a segment, and each segment in turn =
can be=20
assigned to a segment group or segment class. (A group must be small =
enough to=20
be addressed by a single segment value, a class can be any size, so =
groups are=20
used for both addressing and storage management, while classes are just =
for=20
storage management.) Code can reference segments and groups by name, and =
can=20
also reference code within a segment relative to the base of the segment =
or the=20
base of the group.=20
<P>
<P>OMF also contains some support for overlay linking, although no OMF =
linker I=20
know of has ever supported it, taking overlay instructions instead from =
a=20
separate directive file.=20
<P>
<H3>OMF records</H3>OMF currently defines at least 40 record types, too =
many to=20
enumerate here, so we'll look at a simple OMF file. (The complete spec =
is in the=20
Intel TIS documents.)=20
<P>
<P>OMF uses several coding techniques to make records as short as =
possible. All=20
name strings are variable length, stored as a length byte followed by=20
characters. A null name (valid in some contexts) is a single zero byte. =
Rather=20
than refer to segments, symbols, groups, etc. by name, an OMF module =
lists each=20
name once in an LNAMES record and subsequently uses a index into the =
list of=20
names to define the names of segments, groups, and symbols. The first =
name is 1,=20
the second 2, and so forth through the entire set of names no matter how =
many=20
LNAMES records they might have taken. (This saves a small amount of =
space in the=20
not uncommon case that a segment and an external symbol have the same =
name since=20
the definitions can refer to the same string.) Indexes in the range 0 =
through=20
0x7f are stored as one byte. Indexes from 0x80 through 0x7fff are stored =
as two=20
bytes, with the high bit in the first byte indicating a two-byte =
sequence.=20
Oddly, the low 7 bits of the first byte are the high 7 bits of the value =
and the=20
second byte is the low 8 bits of the value, the opposite of the native =
Intel=20
order. Segments, groups, and external symbols are also referred to by =
index,=20
with separate index sequences for each. For example, assume a module =
lists the=20
names DGROUP, CODE, and DATA, defining name indexes 1, 2, and 3. Then =
the module=20
defines two segments called CODE and DATA, referring to names 2 and 3. =
Since=20
CODE is the first segment defined, it will be segment index 1 and DATA =
will be=20
segment index 2.=20
<P>
<P>The original OMF format was defined for the 16 bit Intel =
architecture. For 32=20
bit programs, there are new OMF types defined for the record types where =
the=20
address size matters. All of the 16 bit record types happened to have =
even=20
numerical codes, so the corresponding 32 bit record types have the odd =
code one=20
greater than the 16 bit type.=20
<P>
<H3>Details of an OMF file</H3>Figure 26 lists the records in a simple =
OMF file.=20

<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 26 --></TD>
    <TD><I>Figure 26:</I> Typical OMF record sequence <BR>THEADR program =
name=20
      <BR>COMENT flags and options <BR>LNAMES list of segment, group, =
and class=20
      names <BR>SEGDEF segment (one record per segment) <BR>GRPDEF group =
(one=20
      record per group) <BR>PUBDEF global symbols <BR>EXTDEF undefined =
external=20
      symbols (one per symbol) <BR>COMDEF common blocks <BR>COMENT end =
of pass1=20
      info <BR>LEDATA chunk of code or data (multiple) <BR>LIDATA chunk =
of=20
      repeated data (multiple) <BR>FIXUPP relocations and external ref =
fixups,=20
      each following the LEDATA or LIDATA to which it refers <BR>MODEND =
end of=20
      module </TD></TR></TBODY></TABLE></CENTER>
<P>The file starts with a THEADR record that marks the start of the =
module and=20
gives the name of the module's source file as a string. (If this module =
were=20
part of a library, it would start with a similar LHEADR record.)=20
<P>
<P>The second record is a badly misnamed COMENT record which contains=20
configuration information for the linker. Each COMENT record contains =
some flag=20
bits saying whether to keep the comment when linked, a type byte, and =
the=20
comment text. Some comment types are indeed comments, e.g., the compiler =
version=20
number or a copyright notice, but several of them give essential linker =
info=20
such as the memory model to use (tiny through large), the name of a =
library to=20
search after processing this file, definitions of weak external symbols, =
and a=20
grab-bag of other types of data that vendors shoe-horned into the OMF =
format.=20
<P>
<P>Next comes a series of LNAMES records that list all of the names used =
in this=20
module for segments, groups, classes, and overlays. As noted above, the =
all the=20
names in all LNAMES are logically considered an array with the index of =
the=20
first name being 1.=20
<P>
<P>After the LNAMES record come SEGDEF records, one for each segment =
defined in=20
the module. The SEGDEF includes an index for the name of the segment, =
and the=20
class and overlay if any it belongs to. Also included are the segment's=20
attributes including its alignment requirements and rules for combining =
it with=20
same-name segments in other modules, and its length.=20
<P>
<P>Next come GRPDEF records, if any, defining the groups in the module. =
Each=20
GRPDEF has the index for the group name and the indices for the segments =
in the=20
group.=20
<P>
<P>PUBDEF records define "public" symbols visible to other modules. Each =
PUBDEF=20
defines one or more symbols within a single group or segment. The record =

includes the index of the segment or group and for each symbol, the =
symbol's=20
offset within the segment or group, its name, and a one-byte =
compiler-specific=20
type field.=20
<P>
<P>EXTDEF records define undefined external symbols. Each record =
contains the=20
name of one symbol and a byte or two of debugger symbol type. COMDEF =
records=20
define common blocks, and are similar to EXTDEF records except that they =
also=20
define a minimum size for the symbol. All of the EXTDEF and COMDEF =
symbols in=20
the module are logically an array, so fixups can refer to them by index. =

<P>
<P>Next comes an optional specialized COMENT record that marks the end =
of pass 1=20
data. It tells the linker that it can skip the rest of the file in the =
first=20
pass of the linking process.=20
<P>
<P>The rest of the file consists of the actual code and data of the =
program,=20
intermixed with fixup records containing relocation and external =
reference=20
information. There are two kinds of data records LEDATA (enumerated) and =
LIDATA=20
(iterated). LEDATA simply has the segment index and starting offset, =
followed by=20
the data to store there. LIDATA also starts with the segment and =
starting=20
offset, but then has a possibly nested set of repeated blocks of data. =
LIDATA=20
efficiently handles code generated for statements like this Fortran:=20
<P><TT><BR>INTEGER A(20,20) /400*42/=20
<P></TT>
<P>A single LIDATA can have a two- or four-byte block containing 42 and =
repeat=20
it 400 times.=20
<P>
<P>Each LEDATA or LEDATA that needs a fixup must be immediately followed =
by the=20
FIXUPP records. FIXUPP is by far the most complicated record type. Each =
fixup=20
requires three items: first the target, the address being referenced, =
second the=20
frame, the position in a segment or group relative to which the address =
is=20
calculated, and third the location to be fixed up. Since it's very =
common to=20
refer to a single frame in many fixups and somewhat common to refer to a =
single=20
target in many fixups, OMF defines fixup <I>threads</I>, two-bit codes =
used as=20
shorthands for frames or targets, so at any point there can be up to =
four frames=20
and four targets with thread numbers defined. Each thread number can be=20
redefined as often as needed. For example, if a module includes a data =
group,=20
that group is usually used as the frame for nearly every data reference =
in the=20
module, so defining a thread number for the base address of that group =
saves a=20
great deal of space. In practice a GRPDEF record is almost invariably =
followed=20
by a FIXUPP record defining a frame thread for that group.=20
<P>
<P>Each FIXUPP record is a sequence of subrecords, with each subrecord =
either=20
defining a thread or a fixup. A thread definition subrecord has flag =
bits saying=20
whether it's defining a frame or target thread. A target thread =
definition=20
contains the thread number, the kind of reference (segment relative, =
group=20
relative, external relative), the index of the base segment, group or =
symbol,=20
and optionally a base offset. A frame thread definition includes the =
thread=20
number, the kind of reference (all the kinds for target definition plus =
two=20
common special cases, same segment as the location and same segment as =
the=20
target.)=20
<P>
<P>Once the threads are defined, a fixup subrecord is relatively simple. =
It=20
contains the location to fix up, a code specifying the type of fixup (16 =
bit=20
offset, 16 bit segment, full segment:offset, 8 bit relative, etc.), and =
the=20
frame and target. The frame and target can either refer to previously =
defined=20
threads or be specified in place.=20
<P>
<P>After the LEDATA, LIDATA, and FIXUPP records, the end of the module =
is marked=20
by a MODEND record, which can optionally specify the entry point if the =
module=20
is the main routine in a program.=20
<P>
<P>A real OMF file would contain more record types for local symbols, =
line=20
numbers, and other debugger info, and in a Windows environment also info =
to=20
create the imports and exports sections in a target NE file (the =
segmented 16=20
bit predecessor of PE), but the structure of the module doesn't change. =
The=20
order of records is quite flexible, particularly if there's no end of =
pass 1=20
marker. The only hard and fast rules are that THEADER and MODEND must =
come first=20
and last, FIXUPPs must immediately follow the LEDATA and LIDATA to which =
they=20
refer, and no intra-module forward references are allowed. In =
particular, it's=20
permissible to emit records for symbols, segments, and groups as they're =

defined, so long as they precede other records that refer to them.=20
<P>
<H3>Summary of OMF</H3>The OMF format is quite complicated compared to =
the other=20
formats we've seen. Part of the complication is due to tricks to =
compress the=20
data, part due to the division of each module into many small records, =
part due=20
to incremental features added over the years, and part due to the =
inherent=20
complexity of segmented program addressing. The consistent record format =
with=20
typed records is a strong point, since it both permits extension in a=20
straightforward way, and permits programs that process OMF files to skip =
records=20
they don't understand.=20
<P>
<P>Nonetheless, now that even small desktop computers have megabytes of =
RAM and=20
large disks, the OMF division of the object into many small records has =
become=20
more trouble than it's worth. The small record type of object module was =
very=20
common up through the 1970s, but is now obsolescent.=20
<P>
<H2>Comparison of object formats</H2>We've seen seven different object =
and=20
executable formats in this chapter, ranging from the trivial (.COM) to =
the=20
sophisticated (ELF and PE) to the rococo (OMF). Modern object formats =
such as=20
ELF try to group all of the data of a single type together to make it =
easier for=20
linkers to process. They also lay out the file with virtual memory=20
considerations in mind, so that the system loader can map the file into =
the=20
program's address space with as little extra work as possible.=20
<P>
<P>Each object format shows the style of the system for which it was =
defined.=20
Unix systems have historically kept their internal interfaces simple and =

well-defined, and the a.out and ELF formats reflect that in their =
relative=20
simplicity and the lack of special case features. Windows has gone in =
the other=20
direction, with process management and user interface intertwined.=20
<P>
<H2>Project</H2>Here we define the simple object format used in the =
project=20
assignments in this book. Unlike nearly every other object format, this =
one=20
consists entirely of lines of ASCII text. This makes it possible to =
create=20
sample object files in a text editor, as well as making it easier to =
check the=20
output files from the project linker. Figure 27 sketches the format. The =

segment, symbol, and relocation entries are represented as lines of text =
with=20
fields separated by spaces. Each line may have extra fields at the end =
which=20
programs should be prepared to ignore. Numbers are all hexadecimal.=20
<P>
<CENTER>
<TABLE border=3D3>
  <TBODY>
  <TR>
    <TD><!-- INSERT FIGURE 27 --></TD>
    <TD><I>Figure 27:</I> Project object format <BR>LINK <BR><I>nsegs =
nsyms=20
      nrels</I> <BR>-- segments -- <BR>-- symbols -- <BR>-- rels -- =
<BR>-- data=20
      -- </TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<P>The first line is the ``magic number,'' the word <TT>LINK</TT>.=20
<P>
<P>The second line contains at least three decimal numbers, the number =
of=20
segments in the file, the number of symbol table entries, and the number =
of=20
relocation entries. There may be other information after the three =
numbers for=20
extended versions of the linker. If there are no symbols or relocations, =
the=20
respective number is zero.=20
<P>
<P>Next comes the segment definitions. Each segment definition contains =
the=20
segment name, the address where the segment logically starts, the length =
of the=20
segment in bytes, and a string of code letters describing the segment. =
Code=20
letters include R for readable, W for writable, and P for present in the =
object=20
file. (Other letters may be present as well.) A typical set of segments =
for an=20
a.out like file would be:=20
<P><TT><BR>.text 1000 2500 RP <BR>.data 4000 C00 RWP <BR>.bss 5000 1900 =
RW=20
<P></TT>
<P>Segments are numbered in the order their definitions appear, with the =
first=20
segment being number 1.=20
<P>
<P>Next comes the symbol table. Each entry is of the form:=20
<P><TT><BR>name value seg type=20
<P></TT>
<P>The name is the symbol name. The value is the hex value of the =
symbol. Seg is=20
the segment number relative to which the segment is defined, or 0 for =
absolute=20
or undefined symbols. The type is a string of letters including D for =
defined or=20
U for undefined. Symbols are also numbered in the order they're listed, =
starting=20
at 1.=20
<P>
<P>Next come the relocations, one to a line:=20
<P><TT><BR>loc seg ref type ...=20
<P></TT>
<P>Loc is the location to be relocated, seg is the segment within which =
the=20
location is found, ref is the segment or symbol number to be relocated =
there,=20
and type is an architecture-dependent relocation type. Common types are =
A4 for a=20
four-byte absolute address, or R4 for a four-byte relative address. Some =

relocation types may have extra fields after the type.=20
<P>
<P>Following the relocations comes the object data. The data for each =
segment is=20
a single long hex string followed by a newline. (This makes it easy to =
read and=20
write section data in perl.) Each pair of hex digits represents one =
byte. The=20
segment data strings are in the same order as the segment table, and =
there must=20
be segment data for each ``present'' segment. The length of the hex =
string is=20
determined by the the defined length of the segment; if the segment is =
100 bytes=20
long, the line of segment data is 200 characters, not counting the =
newline at=20
the end.=20
<P>
<P><I>Project 3-1:</I> Write a perl program that reads an object files =
in this=20
format and stores the contents in a suitable form in perl tables and =
arrays,=20
then writes the file back out. The output file need not be identical to =
the=20
input, although it should be semantically equivalent. For example, the =
symbols=20
need not be written in the same order they were read, although if =
they're=20
reordered, the relocation entries must be adjusted to reflect the new =
order of=20
the symbol table.=20
<P>
<H2>Exercises</H2>1. Would a text object format like the project format =
be=20
practical? (Hint: See Fraser and Hanson's paper "A Machine-Independent =
Linker.")=20
</BODY></HTML>

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-01.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABoAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2WeZI
kUGMkl8ABc8/hUQlZslLWRv+A4/nT5lVVVju4kX17tj+tWMgoeGAx70iCoJJvM/485MfVP8AGlWS
QtGHtCoJxlmX0PoasO6hwvzdPeoi6tJAoDHBJ7/3T/jTAfhTuAQcEU4A5PyL0rD8RahqOnvYjTLB
7nzrhUmJViETIz0IwcEnoR8p9qy7nXvE3mk2+huYuDjYxKjHH8XzZJOcAbcc5zQFjrgcFcxrkrTW
wq/dXJPA/GuNku/FjaRDcR2v+nJezExGIgNAInKKfm5y2wbgeuPcUy41nxcJ49mgBh9qZMfP/q9y
jls4Bwc7sYOCOCOQLHcADY42LQE3NjYp49a87ttY8dDzs6QJN4eRfMjZduI8hAA3A3DuSTu4PFdx
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
EAjjdnPv60HGWJ39PeiimA4AAD7/AOtFFFSB/9k=

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-03.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCACVAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2wtgn
BXr6UoHuPyqKOdJo0kjkDo4DKy8gg4wQaJ5vJtpJfncorNtUZJx26VJJLuwAAw6elMY8cEdPSuZH
i24aC0k/sa+DSqxkTY2YyM8fd56D06jGTkDU0TULrU7F7i4s5bM5G2KRSG2lQcnKjnkj8KYGkSf7
wHTtTixAPzjr6Uh9Ax7dqUj1Y/lSERNOEKhpFGTxmhpgg3O6qB1JGBUc0C7sxxMXZgS+B26Ak80s
odVzlnOcIETJU/jx/KmMkWQSIpVwVK8EClDEA85+X0qG1SVYyJNy9SMgZPrnGRU2cr95vu+lAhxb
qM88dqRmJOenPcUhI3dWzgdqCQc8t1HagYqliD0PJ7UUAD+835UUgK2madFpel2thF5jR28SxKWI
yQoA5qSSVEwrI5DEjaF3ZqYjrwev96qkgmeVfLA+WTADEjPynPP4/pQBzl/oviGXU7q60vVZYllk
V4kk5EYC7SuDxg9frz1roY557aBFug7y7cFwVG71OM1MBeZAHkr1yck/4VFcWsrRGR5VJVeAAw/9
mpgY9z440Wz89Z5Z0eKRkdPKYlQsmwtxxtz3/rxXRRuJoldVkAYBgGG0j6g8g/WsLz/D83m3Mk2m
SRKNxZ2Q7c5Oc++Sfzp2pw39+lvdaVqIhMDFtoyyTqcYB/LqAepoEbhbBAww59fakAJIYlsZPeuW
TxPPYGKHXLKSJ3OPPgVjFnOAM5PJALY69uvFdJa3EVxCksDpLE+SrpJuB69COtMCXO7aSrdPWkUN
tPB6ev8A9enenHb+9XPanY+Iby/mFnfx2tl5ShAwVyW6ngrn269+3WgDeZcZOG6etAYKxU5ByO9c
y+leKmHOsQAlxuyAfkyfl/1Y56c8Z9B1q1oum6/BceZq9/b3SeWOI1wd+ev3Rxtx+NAzfA64DdfW
ikUnn5T19aKQASuTwo5qLKgwnKtmUkH2IYipT1OWXrUO+MwwEEAZGB0I4oEWRgEZC9+9V7lk+zs2
EAC56+lL9ngYglVY8n5yW/mahuILb7PIfIhOI2Odg9KAMZvBOhGV3FjEdxDn97IOQCo/i9CR9DW0
yNBbokaR7ItoADkkgdunPFcw3ijxJ5sijw0+wyKFbLYVPl3Z45PL9OOB1HJ6TSL+e/02O5vLM2Uz
k5gc5K4bAJ6dQAfxpgSzLFOoingiZGbvgjpSWVpHZxLDEkMcCHEaIMBRzUz7MtvkBQsMeoP1pmSS
RFcxsQxB3LnB9OCKAJAuSPu4xxULRobhAwByh43HHGP8aJLiaKI58rIBwRn+Xeq9pemeVPOUROqM
Crd+V5FAE3k2j4kWNBt4yDtxU0KojShQoG8Zyc9hXDLYa6YpIk1+0UsoXd0YjYQxPy/eLbTnngY9
x1trexGIRvcxGTeqZDA72CAnHTPQnp2NIZpYwTjbiikToeR19KKAEJ5Oc9fSoVRHgjUM4AwV456c
dqmY54JbqO1MVWUBSxJB9BQIiMbrgC4fJzyUH+FL9mlkiKvcuMqQcIKsKORy3fqKCMADc2MelAXG
OFYYJbp2yKiKyZOyVsZHDrn/AOvUpH3gC3T0peRn7/b0pgRBiCRKpAJx0yD+lcre2tx4b1ttZtif
7OuZD9uQ4ATqfMBIz1J49frx1PzSTyM5bEbAKvvgHP60skCXCbJlLIScqQMGgAtbmG8jjngl3owy
rKOxrF1Twrpmpaul9cJM0zIOVYgErjGQOvGR/hUmh6Q2iz3kEU7GyLhoIT1jz15zyCf5epJrYZHk
aJ0Ygrk/Nz2oA5S2+HOgxWrQzxSXD+WE3n5flByAMfTr9au2PhLSdPvluIInWWCYOjE9T5YTnj0z
+dbjLN8xEqdP7n/2VLGhG/eSzMQxwMeg9fagCVX68nr/AHaKauMt97r60UrIB5UgdGzx3qPyyJSw
VyGPOD0469aeVOfuj86CCOijrQAocEhRkkEg803JIHytnHrRtUkNsUPyM96ZFCYz98tx/Fj+goAk
6DlW+760O3PQ9u9RZbeVMORj72R/+unumOQi0xDZItx3LvV8jkN1+tMCTx8lQ/P8LEH+dS7d4YbU
znpmkwF6qnX1oAqyjzCHKXCMvOBjnBzjuKhku4GihnacwwKjF2aTYFIxwfSr/GcEIBz3/wDrVQu7
KC4Rbb7NHJG8bFk8wrzlcHI5BHHNAFKLXvD7xxuuqQ4li8xS10R8uBycnj7w6+tbMaBZJcbsbgMF
ye3vXN/8Ibo5idDo1qEdArL9pflR0HA6cCt+2Vl84MkYIYABXyPujuRQMtBSC3B6+tFKpPPyr19a
KAEJXP8ABzigBO2zg1W07UI9T0621CAlYbiJJVDLggEZGatgsc8jOf7tIBhC8HK9fSkUA7W+Tp6U
/BAGD1P900KG+Uhu3900ANO1lHK5xXKXHjG5t7qaB9BvZCjzIrxxnYQhbbzjqwXPpyOa6vHHXnH9
2uPns/ECTXEtjrKSI9w5AIDBPnfK/dJ+Vdq49R145YE174pazkBi0O6bdbJc71hPIPVCAMhh6Vp6
NrLazHK8lhPZmN9oE6gbuO3P+QRWP5fiIwyQLqccl2syMS2AVhOeCAvU7QM+zc8VYlsPFMjTmDUb
aMTcJkljFk5yPkwcLx9cnI6AA6Bom5KygnJ+U4A/MDNZ2qWrXVhPYm8WJ5bV4xPjG0sRg8Htj1rT
gEv2eESsWkUAMcZyccnoP5CszWLzUbRfN0y1F1MFG6IgjKjceD2JIA/GmIxrLR9TgvI55vEd1PEj
o3lfZ3IYAEFevQ59+mTmupt5Q0k56ZYdVx2FcnceKfEMZ+bwvcBOFDeYcAlwvZSe5PA9OxzXVW7u
zPvVkdkVyh5wSMY/SkMuK+M5K9aKbu5OWbr6UUWAEjjgiWGNdkaKFRUXAUDoBxUgzk5LZyO1NHJP
DdPWggkHhhgjvSAU9iWY4J7Ui4AX5m6elA6YIfr/AHqFXJAAccdM/wD16AE52ZBb7vpXO3fgvRrq
5e4dJ0lIlZmjfGTIWLHp1+b9AOldEFOwYD8L60NyrfKeR6//AF6YHK/8K90MLgR3G0IsWC/VQCMd
OfvE56/hxXUxxiNFjjXaq8BVXAAx0xS9Mna3Ud6XnO7DdfWkBGTggAv1Pao1T/TGJL4MY5wPU1Ng
nA2sOT3ppwskZYvkkqBnr39famIcSAuPn6egqBtwu5Cd3zRDHA7E/wCIqZ1JUcP93+9/9emNGWk3
7WyEIzu9fx9qAHgNk/e6+1FDZB6N+f8A9eimA/B3Nwc4/vGgrnOfUfxGm8cthOnrTiV5GI+o71Ix
vzA/j/eNKA24evP8Ro2p6J1oTYSMhAeaYAMhBkc7f71KRwSR245puAcZCfdp21MH7nSgQEkEjA5I
70uM5OO/rTDtycbOopTtOfudaAA9B8vc96MZIygOM4yabkbs5Tg0B1yo+TkkGgA28DKjG31o2sVb
Cr931oG3aMlORTe5HygFOtACuuG+6KKR8A4G3p6UVSEShsL95Tx6Uu7IJ3LjPpSEcHJbp6Upx03M
Bn0/+tUFAW5wHGAfSmBjwS69T0FODYOSWxnjj/61IDkg7m6njb/9agAD5UYI+7zxRvJBww6c8UBg
MYLdP7v/ANagD5c5blfT/wCtTAXJyScdu1G4nOHHX0pG4HBb8qTdyRlhz6f/AFqQCknjDDOfSopZ
lhCyPKEjUsWYjAGAc556U8nnGW6+lQXaq6xB/MeMuwkUITkFWHYe9MRTTxNosrlf7UswVyOXAz8o
bjJ54IPFTWOq2WpB3tLtJvLLxsEzwynBz/noc96zF8M+HleJhpcgaMEoRHJlTgDcPQ4A568VdsLK
zsZiLK1eFZNzyERkbmPOTkdaBmhNnfye392inuwLfx/lRVJ6Eu5IM8jJ+7mlwTnk9qKKzLGlcHqe
tBGABk9T3ooouFhVjBx8zdPWjbgDk9PWiii4CSL8xXJwR60iqDk88N60UU0wHmMc8n73rTTGBj5m
ySe9FFK4rCKM45PT1pFXAPJ5HrRRTuArLzwT+dFFFUtiXuf/2Q==

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-04.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABfAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2a1hF
pYwWwleQQxrHvc5ZsADJ9+Kz9avL63hhXTpLBZ3dt322TapQKSSMc8YH4ZrVduOCPzqpfWFtfRr9
otoZWQ/KXVSVyQDjI7jrSJOUfXde2NJJfeH4UR8blmZywOQDxnqeR9ORXTaXfvdabFNPcWkkh4d7
Z8x7s4wCefb61WGh2MUMiraWyoxyw2RgHnv8lMm0tZdNNpbRWflO2WhdQImG4nOFAycgUAawuEDh
fMTdjONwz1pY7lJPuyIenQiuR/4RS5h2y2lpoUcqY25jk4APGDnil0rwpcWGoxXYt9KjMZCgxB9w
TkHGTjJB60xHVpMsjEBgSOuDVL+3dMWVo21G3EiHBXzVzxn/AANX920/KBnjgEVQTSNP3bv7Psyd
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
miGf/9k=

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-05.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABxAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD1rUfE
Wl6TIsV7diF2AIG1jkE4HQHvWb/wnWgNKEjvS5I/hjbjkDnI/H8Ppm9eWeqy3MslndW8KtEqLviD
MGDZJz3GOMe9UH0vVorIQx6rDburhk8mFUQLggjaPUkN9aRJuWt3Ff2yXUEm+GVQyNyMgjrgipSM
jG7jPZvasaLUL6C1hjIjv5wziV1ZYQcHjaD1wDz9PeiHWL55GD2kCLgFM3iEt+X86lySdjWNCco8
ytb1X+ZqRhipwx4YYLE+tIjP55DOSuOOcDr9P61ntqOpiVVFpEU3INwuF4BHPHfBrUQSZJds56Yx
xVJpkSg47/mmOLEr1GOf4qie8tkdka4iVhxtaQA5PSpjuAPB7+lZM+h6bNd3NxLaCSafHmOzfeAC
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
A/3T+NP7N/ntRRSAVaKKKQz/2Q==

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-07.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAC9AGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2pBGS
2F7/AN2mTyRRwgthQO5GBUw3An5Rn61VuwzWhJRTtIYjPoQaRAguIHCsFZhn+CJm/kKDeRJuZYJn
wOghI/nStPdKVxaHA7eYKZJc3IBxp8pJxwHT/GgZGup2wVmkDquT1ib/AAqz58AMSb13OAVXHLfQ
d6pvcXYjcnT2xtbOJVrM1Hwsmp32lalJdTwXFkAUWMrt3fLycrz0oA6BriASldygrwR6d6qf21pm
M/a4trTm3DDp5igkrn1wp/KubuPh5Z3lxPM1/eJNNI0hdSgOW3bs/Lz99sZzjgDirJ8Bae+lPpjP
I0LXUlzkhc7njZDn5ecbyR7gelAHQfbLYwhy6KMgYJHBPQfWnRahZTXLwpPG0sRCuoPIJBIH14Nc
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
YOo4FgOAvU9/eiiPIX7xPJ9PWik9w1P/2Q==

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-08.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABiAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2GW5u
Vukjit1cspb/AFmMAEe3uKU3kyb99nKCPQg/yo2MNSjJc5ET46eq1U1O51KPTdRlsrV5LmJD9nTg
+Y304/nSJJ4r+Wa3SSKzkZWAIO4Cmy31xFLCjWLgyvsU+YvXBP8AIGuEju/HzNZynThF9ngYPGqA
q5Ixk/NycjIX6c81JFe/EGKxj/0OKWcSgbZYhuGQ5LZDdM7V9ge/WjQDuxNeMzAWQz7zCoEu7uTz
kW0/1bFW/ejGcZ9PeuZttS8df2lElxpsQtjeeXI6oB+5yvI+bsCx5444J6HtgMIw3kZz2H+FPQDP
e5vYxGZLPALqCTKO5x2q+DIHBwvIP8X09qgv1PkqRIx/eIOg/vD2qyEIYZcngnkCloITdJknC8+/
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
v70u4+YOT0ooqkC2As29vmPX1ooopiP/2Q==

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-09.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAA9AGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2tuA2
Mjj1pSRwcN+dNYDJ+c4I9qildluo4llwrIxJwCeCP8akknG3auVP0pkaquSEO4nJOeeT/wDWFRmO
T5CLtgM5IKryMfShlYgbbpx83cLz+lMRKXALfKwx70/crk4B6DvWYJGlDFZ5vXmMHPHsKkUXJ3ES
N7fIo/maALwA+QYbgetJlRj7559elUraadoo2IBbGCSwHP4ZqXzZ8ciPr2k9/wDdpgZeteIn0mfy
/wCy725RkZjJCCQpAJAOM9cY9qyx41keVCPDusAP93MeON23n065FdQ3nFWO9F465z/QUy2tRbyt
Is7kv94Ek5/MmgNDnNU8WahDdm2sdDu5fJdRJI2QGUuq/L6nkn6Y9eH6d4qudRura2GhahEkkih5
5gVVcozZHHIyuM8Dn8+nVwNnzNyPSnbvkPztnPp7/SjUWhDH5mDujbOe7c4op6Mfm+Zuvp/9aimL
QlbcAwyOnpVa5klF3bxxhWfa5OeBtGB+eSPyqaVwkbHYCccD1PQVVlRxe2527m2OTjj+7/jUFjpL
mdZoYTFFukBIO89se3vRLJcRqn+qG5wvAJxn8RTXEjSW832fasTEsSw5G0j+eKkkjmuIVxAVPmK/
JXoGBx1oAfi5CuPPix7Rn/4qj/SlyQ8TYHTaVz+poZ2BYC3Y9zyv+NRzzvFDJIbYjahPLL/jTEOt
m8u0jaRkG7LnHQZOf61Ql8S6RFJLG+pWyGHJkBYcAZz3/wBk8deKuxQRtbxqYUD7QGYcE4HrWRP4
L0K4keeXTlaVywLec/RiS3GcDJJPHfmgDUbVLB1CrqFr+8ICfvF+YkcAc857VXl13S4JhHJqVsjl
/K2s3IYbicjPH3ScnjAzWY3gjSBcQzwQSW7QyJIRFM3zlMFQ2c8ZGTjGTyTmrUnhDRri5aWSwG9p
JJSyzOCWkGHPXjIA+nbFAGrBKJQhSZGUgEMvIII7HvUxJK/eAOfT3qpaafBYQQJBHhI0CKpcnAwB
3+gq0oO0nYvX+v0piEwQSNy8e1FOXdz8ijmimIZKd11Em1uAXPPpx/WmzErexuI5CojYZXnklf8A
A0suUuI2ycEFOnc8/wBKmDZIyT054qCis8u4QoYpdrNzxnOAT/SphMduPKm6/wBfrWXqevadpBtx
fXTwZLshMZbcEXLdAex/HtWdJ8QPD0cnl/b3LcFsQP8AID0z8vHUD68daYHR+YfnxBNn8P8AGo5S
0geN7eXaykHkHr+NOt7yG6hM0M29D0K8joDTmWKSX5twbH3lyD+dADbbcttBvRwxUFhnvj61LnPR
W688+9U7qO8W1ZbOUNcEHyzMPlztOAcDpnFc3IvjdJDLt0/5EIRMnDOdvJ46Ag/mfamI7EgYfCN0
9fb60hxuxsbOPX/69ZOjyaubST+2Y1ScyHaYFyu3HH9fwxWsPv4y/Trj/wCtQGg0EAJlG/P2+tLj
K5Kt9719/rQQpCAl8Z67fb6UHAGNz4z6f/WoAYzAMQUY/wDAv/r0USFd33n6en/1qKtbCZy/hfx/
pfjC6ubGGKa3nRPMVZQPnUHqCDwRkcUxvE2vWuoSQSaEJv8ASPLDJKQNp8zaeRwcRjPOBvU9+G+D
vh5p/hi/uL2O5muJyhRC4ACLnngd+BzXYlFYjcM4Gaz0L1MC2lXXNKt59W0YRSTb0eGRfM8tSCOu
O4449a04dL01Uk8uxtAJQFceSuGAwAD7cDitCNVCIAAKaTnIwODQA1sKrKCgUdAB7UHIPVenXFPK
jy3pF5f8DSAavAQ71P4e1Nckjl1xu/rUu3aq47f4U11GPxpiImclXAkXp6f/AF6k3fMP3i9P896C
AVc+1OwPlOO1FwsRByyp86/5FKTjnzFwT/nvTx/q0P8AnpQCMHIzg07isRPtLZ3pzRUrAE9AKKpP
QGf/2Q==

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-10.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABXAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD1nXNR
utPitntbJrvfMEkVByq4PP6VhzeLNSiS6P8Awj07OjEQkElZBtPOcdNw9uCK3tY0+71C3ijtNSms
HSQOzxqGLLgjb198/hWNJ4Y1Q4LeJLsuq7VbZ0Py843YJ+X0zyep5qSS1pGu3eoam9tc6TLax+UZ
Emf7rcj5eQDnqe3Hat7g4+7jjtWDY6DqVvfQ3Mmu3c0aEb4mX5WwCMfe9x69B1PNbUzMIvlLAkqO
AO5xTAcSu4YK9fSgYweV6elYuqa1DpMaPcfamVpDGPLVScgEnrj0/UVBL4osLZd8zXoiJkVZBDuV
9hAJG0HIOeD9aAN/juRwfSlBVjnjof4a52PxXpN3crBFc3pdnCqVgOCckY+77fTmtwK8dwg3yFSr
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
me1ADH5Q/O0dqKKYEgUqSNx60UUUgP/Z

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-14.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCACMAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2Kcvu
O2R1AA4GOSSfY+lc8PF9m0M7Kuos0Mnl+XsTfId4T5B1PJFXNd1MaaDI1ncXQZQDHb8scZPAxye+
B2B9Kwv+Eo06O9a2Xw7qX2hEaYL5fzEA43DnPOPzpWJNa48W6RZXTW97eXNrKJAmJYuCSqtjIBHR
hn0qunjrQJHZP7TuSFjEhPkEgggnjC5zgfqO9QP4himQuPDWqSEKZAZFOMhQcdTzzjp2om1y3tb8
2yeGLyTazBpY4SV2jIBBxySOg9D1p2A6ptyGJ/NlKuejKB2z6DHSq91rFraJFLcziGJ92Gk+XOPr
9R+nqKzNJ1s6ncQhtKurNwGYidiMFQoIAPUEvwfY1rGwgu4oft1vC7I29VPRT9P1+v0pAVo/Eeky
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

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-22.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABUAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2ogsQ
M9z/AA1lmVkuFSbUI43ZC6xiPBI69z6VpszLGxGc8nPHvWFrmiaZqckbX1xLHtiMexXRQQehORnj
nv8AXIpEl8XNvKm9dR3AqHyu37p79OnFSbkQlDeOWHJGB0/KsCPw9oge5LXzyLcxtHKGkjAbc+9m
wAOcj6AcAVF/wiehB4XGpXv7snA+0qQfl285HIwOh47HjigDp4o45UV0nchlyMEnt/8AXpYc+Ty5
OTkZXJxmsfQvDmmaRIsllcXMzLGVHmSh9oIX2/2R/LpWxBn7OhO7lVPagRMWxgDnH+yaQtgDPcf3
aAxOOG6+opJIjJs64XnPFAx+75uDxxxtppYgg9Of7tQRKVJzK7EEIcilnjy6uZHXLADHJ/CgCfcA
AQcfL/dNOLZbr6djVMQTEkGViCODxnrn6VYSN487mdySD2AHsKBD88nBxz6UUuCScFhzRSGRSjMW
CFwWA6+ppnkW+ATDD0/uipLjzDGoVlHzjqpPf61GUn2YNwvTtF/9emIJba1cbvs8R5HAUUR29uef
JRQD0ximOtwuQLleMEnyv/r07yrk4JuwOe8P/wBegBGht0hZjGnCE/ep8USRxKigHAGcsTUNxFdG
0kH2lMeW2f3Pt9asqJkYb5lZe+I8f1oAcEXd1TP1pCflwAvT1p2cnIIPPoeaYxJTrjK9hTAhWFGQ
r5m7dg5yPXOelPeBGCoXPy5A+bB6daZHamIL++kYDHBzzzUrRl33byD0zt6UARJFHGV+Yk7e7mrO
VJ/h7d6riB9il5WLhTyBxnjtTo4mVwWldsY4K96ALAXPQL+dFKpIz8x6/wB2ipGQTEhAQpP7xeOP
UUrNIUBWLBx3b/Co5m2xgkL/AKxe/uKlDjAJCkYPemIgcTsxBhTOQTiU/wCFPBuSf9Ug5/56Hn9K
V5Y1cgqT06A/4U5ZMtkoF57kUwK87XBtpFKIBtIyHJ/pVthjA+Y9O9V7ogwnAUZGP1FSsRz909O/
vQA5gcAbT19fagYC8huh70wEMckKDn19qMrjACdD1NAh3JY5DADGOaXqeQ3X19qTcuMYTPFJ8pOP
k6+vtQAp6DCt370pHGcN270DGBwnOaCBjjZ0FADlGc5Ddf71FNUdfudaKQyG4AYKGdh+8XgDGeaV
4FK9WIwe5ouNwjGFJPmLwT7ilfzsABBjB/jP+FADXhjI24IJx609IEQ9WPPqagZJlbLIjNxgtIRj
6cUu66Y8RRnnvKf8KAJJ2Plr8x+8vb/aFSl8dznj+H3qnK0/lorQAfOORJnuPargUEEnPbjNMQm4
s3BbH09qQZ6ZPf8Ahqk82oR3cojtRJD/AAHzAp6UtxcXqgrFZkttOD5o649/f+VTzI19k9NV95d5
IJDN26CkBIbGT19Pas9LnUhGw+wZbb94ygc9uM1LLNegIyWJJO7K+cOMYx+fNHMg9jLuvvRcDHOM
nv8Aw0BmK9WHA7VSkmvlmxHZF0+Yf60DvwaYl5fOGI08gfdAabBwM80cyD2MrXuvvRohuWyW69hR
SRFjGDJGQ+Bkbs4OKKZmRXEgCD7n+sXHPuKDKv8ACM/QUs7KAhdwq7xknjsagN7ZtwLlW9Qhz/Kg
AeRQW/0ZyTjn5T/WljuBHkeRN97uAe31pBcwp9xpSowQPIY9/pT/ALYrNnbOBu/54P6fSmAjyiRU
HlEAuMbhj+IVPtXk5GeKrTT70GxZywYHHksP4hntVncRyu7HHagRTksDLdGUXRi3EAqvcAdM5+tV
7yBIZXn+2GMMTkgZ4GWI6+mfyrWDAseW6+ntTJIkkGJEDrzwy59vSpaNo1ZJq+3yMqcxSDMWrRLl
g2N3BGenWmFYVkbOq7MSHKscE8n3zjtWkLS2UACBAFAIxGOPpxSyWlq+5ngRsnktGDn9KXKzRVor
TX8ClFCl0EQairyIWbcMZGeP8fzqWXT/ADrdYzd8BAGJGd5znJ5q1FbQxMrLGFIzghACP0qb7ykg
t90dqfL3M3Wd/de3oNRVVcZTjjp7UU/Iyclvy/8ArUUzIFQE4OTz3NIyjJHPfvRRQMYBkkHPGO9S
7Rx16+vtRRQxDQMZwT37+9Kv3e/Qd6KKAF2gHjPr1pMfMOvOe9FFIY0gAY5xj1pcAuRz19aKKYhy
xgkZLdT3NCoOmT09TRRSuFgZQGPX8zRRRRcD/9k=

------=_NextPart_000_002A_01C557A1.1FB0D180
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: http://www.iecc.com/linker/thumb-linker03-25.jpg

/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy
MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAfAGQDASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD2Tfhc
CRM5HUf/AF6o3884NvHBLCrSSFSzqSBwx6ZHpVsuQTl1+8OgqjfCRljlWWJfJcvucHHQjt9aSRUd
xjPqCzxZvLQgk9IG/wDi6lMd8zBvt1qAev7k/wDxdMigvpVhlubq3jwS3lrCSQcEYJ3Y7+lJK12u
wm7iOTtCmEnOT/vCnYocJbpJ47d7q3w0bMHCHtj/AGvf9KljEzQKHuYN+3h1jIA6dix/nUCWd0ZE
aS7iOI2UFIiCCSOeSfT0qcQSCBIlu3BK/wCsKDd/LH6UWE2h+G8vak8Yfb9/Z/TNOXdhg08bfIAD
twSfXrUKsXmVTM37tMsAowc+v5dqV0mZWK3I5AxlMhRz06frRYQ03Nw08sKyQHZGpLHI5Jbtz6et
PjlkNxNFNLCQiI+VB7lhzz7UyaKWN3uEuEUtEqkNEW6bueCPWi3E2+ad5oX3ooHloQMDd7n1osPQ
tcgHEkfbH+c0AkZVpFXkZI/Cm7yRksO38NKX3AjePvD+E+1BIqyoCwBQgHH+eaKFiJLHKHn0opaB
oYviCfXVKy6UYDGAoKSRklmz/Lp+Z74rIkufFE11BbFLfzEKyONhwCCdxHbuNueODnnFdNq2nx6j
YNbO5CmWN+gPKMrjqOmVFcwngxGVVudbvS7IEZomKljncST19MemB6U0g5kjShvdW07Rbm+1ZPPu
POVlijUgBSEUgcZ+9vIHXFZLfEHTDbx3Zs9TMSBnU+SoGd23GS2M8k+mPfiuyW5iUgecxwT1H/1q
huJrK7t2t7kJNCx+aOSMMvByOCMelNRfYSkjE0DxYda1F7b+z7u3RA5SVgCrbX24PcHGDj/JteIN
TvrIWaadYXNyZpAsjpGxEa7l3HhTzgkjoOD9DpC9tk2KZyOP7n/1qb/aVtGqfvm6dl/+tT5Jdh8y
ObsPE2s3F9bRXHhq8ghuGCs21v3Q5BZspjsPTg11gICYDN0GRt/+tVf+04JCp84hdv8Ad/8ArVIt
/bBA3nfLjH3f/rUOEuwXRW1fUZ9PtRJb281y5cJtRGO0HOWOFJwPYdx061zS+KdVto/LfwxfjciM
7IreWpZQSR8uQAW5GMjBxmuta8gAb98QMf3f/rUNfWwV8Ttnbn7p6flRyS7BzI5ZfFWsNPLE/h6/
CedKqSiFyNiH5TjbnkdOnNW9O8RalfXsUE2hX1tC5XMzjG3IJ5BUf3SPxHrW819AS5W4OCB/Cf8A
Cn/bLdc5mI5H8P8A9ajll2DmQ9cktyRz6f8A1qKiGpW+5sTnGf7p/wAKKOSXYXMu5//Z

------=_NextPart_000_002A_01C557A1.1FB0D180--
